<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Pretty Good Scouting App (Pro)</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@500&family=Bangers&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<style>
/* --- THEME & RESET --- */
:root {
  --bg: #050505; --panel: #121212; --card: #1e1e1e; --border: #2a2a2a;
  --text: #ffffff; --muted: #888; --green: #34d399; --red: #f87171;
  --yellow: #fbbf24; --blue: #60a5fa; --purple: #a78bfa; --diamond: #22d3ee;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); padding-bottom: 120px; -webkit-font-smoothing: antialiased; overflow-x: hidden; }
.app { max-width: 480px; margin: 0 auto; min-height: 100vh; position: relative; border-left: 1px solid var(--border); border-right: 1px solid var(--border); }

/* --- SPLASH SCREEN --- */
#splash-screen {
    position: fixed; inset: 0; z-index: 9999; background-color: #000;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    transition: opacity 0.8s ease-out, visibility 0.8s;
}
.splash-hidden { opacity: 0; visibility: hidden; pointer-events: none; }
.splash-bg { position: absolute; inset: 0; z-index: 0; }
.splash-bg img { width: 100%; height: 100%; object-fit: cover; }
.splash-bg::after {
    content: ''; position: absolute; inset: 0;
    background: linear-gradient(135deg, rgba(0,0,0,0.85) 0%, rgba(10,10,30,0.9) 100%);
}
.splash-content { position: relative; z-index: 10; text-align: center; width: 100%; padding: 0 20px; }
.big-title {
    font-family: 'Inter', sans-serif; font-weight: 900; text-transform: uppercase;
    line-height: 0.9; letter-spacing: -0.05em; display: flex; flex-direction: column; gap: 0;
    text-shadow: 0 4px 30px rgba(0,0,0,0.8);
}
.big-title span { font-size: 3.5rem; }
@media(min-width: 400px) { .big-title span { font-size: 4.5rem; } }

/* --- HEADER --- */
header { padding: 12px 16px; background: var(--bg); position: sticky; top: 0; z-index: 50; border-bottom: 1px solid var(--border); }
.status-row { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
.status-badge {
    font-size: 10px; font-weight: 700; color: var(--muted);
    background: rgba(255,255,255,0.05); padding: 4px 10px; border-radius: 99px;
    display: flex; align-items: center; gap: 6px; border: 1px solid transparent; transition: all 0.2s;
}
.status-badge.live { color: var(--green); border-color: rgba(52, 211, 153, 0.2); background: rgba(52, 211, 153, 0.1); }
.status-badge.dead { color: var(--red); border-color: rgba(248, 113, 113, 0.2); background: rgba(248, 113, 113, 0.1); }
.status-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

/* --- RESTRICTED BADGE --- */
.restricted-badge {
  display: inline-flex; align-items: center; gap: 4px;
  background: rgba(248, 113, 113, 0.15); color: var(--red);
  border: 1px solid rgba(248, 113, 113, 0.3);
  padding: 3px 8px; border-radius: 4px;
  font-size: 10px; font-weight: 700; text-transform: uppercase;
}
.restricted-count {
  display: inline-flex; align-items: center; gap: 6px;
  color: var(--red); font-size: 12px; font-weight: 600;
}
.btn-remove-restricted {
  background: rgba(248, 113, 113, 0.2); color: var(--red);
  border: 1px solid rgba(248, 113, 113, 0.3);
  padding: 6px 12px; border-radius: 8px;
  font-size: 11px; font-weight: 700; cursor: pointer;
  transition: all 0.2s;
}
.btn-remove-restricted:hover {
  background: rgba(248, 113, 113, 0.3);
}

.search-container { position: relative; display: flex; gap: 8px; }
.input-wrapper { position: relative; flex: 1; }
.search-icon { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 16px; }
input[type="text"] {
  width: 100%; padding: 14px 14px 14px 42px; border-radius: 12px; background: #111; border: 1px solid #333;
  color: white; font-family: 'Inter', sans-serif; font-size: 16px; outline: none; transition: all 0.2s;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
input[type="text"]:focus { border-color: var(--blue); background: #161616; }
.icon-btn {
    width: 48px; border-radius: 12px; border: 1px solid #333; background: #111;
    color: var(--muted); font-size: 18px; cursor: pointer; display: grid; place-items: center; transition: all 0.2s;
}
.icon-btn.active { color: var(--green); border-color: rgba(52, 211, 153, 0.4); background: rgba(52, 211, 153, 0.1); }

/* --- ENHANCED CAMERA OVERLAY --- */
#camera-overlay { 
  position: fixed; inset: 0; z-index: 9999; background: #000; 
  display: flex; flex-direction: column;
}

#camera-header {
  position: absolute; top: 0; left: 0; right: 0; z-index: 10001;
  padding: 20px; background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  text-align: center;
}

.camera-title {
  font-size: 18px; font-weight: 800; color: #fff; margin-bottom: 8px;
}

.camera-mode-toggle {
  display: flex; gap: 8px; justify-content: center; margin-top: 12px;
}

.mode-btn {
  background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.6);
  border: 2px solid rgba(255,255,255,0.2); padding: 8px 20px;
  border-radius: 99px; font-weight: 700; font-size: 13px;
  cursor: pointer; transition: all 0.2s;
}

.mode-btn.active {
  background: rgba(96,165,250,0.2); color: var(--blue);
  border-color: var(--blue);
}

.mode-btn:hover:not(.active) {
  background: rgba(255,255,255,0.15);
}

.camera-status {
  font-size: 13px; font-weight: 600; color: var(--blue); 
  padding: 6px 16px; background: rgba(96,165,250,0.15); 
  border-radius: 99px; display: inline-block;
  border: 1px solid rgba(96,165,250,0.3);
}

.camera-status.detecting {
  color: var(--yellow); background: rgba(251,191,36,0.15);
  border-color: rgba(251,191,36,0.3);
  animation: pulse 1s ease-in-out infinite;
}

.camera-status.success {
  color: var(--green); background: rgba(16,185,129,0.15);
  border-color: rgba(16,185,129,0.3);
}

.camera-status.error {
  color: var(--red); background: rgba(239,68,68,0.15);
  border-color: rgba(239,68,68,0.3);
}

#reader { 
  width: 100%; height: 100%; flex: 1; position: relative;
}

/* Animated Scan Frame */
.scan-frame {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: 300px; height: 180px; z-index: 10000; pointer-events: none;
}

/* ISBN Frame - Wider for text */
.isbn-frame {
  width: 280px; height: 80px;
}

.isbn-hint {
  position: absolute; bottom: -35px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.7); font-size: 12px; font-weight: 600;
  white-space: nowrap; text-align: center;
}

.scan-corner {
  position: absolute; width: 40px; height: 40px;
  border: 3px solid var(--blue); opacity: 0.8;
}

.scan-corner.top-left { top: 0; left: 0; border-right: none; border-bottom: none; }
.scan-corner.top-right { top: 0; right: 0; border-left: none; border-bottom: none; }
.scan-corner.bottom-left { bottom: 0; left: 0; border-right: none; border-top: none; }
.scan-corner.bottom-right { bottom: 0; right: 0; border-left: none; border-top: none; }

.scan-line {
  position: absolute; top: 0; left: 0; right: 0; height: 2px;
  background: linear-gradient(90deg, transparent, var(--green), transparent);
  animation: scanLine 2s ease-in-out infinite;
  box-shadow: 0 0 10px var(--green);
}

@keyframes scanLine {
  0% { top: 0; opacity: 0; }
  50% { opacity: 1; }
  100% { top: 100%; opacity: 0; }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.camera-footer {
  position: absolute; bottom: 0; left: 0; right: 0; z-index: 10001;
  padding: 30px; background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  display: flex; justify-content: center;
}

#close-camera {
  background: rgba(239,68,68,0.2); color: var(--red); 
  border: 2px solid var(--red); padding: 14px 32px;
  border-radius: 99px; font-weight: 800; font-size: 16px; 
  cursor: pointer; transition: all 0.2s;
  display: flex; align-items: center; gap: 8px;
}

#close-camera:hover {
  background: var(--red); color: #fff;
}

#close-camera:active {
  transform: scale(0.95);
}


/* --- CARD --- */
.card {
  margin: 16px; background: var(--panel); border-radius: 20px; border: 1px solid var(--border);
  overflow: hidden; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.5); animation: slideUp 0.3s ease-out;
}
@keyframes slideUp { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }

.banner { padding: 32px 24px; text-align: center; position: relative; }
.banner.buy { background: linear-gradient(180deg, #064e3b 0%, var(--bg) 100%); }
.banner.gem { background: linear-gradient(180deg, #064e3b 0%, var(--bg) 100%); } 
.banner.reject { background: linear-gradient(180deg, #7f1d1d 0%, var(--bg) 100%); }
.banner.consider { background: linear-gradient(180deg, #78350f 0%, var(--bg) 100%); }

.score-container { position: relative; width: 140px; height: 140px; margin: 0 auto 16px auto; display: flex; align-items: center; justify-content: center; }
.score-svg { position: absolute; top:0; left:0; width:100%; height:100%; transform: rotate(-90deg); }
.score-circle-bg { fill: none; stroke: rgba(255,255,255,0.05); stroke-width: 5; }
.score-circle-fg { fill: none; stroke: currentColor; stroke-width: 5; stroke-linecap: round; transition: stroke-dashoffset 1s; stroke-dasharray: 440; stroke-dashoffset: 440; animation: pulse-ring 2s ease-in-out infinite; }
@keyframes pulse-ring {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}
.score-num { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 64px; font-weight: 700; color: #fff; letter-spacing: -0.04em; z-index: 2; background: linear-gradient(135deg, var(--green), var(--diamond)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-feature-settings: 'tnum'; }

/* REPOSITIONED GEM ICON (FIXED) */
.gem-icon {
    position: absolute; 
    top: 10px; 
    left: 50%;
    margin-left: 80px; /* Positions it next to the 140px score ring */
    font-size: 28px; 
    filter: drop-shadow(0 0 15px rgba(34, 211, 238, 0.8)); 
    animation: float 3s ease-in-out infinite; 
    display: none; 
}
.gem-icon.visible { display: block; }
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }

.decision-label {
  font-family: 'Inter', -apple-system, sans-serif;
  font-size: 28px; font-weight: 800; text-transform: uppercase; 
  padding: 0; border-radius: 0; display: inline-block; margin-top: 0; box-shadow: none; letter-spacing: 1px;
}
.decision-label.buy { background: transparent; color: var(--green); text-shadow: 0 2px 10px rgba(52, 211, 153, 0.3); }
.decision-label.consider { background: transparent; color: var(--yellow); text-shadow: 0 2px 10px rgba(251, 191, 36, 0.3); }
.decision-label.reject { background: transparent; color: var(--red); text-shadow: 0 2px 10px rgba(248, 113, 113, 0.3); }

#geminiQuickBadge {
    display: inline-flex; align-items: center; gap: 6px; margin-top: 10px; padding: 6px 14px; border-radius: 99px;
    background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
    color: var(--purple); font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em;
}
#geminiQuickBadge:active { transform: scale(0.96); }
.gemini-style-good { background: rgba(52, 211, 153, 0.15); border-color: var(--green); color: var(--green); }
.gemini-style-neutral { background: rgba(167, 139, 250, 0.1); border-color: var(--purple); color: var(--purple); } /* NEUTRAL (PASS) */
.gemini-style-bad { background: rgba(248, 113, 113, 0.15); border-color: var(--red); color: var(--red); }

.condition-toggle {
  display: flex; background: rgba(0,0,0,0.3); border-radius: 99px; padding: 4px; margin: 20px auto 16px auto;
  width: fit-content; border: 1px solid var(--border);
}

.category-badge {
  display: inline-block; background: rgba(167,139,250,0.15); 
  color: var(--purple); padding: 3px 8px; border-radius: 99px;
  font-size: 9px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.05em; border: 1px solid rgba(167,139,250,0.3);
}
.cond-btn { padding: 6px 16px; border-radius: 99px; font-size: 12px; font-weight: 700; color: var(--muted); cursor: pointer; }
.cond-btn.active { background: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }

.slider-container { background: rgba(0,0,0,0.2); border-radius: 12px; padding: 16px 12px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.05); }
.slider-container.collapsed { padding: 0; }
.slider-container.collapsed .slider-content { display: none; }
.adjuster-summary { padding: 12px 16px; cursor: pointer; font-size: 12px; color: var(--muted); text-align: center; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.2s; }
.adjuster-summary:hover { color: var(--blue); }
.slider-content { padding-top: 8px; }
.slider-content { padding-top: 8px; }
.slider-row { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
.slider-row:last-child { margin-bottom: 0; }
.slider-header { display: flex; justify-content: space-between; font-size: 11px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; font-family: 'Inter', sans-serif; }
.slider-val { color: var(--blue); font-family: 'Inter', sans-serif; font-weight: 700; }
input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--blue); cursor: pointer; margin-top: -6px; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}
input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #333; border-radius: 2px; }

.profit-display { margin-bottom: 12px; }
.profit-val { font-size: 36px; font-weight: 600; font-family: 'JetBrains Mono', monospace; letter-spacing: -0.02em; color: #ffffff; }

.item-title { margin: 6px 0 10px 0; font-size: 14px; color: rgba(255,255,255,0.8); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; height: 40px; font-weight: 800; }

.link-row { display: flex; justify-content: center; gap: 8px; margin-bottom: 12px; }
.ext-link {
  font-size: 10px; font-weight: 700; color: var(--muted); text-decoration: none;
  background: rgba(255,255,255,0.05); padding: 6px 12px; border-radius: 6px; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1); cursor: pointer;
}
.ext-link:hover { color: #fff; border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); }

.ai-box {
  margin-bottom: 16px; padding: 12px; border-radius: 8px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
  font-size: 13px; line-height: 1.5; color: #fff; text-align: left; cursor: pointer; transition: background 0.2s; position: relative;
}
.details-panel { background: rgba(255,255,255,0.03); border-top: 1px solid var(--border); }
.details-summary { padding: 16px; cursor: pointer; font-size: 13px; color: var(--muted); text-align: center; font-weight: 600; }
.details-body { padding: 0 20px 20px; text-align: left; }

.insight-grid { display: grid; gap: 12px; margin-bottom: 16px; }
.insight-box { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); text-align: left; }
.insight-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.insight-tags { display: flex; flex-wrap: wrap; gap: 6px; }
.tag { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #fff; }
.tag.good { background: rgba(16,185,129,0.2); color: var(--green); }
.tag.bad { background: rgba(239,68,68,0.2); color: var(--red); }
.tag.warn { background: rgba(251,191,36,0.2); color: var(--yellow); }
.tag.gem { background: rgba(34, 211, 238, 0.15); color: var(--diamond); border: 1px solid rgba(34,211,238,0.3); box-shadow: 0 0 5px rgba(34,211,238,0.2); }

/* Plain English Trigger Signal Badges */
.signals-container {
  display: flex; flex-wrap: wrap; gap: 6px; margin: 12px 0;
  padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.1);
}
.signal-badge {
  font-size: 10px; font-weight: 700; padding: 5px 10px;
  border-radius: 6px; display: inline-flex; align-items: center; gap: 4px;
  text-transform: uppercase; letter-spacing: 0.03em;
  cursor: help; transition: all 0.2s;
  border: 1.5px solid;
}
.signal-badge:hover {
  transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.signal-badge.signal-good {
  background: rgba(52, 211, 153, 0.15); color: var(--green);
  border-color: rgba(52, 211, 153, 0.4);
}
.signal-badge.signal-warn {
  background: rgba(251, 191, 36, 0.15); color: var(--yellow);
  border-color: rgba(251, 191, 36, 0.4);
}
.signal-badge.signal-bad {
  background: rgba(248, 113, 113, 0.15); color: var(--red);
  border-color: rgba(248, 113, 113, 0.4);
}
.signals-title {
  font-size: 10px; font-weight: 700; color: var(--muted);
  text-transform: uppercase; letter-spacing: 0.05em;
  margin-bottom: 6px;
}

.metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px; margin-top: 12px; }
.metric { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 10px; text-align: center; }
.metric-lbl { font-size: 9px; color: var(--muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
.metric-val { font-size: 13px; font-weight: 700; color: #fff; }

.keepa-embed img { max-width: 100%; height: auto; display: block; margin: 0 auto; border-radius: 8px; }

/* TOGGLES (Restored) */
.toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.toggle-switch {
  width: 44px; height: 24px; background: #333; border-radius: 99px; position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle-switch::after {
  content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: transform 0.2s;
}
.toggle-switch.active { background: var(--green); }
.toggle-switch.active::after { transform: translateX(20px); }

/* --- PAGES --- */
#settingsPage, #historyPage {
  position: fixed; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px;
  background: var(--bg); z-index: 3000; padding: 24px;
  display: flex; flex-direction: column; border-left: 1px solid var(--border); border-right: 1px solid var(--border);
}
.settings-header { font-size: 20px; font-weight: 800; margin-bottom: 24px; text-align: center; }
.settings-content { flex: 1; overflow-y: auto; }
.settings-group { margin-bottom: 24px; }
.label { display: block; font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--muted); text-transform: uppercase; }
.settings-input { width: 100%; padding: 14px; background: var(--panel); border: 1px solid var(--border); color: white; border-radius: 12px; font-family: 'JetBrains Mono', monospace; }
.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: auto; }
.btn-main { width: 100%; padding: 16px; border-radius: 12px; border: none; font-weight: 700; font-size: 14px; cursor: pointer; }
.btn-save { background: var(--green); color: #000; }
.btn-back { background: var(--panel); color: #fff; border: 1px solid var(--border); }

.actions {
  position: fixed; bottom: 0; left: 0; right: 0; background: rgba(5,5,5,0.95); backdrop-filter: blur(10px);
  padding: 16px; border-top: 1px solid var(--border); display: flex; gap: 12px; z-index: 100; max-width: 480px; margin: 0 auto;
}
.act-btn { flex: 1; padding: 14px; border: none; border-radius: 12px; font-weight: 700; font-size: 14px; cursor: pointer; transition: transform 0.1s; }
.act-btn:active { transform: scale(0.96); }
.btn-set { flex: 0 0 50px; background: var(--panel); color: #fff; border: 1px solid var(--border); display: grid; place-items: center; font-size: 20px; }
.btn-hist { background: var(--blue); color: #fff; }
.btn-dl { background: var(--green); color: #fff; }
.btn-cam { background: rgba(34,211,238,0.2); color: var(--diamond); border: 1px solid rgba(34,211,238,0.4); font-size: 18px; }

/* === UPGRADED DESIGN CSS === */
.item-title { 
  font-size: 18px !important; font-weight: 800 !important; color: #fff !important; line-height: 1.3 !important; 
  margin-bottom: 16px !important; text-align: center !important; padding: 0 20px !important; 
  min-height: 48px !important; display: flex !important; align-items: center !important; justify-content: center !important;
  height: auto !important; -webkit-line-clamp: unset !important;
}

/* Keepa Restricted Badge */
.keepa-restricted {
  position: absolute; top: 10px; right: 10px; background: rgba(239,68,68,0.2); border: 2px solid var(--red);
  color: var(--red); font-size: 10px; font-weight: 800; padding: 4px 10px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
  animation: pulse-badge 2s ease-in-out infinite;
}
@keyframes pulse-badge { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

/* Visual Meter Pricing */
.pricing-meter {
  background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px 12px 10px; margin-bottom: 12px;
}
.meter-row { margin-bottom: 12px; text-align: center; }
.meter-row:last-child { margin-bottom: 0; }
.meter-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; letter-spacing: 0.05em;
}
.meter-value {
  font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-bottom: 6px;
}
.meter-bar {
  height: 6px; background: rgba(255,255,255,0.05); border-radius: 99px; overflow: hidden; position: relative;
}
.meter-fill {
  height: 100%; border-radius: 99px; transition: width 0.3s ease;
}
.meter-fill.green { background: linear-gradient(90deg, var(--green), rgba(16,185,129,0.6)); }
.meter-fill.blue { background: linear-gradient(90deg, var(--blue), rgba(96,165,250,0.6)); }

/* Compact Sliders */
.adjusters-compact {
  background: rgba(0,0,0,0.2); border-radius: 10px; padding: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);
}
.adjuster-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.adjuster-row:last-child { margin-bottom: 0; }
.adjuster-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); min-width: 40px; letter-spacing: 0.05em;
}
.adjuster-slider { flex: 1; }
.adjuster-value {
  font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 700; color: var(--blue); min-width: 45px; text-align: right;
}

/* Why This Score Section */
.reasoning-section {
  background: rgba(255,255,255,0.03); border-radius: 10px; padding: 10px; margin-bottom: 10px;
}
.reasoning-header {
  font-size: 10px; font-weight: 800; text-transform: uppercase; color: var(--muted); margin-bottom: 8px;
  letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
}
.signal-item {
  display: flex; align-items: flex-start; gap: 6px; margin-bottom: 6px; padding: 6px;
  background: rgba(0,0,0,0.2); border-radius: 6px;
}
.signal-item:last-child { margin-bottom: 0; }
.signal-icon { font-size: 14px; flex-shrink: 0; margin-top: 0; }
.signal-text { flex: 1; }
.signal-text strong {
  display: block; font-size: 11px; font-weight: 700; margin-bottom: 2px; line-height: 1.3;
}
.signal-text p {
  font-size: 10px; color: var(--muted); line-height: 1.3; margin: 0;
}

/* Gemini Second Opinion */
.gemini-opinion {
  background: rgba(16,185,129,0.08);
  border-top: 2px solid rgba(16,185,129,0.4);
  border-bottom: 2px solid rgba(16,185,129,0.4);
  border-left: none;
  border-right: none;
  border-radius: 0;
  padding: 20px;
  margin: 0;
}
.gemini-opinion.loading {
  background: rgba(96,165,250,0.08); border-color: rgba(96,165,250,0.3);
}
.gemini-opinion.upgrade {
  background: rgba(16,185,129,0.08); 
  border-top-color: rgba(16,185,129,0.4);
  border-bottom-color: rgba(16,185,129,0.4);
}
.gemini-opinion.downgrade {
  background: rgba(239,68,68,0.08); 
  border-top-color: rgba(239,68,68,0.4);
  border-bottom-color: rgba(239,68,68,0.4);
}
.gemini-header {
  display: flex; align-items: center; justify-content: center; margin-bottom: 16px;
  padding-bottom: 0; border-bottom: none;
}
.collapse-icon {
  color: rgba(255,255,255,0.5); cursor: pointer; font-size: 18px; font-weight: 800;
  padding: 4px 8px; transition: all 0.2s;
}
.collapse-icon:hover {
  color: rgba(255,255,255,0.9); background: rgba(255,255,255,0.1); border-radius: 4px;
}
.gemini-content.hidden {
  display: none;
}
.gemini-title {
  font-family: 'Inter', sans-serif;
  font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
  color: var(--green); display: flex; align-items: center; gap: 6px;
}
.gemini-title.upgrade { color: var(--green); }
.gemini-title.downgrade { color: var(--red); }
.score-comparison {
  display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 16px;
}
.score-box { text-align: center; }
.score-box-label {
  font-family: 'Inter', sans-serif;
  font-size: 9px; font-weight: 600; text-transform: uppercase; color: var(--muted); margin-bottom: 4px; letter-spacing: 0.5px;
}
.score-box-value {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size: 32px; font-weight: 700; line-height: 1; font-feature-settings: 'tnum';
}
.score-box-value.amber { color: var(--yellow); }
.score-box-value.green { color: var(--green); }
.score-box-value.red { color: var(--red); }
.score-arrow { font-size: 28px; font-weight: 800; }
.score-arrow.up { color: var(--green); }
.score-arrow.down { color: var(--red); }
.gemini-verdict {
  text-align: center; font-size: 11px; font-weight: 800; padding: 6px 14px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
}
.gemini-verdict.upgrade {
  background: rgba(16,185,129,0.2); color: var(--green); border: 2px solid rgba(16,185,129,0.4);
}
.gemini-verdict.downgrade {
  background: rgba(239,68,68,0.2); color: var(--red); border: 2px solid rgba(239,68,68,0.4);
}
.gemini-text {
  font-family: 'Inter', sans-serif;
  font-size: 13px; line-height: 1.6; color: rgba(255,255,255,0.9); text-align: left;
  background: rgba(0,0,0,0.3);
  padding: 14px;
  border-radius: 8px;
  border-left: 3px solid var(--green);
  font-weight: 500;
}
.gemini-text strong {
  font-weight: 700;
}

/* Key Info Section - Simplified for mockup */
.key-info {
  padding: 24px; background: rgba(0,0,0,0.3);
}

.price-profit-grid {
  display: flex; flex-direction: column; gap: 20px;
}

.info-box {
  display: flex; justify-content: space-between; align-items: center;
  border-radius: 0; padding: 0; text-align: left;
  transition: none; position: relative; border: none; background: none; box-shadow: none;
}

.info-box.price-box {
  border: none; background: none; box-shadow: none;
}

.info-box.profit-box {
  border: none; background: none; box-shadow: none;
}

.info-label {
  font-family: 'Inter', sans-serif;
  font-size: 11px; font-weight: 600; text-transform: uppercase;
  color: var(--muted); margin-bottom: 0; letter-spacing: 0.5px;
}

.info-value {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size: 28px; font-weight: 600; font-feature-settings: 'tnum';
}

.info-value.price { color: var(--diamond); }
.info-value.profit { color: var(--green); }

/* Time Badge - Shown inline with profit */
.profit-with-time {
  display: flex;
  align-items: baseline;
  gap: 10px;
}
  gap: 6px;
}

.time-badge {
  font-family: 'Inter', sans-serif;
  font-size: 15px;
  font-weight: 600;
  padding: 0;
  border-radius: 0;
  text-transform: none;
  letter-spacing: 0;
  white-space: nowrap;
  transition: none;
  background: none;
  border: none;
  color: var(--orange);
}

.time-badge.fast {
  background: none;
  color: var(--orange);
  border: none;
}

.time-badge.medium {
  background: none;
  color: var(--orange);
  border: none;
}

.time-badge.slow {
  background: none;
  color: var(--orange);
  border: none;
}

/* Collapsible Sections */
.collapsible-section {
  margin: 12px 16px; border-radius: 12px; overflow: hidden;
  border: 2px solid; transition: all 0.2s;
}

.collapsible-section.score-section {
  border-color: rgba(251,191,36,0.4);
  background: rgba(251,191,36,0.05);
  box-shadow: 0 0 20px rgba(251,191,36,0.15);
}

.collapsible-section.pricing-section {
  border-color: rgba(34,211,238,0.4);
  background: rgba(34,211,238,0.05);
  box-shadow: 0 0 20px rgba(34,211,238,0.15);
}

.collapsible-header {
  padding: 14px 16px; cursor: pointer;
  display: flex; justify-content: space-between; align-items: center;
  transition: background 0.2s; user-select: none;
}

.collapsible-header:hover {
  background: rgba(255,255,255,0.03);
}

.collapsible-header:active {
  transform: scale(0.99);
}

.collapsible-title {
  font-size: 12px; font-weight: 800; text-transform: uppercase;
  letter-spacing: 0.05em; display: flex; align-items: center; gap: 8px;
}

.collapsible-title.score-title { color: var(--yellow); }
.collapsible-title.pricing-title { color: var(--diamond); }

.chevron {
  font-size: 14px; color: var(--muted); transition: transform 0.3s ease;
}

.collapsible-section.open .chevron {
  transform: rotate(180deg);
}

.collapsible-body {
  padding: 16px; border-top: 1px solid rgba(255,255,255,0.1);
  font-size: 11px; line-height: 1.6; display: none;
  animation: slideDown 0.3s ease-out;
}

.collapsible-section.open .collapsible-body {
  display: block;
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes flashBlue {
  0% { box-shadow: 0 0 20px rgba(96,165,250,0.2); }
  50% { box-shadow: 0 0 40px rgba(96,165,250,0.8), 0 0 60px rgba(96,165,250,0.4); transform: scale(1.02); }
  100% { box-shadow: 0 0 20px rgba(96,165,250,0.2); transform: scale(1); }
}

@keyframes flashGreen {
  0% { box-shadow: 0 0 20px rgba(52,211,153,0.2); }
  50% { box-shadow: 0 0 40px rgba(52,211,153,0.8), 0 0 60px rgba(52,211,153,0.4); transform: scale(1.02); }
  100% { box-shadow: 0 0 20px rgba(52,211,153,0.2); transform: scale(1); }
}

/* Controls Section */
.controls-section {
  padding: 16px; background: rgba(0,0,0,0.2);
  border-top: 1px solid var(--border);
}

/* Update condition toggle to be centered and have proper spacing */
.controls-section .condition-toggle {
  margin: 0 auto 16px auto;
  display: flex;
  width: fit-content;
}

/* Signal items in Why Score section */
.signal-item {
  display: flex; align-items: flex-start; gap: 6px; margin-bottom: 6px; padding: 6px;
  background: rgba(0,0,0,0.2); border-radius: 6px;
}
.signal-item:last-child { margin-bottom: 0; }
.signal-icon { font-size: 14px; flex-shrink: 0; margin-top: 0; }
.signal-text { flex: 1; }
.signal-text strong {
  display: block; font-size: 11px; font-weight: 700; margin-bottom: 2px; line-height: 1.3;
}
.signal-text p {
  font-size: 10px; color: var(--muted); line-height: 1.3; margin: 0;
}

/* Buy Box Narrative */
.bb-narrative {
  background: rgba(34, 211, 238, 0.08);
  border-left: 3px solid var(--diamond);
  padding: 14px;
  border-radius: 8px;
  margin-bottom: 24px;
}

.bb-narrative-title {
  font-family: 'Inter', sans-serif;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  color: var(--diamond);
  letter-spacing: 0.5px;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.bb-narrative-text {
  font-family: 'Inter', sans-serif;
  font-size: 13px;
  line-height: 1.6;
  color: rgba(255,255,255,0.85);
  font-weight: 500;
}


/* Pricing Strategy Section (Concept 3 Style) */
.pricing-strategy {
  margin-bottom: 12px;
  background: rgba(96,165,250,0.06); border-radius: 12px;
  border: 2px solid rgba(96,165,250,0.3);
}

.pricing-strategy.wide-range {
  background: rgba(34,211,238,0.06); border-color: rgba(34,211,238,0.3);
}

.pricing-strategy.tight-range {
  background: rgba(251,191,36,0.06); border-color: rgba(251,191,36,0.3);
}

.pricing-strategy.fbm-driven {
  background: rgba(239,68,68,0.06); border-color: rgba(239,68,68,0.3);
}

.strategy-header {
  padding: 12px 14px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}

.strategy-title {
  display: flex; align-items: center; gap: 8px;
  font-size: 11px; font-weight: 800; text-transform: uppercase;
  letter-spacing: 0.05em; color: var(--blue);
}

.strategy-title.wide-range { color: var(--diamond); }
.strategy-title.tight-range { color: var(--yellow); }
.strategy-title.fbm-driven { color: var(--red); }

.strategy-icon {
  width: 28px; height: 28px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; border: 2px solid;
  background: rgba(96,165,250,0.15); border-color: var(--blue);
  color: var(--blue);
}

.strategy-icon.wide-range {
  background: rgba(34,211,238,0.15); border-color: var(--diamond);
  color: var(--diamond);
}

.strategy-icon.tight-range {
  background: rgba(251,191,36,0.15); border-color: var(--yellow);
  color: var(--yellow);
}

.strategy-icon.fbm-driven {
  background: rgba(239,68,68,0.15); border-color: var(--red);
  color: var(--red);
}

.strategy-body {
  padding: 12px 14px;
}

.strategy-type {
  font-size: 12px; font-weight: 700; margin-bottom: 8px;
}

.strategy-type.wide-range { color: var(--diamond); }
.strategy-type.tight-range { color: var(--yellow); }
.strategy-type.fbm-driven { color: var(--red); }

.strategy-details {
  font-size: 11px; color: rgba(255,255,255,0.8); line-height: 1.5;
  margin-bottom: 10px;
}

.price-range-display {
  background: rgba(0,0,0,0.3); border-radius: 8px;
  padding: 8px 10px; font-size: 11px; display: flex;
  justify-content: space-between; align-items: center;
}

.price-range-label {
  color: var(--muted); font-weight: 600;
}

.price-range-values {
  font-family: 'JetBrains Mono', monospace; font-weight: 700;
}

.price-range-min { color: var(--red); }
.price-range-max { color: var(--green); }
.price-range-separator { color: var(--muted); margin: 0 6px; }

.recommended-list-price {
  background: rgba(96,165,250,0.15); border-radius: 8px;
  padding: 10px; text-align: center; margin-top: 8px;
}

.list-price-label {
  font-size: 9px; font-weight: 700; text-transform: uppercase;
  color: var(--muted); margin-bottom: 4px; letter-spacing: 0.05em;
}

.list-price-value {
  font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
  color: var(--blue);
}

/* === DECISION TRACKING === */
.decision-section {
  padding: 16px;
  margin: 10px;
  background: none;
  border: none;
  border-radius: 0;
}

.decision-prompt {
  display: none; /* Removed per mockup */
}

.decision-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.decision-btn {
  font-family: 'Inter', sans-serif;
  height: 54px;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  border: none;
}

.decision-btn.buy {
  background: var(--green);
  color: #000;
  box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
}

.decision-btn.buy:hover {
  transform: scale(1.02);
}

.decision-btn.buy:active {
  transform: scale(0.96);
}

.decision-btn.pass {
  background: #2a2a2a;
  color: var(--red);
  border: 1.5px solid var(--red);
}

.decision-btn.pass:hover {
  transform: scale(1.02);
}

.decision-btn.pass:active {
  transform: scale(0.96);
}

.decision-btn.selected {
  animation: decisionPulse 0.5s ease;
}

@keyframes decisionPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.decision-note {
  text-align: center; font-size: 11px; color: #666;
  margin-top: 10px; font-style: italic;
}

.decision-note.success {
  color: var(--green); font-weight: 700;
}

.hidden { display: none !important; }

/* --- HISTORY & COLLAPSIBLE UI --- */
.history-item-wrapper {
    position: relative;
    margin-bottom: 10px; 
    border-radius: 10px;
    overflow: hidden;
    background: var(--panel);
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all 0.2s;
}

.history-item-content {
    padding: 12px;
    transition: transform 0.3s;
}

.delete-confirm-overlay {
    position: absolute;
    inset: 0;
    display: none; 
    background: rgba(248, 113, 113, 0.15);
    padding: 12px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
}

.delete-confirm-overlay.active {
    display: flex;
}

.delete-message {
    font-size: 13px;
    font-weight: 800;
    color: var(--red);
    margin-bottom: 10px;
}

.confirm-buttons {
    display: flex;
    gap: 10px;
    width: 100%;
}

.btn-delete-confirm {
    flex: 1;
    padding: 8px 12px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 12px;
    cursor: pointer;
    transition: transform 0.1s;
}

.btn-delete-confirm.cancel {
    background: var(--card);
    color: #fff;
    border: 1px solid var(--border);
}

.btn-delete-confirm.delete {
    background: var(--red);
    color: #fff;
    border: none;
}

/* --- PRICE DETAILS STYLES --- */
.price-metric-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 12px;
}

.price-metric-label {
    color: var(--muted);
    font-weight: 600;
}

.price-metric-value {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
}

.price-metric-value.fba { color: var(--green); }
.price-metric-value.fbm { color: var(--yellow); }
.price-metric-value.amz { color: var(--blue); }
.price-metric-value.none { color: var(--red); }


/* === SCORE EXPLANATION PANEL === */
#scoreExplanationPanel {
  background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px 15px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);
}
.score-details-header {
  font-size: 11px; font-weight: 800; text-transform: uppercase; color: var(--purple); margin-bottom: 10px;
  letter-spacing: 0.05em; display: flex; align-items: center; justify-content: space-between; cursor: pointer;
}
.score-details-content {
  font-size: 11px; line-height: 1.6; color: rgba(255,255,255,0.7);
  border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px;
}
.score-details-section {
    margin-bottom: 12px;
}
.score-details-section:last-child {
    margin-bottom: 0;
}
.score-details-title {
    font-size: 12px; font-weight: 700; color: var(--text); margin-bottom: 5px;
    display: flex; align-items: center; gap: 6px;
}
.score-details-metric-row {
    display: flex; justify-content: space-between; padding: 2px 0;
}
.metric-name {
    color: var(--muted);
    font-weight: 600;
}
.metric-value-num {
    font-weight: 700;
    color: var(--blue);
}

/* ================= MARVEL ENHANCEMENTS ================= */
@keyframes comicVibrate {
  0% { transform: translate(1px, 1px) rotate(0deg); }
  10% { transform: translate(-1px, -2px) rotate(-1deg); }
  20% { transform: translate(-3px, 0px) rotate(1deg); }
  30% { transform: translate(3px, 2px) rotate(0deg); }
  40% { transform: translate(1px, -1px) rotate(1deg); }
  50% { transform: translate(-1px, 2px) rotate(-1deg); }
  60% { transform: translate(-3px, 1px) rotate(0deg); }
  70% { transform: translate(3px, 1px) rotate(-1deg); }
  80% { transform: translate(-1px, -1px) rotate(1deg); }
  90% { transform: translate(1px, 2px) rotate(0deg); }
  100% { transform: translate(1px, -2px) rotate(-1deg); }
}

.badge-marvel {
  display: inline-block;
  animation: comicVibrate 0.3s infinite;
  font-family: 'Bangers', cursive;
  text-transform: uppercase;
  padding: 6px 12px;
  border-radius: 4px;
  border: 3px solid #000;
  box-shadow: 4px 4px 0px #000;
  margin: 4px;
  font-size: 14px;
  letter-spacing: 0.08em;
  line-height: 1;
}

.knockout { background: #ffde00; color: #000; }
.solo { background: #ed1d24; color: #fff; }
.mint { background: #22d3ee; color: #000; }
.fast-turn { background: #34d399; color: #000; }
.big-margin { background: #a78bfa; color: #fff; }
.collector-warn { background: #000; color: #ed1d24; border-color: #ed1d24; box-shadow: 4px 4px 0px #ed1d24; }
.reject-marvel { background: #000; color: #f87171; border-color: #f87171; box-shadow: 4px 4px 0px #f87171; }

.comic-burst {
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%) scale(0);
  width: 300px; 
  height: 300px; 
  background: #ed1d24; 
  color: white;
  clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
  display: flex; 
  align-items: center; 
  justify-content: center;
  font-family: 'Bangers', cursive;
  font-weight: 900; 
  font-size: 60px; 
  z-index: 10000;
  border: 5px solid black; 
  transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  pointer-events: none;
  text-shadow: 3px 3px 0px black;
}
.comic-burst.show { 
  transform: translate(-50%, -50%) scale(1.2); 
  animation: heroPulse 0.5s infinite alternate;
}

@keyframes heroPulse {
  from { transform: translate(-50%, -50%) scale(1.2); opacity: 0.9; }
  to { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
}

.marvel-math {
    background: rgba(0,0,0,0.5);
    padding: 12px;
    margin: 12px 16px;
    border-radius: 8px;
    font-size: 12px;
    border-left: 3px solid #ed1d24;
}
.marvel-math div {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    font-family: 'JetBrains Mono', monospace;
}
.marvel-math div:last-child {
    border-top: 1px solid var(--border);
    margin-top: 6px;
    padding-top: 8px;
    font-weight: 800;
    color: var(--green);
    font-size: 14px;
}
.marvel-math .bundle-bonus {
    color: var(--yellow);
    border-top: none;
    margin-top: 4px;
    padding-top: 4px;
}
</style>
</head>
<body>

<div id="splash-screen">
    <div class="splash-bg">
        <img src="https://images.unsplash.com/photo-1521587760476-6c12a4b040da?w=1200&q=80" alt="">
    </div>
    <div class="splash-content">
        <h1 class="big-title">
            <span>PRETTY</span>
            <span>GOOD</span>
            <span>SOURCING</span>
            <span>APP</span>
        </h1>
        <div style="margin-top: 2rem; color: #60a5fa; letter-spacing: 0.2em; font-size: 0.9rem; font-weight: 700; text-shadow: 0 2px 10px rgba(96,165,250,0.5);">INITIALIZING...</div>
    </div>
</div>

<div class="app">
  <div id="mainView">
    <header>
      <div class="status-row">
            <button onclick="showSourceSettings()" style="background:rgba(56,189,248,0.1);border:1px solid rgba(56,189,248,0.3);color:#38bdf8;padding:4px 10px;border-radius:6px;font-size:10px;font-weight:700;cursor:pointer;transition:all 0.2s;">‚öôÔ∏è SKU SOURCE</button>
        <div id="badgeKeepa" class="status-badge dead"><div class="status-dot"></div> Keepa</div>
        <div id="badgeGemini" class="status-badge dead"><div class="status-dot"></div> Gemini</div>
      </div>

      <div class="search-container">
        <div class="input-wrapper">
            <i class="fas fa-search search-icon"></i> 
            <input id="scanInput" type="text" placeholder="Type ISBN or Title, then search..." autocomplete="off" onkeyup="if(event.key === 'Enter') submitSearch()" />
        </div>
        <button id="btnSearch" class="icon-btn" onclick="submitSearch()" title="Search"><i class="fas fa-search"></i></button>
        <button id="btnLock" class="icon-btn" onclick="toggleFocusLock()" title="Focus Lock"><i class="fas fa-lock"></i></button>
      </div>
    </header>

    <div id="camera-overlay" class="hidden">
      <div id="camera-header">
        <div class="camera-title">üì∑ Scan Book</div>
        <div id="camera-status" class="camera-status">Ready to scan...</div>
        
        <div class="camera-mode-toggle">
          <button id="mode-barcode" class="mode-btn active" onclick="switchScanMode('barcode')">
            üìä Barcode
          </button>
          <button id="mode-isbn" class="mode-btn" onclick="switchScanMode('isbn')">
            üî¢ ISBN Text
          </button>
        </div>
      </div>
      
      <div id="reader"></div>
      
      <div class="scan-frame" id="scan-frame-barcode">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="scan-line"></div>
      </div>
      
      <div class="scan-frame isbn-frame hidden" id="scan-frame-isbn">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="isbn-hint">Position ISBN number here</div>
      </div>
      
      <div class="camera-footer">
        <button id="close-camera" onclick="stopCamera()">
          <i class="fas fa-times"></i> Close
        </button>
      </div>
    </div>

    <div id="processing" class="hidden" style="text-align:center; padding:60px;">
      <i class="fas fa-circle-notch fa-spin" style="font-size:32px; color:var(--blue);"></i>
    </div>

    <div id="scanToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:8px 16px; border-radius:99px; font-weight:bold; z-index:200;">
        Scan Detected!
    </div>

    <div id="exportToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:12px 20px; border-radius:99px; font-weight:bold; z-index:200; font-size:14px;">
        Export Complete!
    </div>

    <div class="card hidden" id="titlePickerCard">
      <div class="banner maybe">
        <div style="font-size:12px; font-weight:800; letter-spacing:0.12em; color:var(--muted); text-transform:uppercase; margin-bottom:10px;">
          Title results
        </div>
        <div style="font-size:14px; font-weight:800; margin-bottom:6px;">Pick an edition</div>
        <div id="titlePickerHint" style="font-size:12px; color:rgba(255,255,255,0.75); line-height:1.45; margin-bottom:14px;">
          Click the ID button to copy the ASIN/ISBN, then hit the Search button to fetch product data.
        </div>
        <div id="titlePickerList" style="text-align:left; margin-top:6px;"></div>
        <div style="display:flex; gap:10px; margin-top:14px; justify-content:center;">
          <button class="ext-link" onclick="closeTitlePicker()">Close ‚úñ</button>
        </div>
      </div>
    </div>


    <div class="card hidden" id="resultCard">
      <div id="banner" class="banner buy">
        <div id="keepaRestricted" class="keepa-restricted hidden">‚ö†Ô∏è RESTRICTED</div>
        
        <div id="gemIcon" class="gem-icon">üíé</div>
        
        <div style="text-align: center; margin-bottom: 6px;">
          <div id="categoryBadge" class="category-badge">üìö Category Loading...</div>
        </div>
        
        <div id="itemTitle" class="item-title">--</div>
        
        <div class="score-container">
          <svg class="score-svg" viewBox="0 0 100 100">
            <circle class="score-circle-bg" cx="50" cy="50" r="45" fill="none"></circle>
            <circle class="score-circle-fg" id="scoreRing" cx="50" cy="50" r="45" fill="none"></circle>
          </svg>
          <span id="confidence" class="score-num">--</span>
        </div>
        
        <div id="decision" class="decision-label">--</div>
      </div>
      
      <div class="key-info">
        <div class="price-profit-grid">
          <div class="info-box price-box">
            <div class="info-label">Sell For</div>
            <div class="info-value price" id="recommendedPrice">$0.00</div>
          </div>
          <div class="info-box profit-box">
            <div class="info-label">Net Profit</div>
            <div class="profit-with-time">
              <div class="time-badge hidden" id="timeBadge">~8 Days</div>
              <div class="info-value profit" id="profitValue">$0.00</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Plain English Signals (2025 Strategy) -->
      <div id="signalsContainer" class="signals-container hidden">
        <div class="signals-title">‚ö° Strategy Signals</div>
        <div id="signalsBadges" style="display: flex; flex-wrap: wrap; gap: 6px;"></div>
      </div>
      
      <div id="geminiOpinion" class="hidden"></div>
      
      <div class="collapsible-section score-section" id="whyScoreSection">
        <div class="collapsible-header" onclick="toggleSection('whyScoreSection')">
          <div class="collapsible-title score-title">
            <span><i class="fas fa-sliders-h"></i></span>
            <span>Advanced Details</span>
          </div>
          <i class="fas fa-chevron-down chevron" id="whyScoreChevron"></i>
        </div>
        <div class="collapsible-body" id="whyScoreBody">
          <!-- Buy Box Narrative -->
          <div class="bb-narrative">
            <div class="bb-narrative-title">
              <span>üì¶</span>
              <span>Buy Box Analysis</span>
            </div>
            <div class="bb-narrative-text" id="bbNarrativeText">
              Loading Buy Box analysis...
            </div>
          </div>
          
          <div id="bbSummaryBox" style="background:rgba(96,165,250,0.1); border:1px solid var(--blue); padding:10px; border-radius:6px; margin-bottom:10px; display: none;">
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px; font-weight:700; color:var(--blue); margin-bottom:4px;">
              <span>CURRENT BUY BOX PRICE (<span id="bbCond">--</span>)</span>
              <span style="font-weight:800;" id="bbPriceVal">--</span>
            </div>
            <div id="bbStatusText" style="font-size:12px; line-height:1.4;">--</div>
          </div>
          <div id="reasoningContent"></div>
        </div>
      </div>
      
      <div class="collapsible-section pricing-section" id="pricingStrategySection">
        <div class="collapsible-header" onclick="toggleSection('pricingStrategySection')">
          <div class="collapsible-title pricing-title">
            <span>üíé</span>
            <span>Pricing Strategy</span>
          </div>
          <i class="fas fa-chevron-down chevron" id="pricingStrategyChevron"></i>
        </div>
        <div class="collapsible-body" id="pricingStrategyBody">
          </div>
      </div>
      
      <div class="controls-section">
        <div class="condition-toggle">
          <div id="btnCondUsed" class="cond-btn active" onclick="setCondition('USED')">Used</div>
          <div id="btnCondNew" class="cond-btn" onclick="setCondition('NEW')">New</div>
        </div>

        <div class="adjusters-compact">
          <div class="adjuster-row">
            <span class="adjuster-label">Cost</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="50" step="0.25" value="1" id="sliderCost" />
            </div>
            <span class="adjuster-value" id="costValue">$1.00</span>
          </div>
          <div class="adjuster-row">
            <span class="adjuster-label">Floor</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="20" step="0.5" value="5" id="sliderFloor" />
            </div>
            <span class="adjuster-value" id="floorValue">$5.00</span>
          </div>
        </div>
      </div>
      
      <div style="padding: 16px;">
        <div id="keepaGraphContainer" class="keepa-embed hidden">
          <div style="text-align:center; padding:10px; color:#333; font-size:12px;">Loading Graph...</div>
        </div>

        <div class="decision-section hidden" id="decisionSection">
          <div class="decision-prompt">üìã What's Your Decision?</div>
          <div class="decision-buttons">
            <button class="decision-btn buy" onclick="recordDecision('BOUGHT')">
              <span>‚úì</span>
              <span>BUY</span>
            </button>
            <button class="decision-btn pass" onclick="recordDecision('PASSED')">
              <span>‚úó</span>
              <span>REJECT</span>
            </button>
          </div>
          <div class="decision-note" id="decisionNote">Your decision will be saved with this scan</div>
        </div>

      </div>
    </div>
  </div>

  <div id="settingsPage" class="hidden">
    <div class="settings-header">Settings</div>
    <div class="settings-content">
      <div class="settings-group">
        <span class="label">Keepa API Key</span>
        <input type="password" id="keepaKey" class="settings-input" placeholder="Paste Keepa key..." />
      </div>

      <div class="settings-group">
        <span class="label">Gemini API Key</span>
        <input type="password" id="geminiKey" class="settings-input" placeholder="Paste Gemini API key..." />
      </div>
      
      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Use Proxy Server</span>
          <div id="toggleProxy" class="toggle-switch active" onclick="toggleSetting('useProxy')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Turn OFF if you have a CORS extension installed. Direct is faster.</div>
      </div>

      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Fast Scan (90 Days)</span>
          <div id="toggleFastScan" class="toggle-switch" onclick="toggleSetting('fastScan')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Fetches less data for speed. Good for live scanning.</div>
      </div>

      <div class="settings-group">
        <span class="label">Default Buy Cost ($)</span>
        <input type="number" id="defCost" class="settings-input" value="1.00" step="0.25" />
      </div>
      <div class="settings-group">
        <span class="label">Default Profit Floor ($)</span>
        <input type="number" id="defFloor" class="settings-input" value="5.00" step="0.50" />
      </div>
    </div>
    <div class="btn-grid">
      <button onclick="closeSettings()" class="btn-main btn-back">Cancel</button>
      <button onclick="saveSettings()" class="btn-main btn-save">Save</button>
    </div>
  </div>

  <div id="historyPage" class="hidden">
    <div class="settings-header">Scan History</div>
    <div id="historyStats" style="padding: 12px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; gap: 12px;">
      <div class="restricted-count" id="restrictedCount" style="display: none;">
        <span>üîí</span>
        <span id="restrictedCountText">0 restricted</span>
      </div>
      <button onclick="removeRestrictedItems()" id="btnRemoveRestricted" class="btn-remove-restricted" style="display: none;">
        Remove Restricted
      </button>
    </div>
    <div id="historyList" style="flex:1; overflow-y:auto;"></div>
    <div class="btn-grid" style="margin-top:16px;">
      <button onclick="closeHistory()" class="btn-main btn-back">Back</button>
      <button onclick="exportCSV()" class="btn-main btn-save">Download All CSV</button>
    </div>
    <button onclick="clearHistory()" class="btn-main" 
        style="background: transparent; color: var(--red); border: 1px solid var(--red); margin-top: 10px;">
        <i class="fas fa-trash"></i> Clear All History
    </button>
  </div>

  <div class="actions">
    <button onclick="showSettings()" class="act-btn btn-set"><i class="fas fa-cog"></i></button>
    <button onclick="showHistory()" class="act-btn btn-hist" style="flex: 2;">History</button>
    <button onclick="openCamera()" class="act-btn btn-cam"><i class="fas fa-camera"></i></button>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
let CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || '',
  geminiKey: localStorage.getItem('geminiKey') || '',
  buyCost: parseFloat(localStorage.getItem('buyCost')) || 1.00,
  profitFloor: parseFloat(localStorage.getItem('profitFloor')) || 5.00,
  condition: 'USED',
  useProxy: localStorage.getItem('useProxy') !== 'false', 
  fastScan: localStorage.getItem('fastScan') === 'true' 
};

/* ================= MARVEL CONFIG ================= */
const MARVEL_CONFIG = {
    fbaFees: {
        '0-1': 3.66, '1-2': 4.75, '2-3': 5.50, '3-4': 6.10, '4-5': 7.15,
        '5-10': 8.26, '10-20': 15.06, '20+': 18.00
    },
    returnRates: {
        'NEW': 5, 'LIKE_NEW': 15, 'VERY_GOOD': 25, 'GOOD': 40, 'ACCEPTABLE': 50
    },
    universes: {
        MCU: {
            keywords: ['Avengers', 'Iron Man', 'Captain America', 'Thor', 'Black Panther', 
                      'Black Widow', 'Hulk', 'Ant-Man', 'Doctor Strange', 'Captain Marvel',
                      'Guardians of the Galaxy', 'Eternals', 'Shang-Chi', 'Hawkeye', 'Falcon',
                      'Winter Soldier', 'Scarlet Witch', 'Vision', 'Loki', 'WandaVision'],
            badge: 'üé¨ MCU PREMIUM', scoreBonus: 10, color: 'knockout'
        },
        SpiderVerse: {
            keywords: ['Spider-Man', 'Spider-Verse', 'Miles Morales', 'Spider-Gwen', 
                      'Venom', 'Carnage', 'Spider-Woman', 'Spider-Man 2099', 'Spectacular Spider',
                      'Amazing Spider', 'Ultimate Spider'],
            badge: 'üï∑Ô∏è SPIDER-VERSE', scoreBonus: 8, color: 'knockout'
        },
        XMen: {
            keywords: ['X-Men', 'Wolverine', 'Deadpool', 'Magneto', 'Phoenix', 
                      'Professor X', 'Cyclops', 'Storm', 'Rogue', 'Gambit', 'Nightcrawler',
                      'Beast', 'Jean Grey', 'Mystique', 'Cable', 'X-Force'],
            badge: '‚ö° X-MEN VELOCITY', scoreBonus: 5, color: 'fast-turn'
        },
        Cosmic: {
            keywords: ['Infinity', 'Thanos', 'Silver Surfer', 'Galactus', 'Celestials',
                      'Nova', 'Adam Warlock', 'Annihilation', 'Infinity Gauntlet', 'Infinity War'],
            badge: 'üåå COSMIC', scoreBonus: 6, color: 'big-margin'
        },
        Street: {
            keywords: ['Daredevil', 'Punisher', 'Luke Cage', 'Jessica Jones', 
                      'Moon Knight', 'Elektra', 'Defenders', 'Iron Fist', 'Heroes for Hire'],
            badge: 'ü•ä STREET LEVEL', scoreBonus: 4, color: 'mint'
        }
    }
};

let marvelInventory = JSON.parse(localStorage.getItem('fbaInventory') || '[]');
if (marvelInventory.length === 0) {
    marvelInventory = [
        { title: 'Marvel Masterworks: Avengers Vol 1', asin: 'B001' },
        { title: 'Marvel Masterworks: Avengers Vol 2', asin: 'B002' },
        { title: 'Spider-Man: The Clone Saga Vol 1', asin: 'B003' },
        { title: 'X-Men: Age of Apocalypse Vol 2', asin: 'B004' }
    ];
    localStorage.setItem('fbaInventory', JSON.stringify(marvelInventory));
}


let lastData = null;
let focusLock = false;
let scanQueue = [];
let scanHistory = JSON.parse(localStorage.getItem('scanHistory') || '[]');
let currentScan = null; // Tracks current scan for decision recording
let isProcessing = false;
let tokens = 20; 
let tokenRefill = setInterval(() => { if(tokens < 20) tokens++; updateTokenUI(); }, 3000); 

/* ================= INIT ================= */
const input = document.getElementById('scanInput');
const costSlider = document.getElementById('sliderCost');
const floorSlider = document.getElementById('sliderFloor');
const geminiReasoningHeader = document.getElementById('geminiReasoningHeader');

window.addEventListener('load', () => {
    updateTokenUI();
    resetSliders();
    updateConditionUI();
    updateToggleUI('toggleProxy', CONFIG.useProxy);
    updateToggleUI('toggleFastScan', CONFIG.fastScan);
    input.focus();
    
    document.addEventListener('click', (e) => {
        if(focusLock && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
            input.focus();
        }
    });
});

function resetSliders() {
    costSlider.value = CONFIG.buyCost;
    floorSlider.value = CONFIG.profitFloor;
    updateSliderDisplays();
}

function updateTokenUI() {
    const el = document.getElementById('badgeKeepa');
    if(CONFIG.keepaKey) {
        el.className = 'status-badge live';
        el.innerHTML = `<div class="status-dot"></div> Keepa: ${tokens}`;
    } else {
        el.className = 'status-badge dead';
        el.innerHTML = `<div class="status-dot"></div> Keepa`;
    }
}

function updateConditionUI() {
    document.getElementById('badgeGemini').className = CONFIG.geminiKey ? 'status-badge live' : 'status-badge dead';
}

function updateToggleUI(id, state) {
    const el = document.getElementById(id);
    if(el) {
        if(state) el.classList.add('active'); else el.classList.remove('active');
    }
}

function toggleSetting(key) {
    CONFIG[key] = !CONFIG[key];
    updateToggleUI(key === 'useProxy' ? 'toggleProxy' : 'toggleFastScan', CONFIG[key]);
}

/* ================= SLIDERS ================= */
function onSliderChange() {
  CONFIG.buyCost = parseFloat(costSlider.value);
  CONFIG.profitFloor = parseFloat(floorSlider.value);
  updateSliderDisplays();
  if(lastData) {
    const result = analyze(lastData);
    render(result, lastData);
  }
}
costSlider.addEventListener('input', onSliderChange);
floorSlider.addEventListener('input', onSliderChange);

/* ================= INPUT HANDLING / TITLE SEARCH (FIXED) ================= */
let titleResults = [];

async function submitSearch() {
    const val = input.value.trim();
    if(!val) return;

    // --- ENHANCED ID CHECK ---
    // Check if original has spaces - if so, likely a title unless it's a formatted ISBN
    const hasSpaces = /\s/.test(val);
    
    // Remove hyphens and spaces for validation
    const cleaned = val.replace(/[-\s]/g, '');
    const upper = cleaned.toUpperCase();
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(cleaned);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    // We prioritize ASIN because that's what Keepa search results return
    const is10DigitNumeric = /^\d{10}$/.test(cleaned);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(cleaned);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    const isISBN = isISBN13 || isISBN10WithX;
    
    // ASIN: 10 alphanumeric chars (including 10-digit all-numeric old ASINs)
    const isASIN = /^[A-Z0-9]{10}$/.test(upper) && !isISBN;
    
    // SAFETY: If it had spaces and isn't a valid ISBN/ASIN, treat as title
    const shouldSearchByTitle = hasSpaces && !isISBN && !isASIN;
    
    console.log('submitSearch:', { val, cleaned, upper, hasSpaces, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, isASIN, shouldSearchByTitle });
    
    if(shouldSearchByTitle) {
        console.log('Has spaces and not valid ID, searching as title:', val);
        input.value = ''; 
        await searchByTitle(val);
    } else if(isASIN || isISBN) {
        console.log('Detected as ID, adding to queue:', upper);
        closeTitlePicker(); 
        addToQueue(upper);
        input.value = '';
    } else {
        console.log('Detected as title, searching:', val);
        input.value = ''; 
        await searchByTitle(val);
    }
}

function normalizeTitleKey(s) {
    return (s || '').toLowerCase().replace(/\s+/g, ' ').trim();
}

function showTitlePickerLoading(query) {
    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Searching editions for: "${query}"`;
    list.innerHTML = `
      <div style="padding:12px; color:var(--muted); font-size:12px; display:flex; gap:10px; align-items:center;">
        <i class="fas fa-circle-notch fa-spin" style="color:var(--blue)"></i>
        <span>Looking up editions via Keepa...</span>
      </div>
    `;
    card.classList.remove('hidden');
    const keepaCard = document.getElementById('resultCard');
    if(keepaCard) keepaCard.classList.add('hidden');
}

// Function to handle the copying of the ISBN/ASIN
function copyIdAndFocus(id, title) {
    console.log('copyIdAndFocus called with:', { id, title });
    const inputField = document.getElementById('scanInput');
    
    // Copy to clipboard
    if (navigator.clipboard) {
        navigator.clipboard.writeText(id).catch(err => {
            console.error('Could not copy text: ', err);
        });
    }
    
    // Close the title picker
    closeTitlePicker();
    
    // Put the ID in the search field
    inputField.value = id;
    console.log('Input field set to:', inputField.value);
    
    // Automatically trigger the search
    console.log('Calling submitSearch...');
    submitSearch();
}


function renderTitlePicker(query, results) {
    isProcessing = false;
    const p = document.getElementById('processing');
    if (p) p.classList.add('hidden');

    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Select the right edition for: "${query}"`;
    card.classList.remove('hidden');

    const key = normalizeTitleKey(query);
    const lastKey = localStorage.getItem('lastTitlePickKey') || '';
    const lastIsbn = localStorage.getItem('lastTitlePickIsbn') || '';
    
    let sorted = [...results];
    if(lastKey && lastIsbn && lastKey === key) {
        const idx = sorted.findIndex(r => r.isbn === lastIsbn);
        if(idx > 0) {
            const [hit] = sorted.splice(idx, 1);
            sorted.unshift(hit);
        }
    }

    list.innerHTML = sorted.map((r) => {
        const thumb = r.thumbnail ? `<img src="${r.thumbnail}" alt="" style="width:44px;height:66px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,0.12);" />`
                                  : `<div style="width:44px;height:66px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.04);display:grid;place-items:center;color:rgba(255,255,255,0.25);font-size:14px;">${r.isbnType === 'BOOK' ? 'üìò' : 'üì¶'}</div>`;

        const pill = (lastKey === key && lastIsbn === r.isbn) ? `<span class="tag good" style="margin-left:8px;">Last Pick</span>` : '';
        const binding = String(r.editionLabel || 'Product').replace(/\b\w/g, c => c.toUpperCase());
        const idLabel = (r.isbnType === 'BOOK' && r.isbn.length >= 10 && r.isbn.length <= 13) ? 'ISBN' : 'ASIN/ID';
        
        const displayYear = r.published ? String(r.published).substring(0,4) : 'N/A';
        const safeTitle = escapeHtml(r.title || 'Unknown');
        const safeISBN = escapeHtml(r.isbn);


        return `
          <div style="display:flex; gap:12px; padding:12px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); border-radius:14px; margin-bottom:10px;">
            ${thumb}
            <div style="flex:1; min-width:0;">
              <div style="font-weight:800; font-size:13px; line-height:1.2; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${safeTitle}${pill}
              </div>
              <div style="font-size:11px; color:rgba(255,255,255,0.7); margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${escapeHtml(r.authors || '')} ${r.published ? ' ‚Ä¢ ' + displayYear : ''}
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                <span class="tag warn">${binding}</span>
                <span class="tag" style="background:rgba(96,165,250,0.15);color:var(--blue);border:1px solid rgba(96,165,250,0.25);">${idLabel}: ${safeISBN}</span>
              </div>
            </div>
            <button class="ext-link" style="align-self:flex-start; margin-top:5px; padding:8px 12px; font-size:11px; font-weight:700;" 
                    onclick="copyIdAndFocus('${safeISBN}', '${safeTitle}')" title="Run Analysis">
              Run Item <i class="fas fa-play"></i>
            </button>
          </div>
        `;
    }).join('');

    titleResults = sorted;
}

function closeTitlePicker() {
    const card = document.getElementById('titlePickerCard');
    if(card) card.classList.add('hidden');
    titleResults = [];
}

function fireKeepaFromTitle(encodedKey, encodedIsbn) {
    // This function is now OBSOLETE/NOT USED in v10.14, replaced by copyIdAndFocus
    // but kept as a placeholder if you wish to restore direct click search later.
    const key = decodeURIComponent(encodedKey || '');
    const isbn = decodeURIComponent(encodedIsbn || '');
    if(!isbn) return;

    localStorage.setItem('lastTitlePickKey', key);
    localStorage.setItem('lastTitlePickIsbn', isbn);

    closeTitlePicker();
    addToQueue(isbn); 
}

function escapeHtml(s) {
    return String(s ?? '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
}

async function searchByTitle(title) {
    console.log('searchByTitle called with:', title);
    
    if(!CONFIG.keepaKey) {
        alert("Keepa Error: API Key is missing. Please enter your key in Settings.");
        return;
    }

    try {
        document.getElementById('processing').classList.remove('hidden');
        showTitlePickerLoading(title);

        const url = `https://api.keepa.com/search?key=${CONFIG.keepaKey}&domain=1&type=product&term=${encodeURIComponent(title)}`;
        console.log('searchByTitle: Fetching from Keepa...', { useProxy: CONFIG.useProxy });
        
        const fetchKeepaSearch = async (u) => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 9000);
            try {
                let finalUrl = u;
                
                // Try with proxy if enabled
                if(CONFIG.useProxy) {
                    try {
                        finalUrl = `https://corsproxy.io/?${encodeURIComponent(u)}`;
                        console.log('Trying primary proxy...');
                        const res = await fetch(finalUrl, { signal: controller.signal });
                        if(res.ok) {
                            const json = await res.json();
                            if(!json.error) {
                                console.log('Primary proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                        // If proxy fails, try backup
                        console.log("Primary proxy failed for search, trying backup...");
                        finalUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`;
                        const res2 = await fetch(finalUrl, { signal: controller.signal });
                        if(res2.ok) {
                            const json = await res2.json();
                            if(!json.error) {
                                console.log('Backup proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                    } catch(proxyErr) {
                        console.log("Proxies failed, trying direct...", proxyErr);
                    }
                    // Fall through to direct if proxies fail
                    finalUrl = u;
                }
                
                // Direct fetch (or fallback from proxy failure)
                console.log('Trying direct fetch...');
                const res = await fetch(finalUrl, { signal: controller.signal });
                if(!res.ok) throw new Error(`HTTP ${res.status}`);
                const json = await res.json();
                
                if (json.error) throw new Error(json.error.message);
                console.log('Direct fetch success, got', json.products?.length, 'results');
                return json;
                
            } finally {
                clearTimeout(timeout);
            }
        };

        const data = await fetchKeepaSearch(url);
        
        if(!data.products || data.products.length === 0) {
            console.log('No products found');
            closeTitlePicker();
            document.getElementById('processing').classList.add('hidden');
            alert(`No products found for: "${title}" on Keepa.`);
            return;
        }

        console.log('Processing', data.products.length, 'products...');
        
        // --- Adapt Keepa results for Title Picker UI ---
        let results = data.products.map(p => {
            const authors = (p.manufacturer || p.brand || '').split(',').map(a => a.trim()).join(', ');
            const id = p.asin; 
            const pubDate = p.publicationDate || '';
            const thumbnail = p.images?.[0]?.url || null;

            if(!id) {
                console.warn('Product missing ASIN:', p);
            }

            return {
                title: p.title || 'Unknown',
                authors: authors,
                published: pubDate, 
                isbn: id, 
                isbnType: p.productType, 
                editionLabel: p.binding || p.productType, 
                pref: p.productType === 'BOOK' ? 5 : 1, 
                thumbnail: thumbnail
            };
        }).filter(r => r.isbn); // Filter out any without IDs
        
        const parseYear = (d) => {
            const m = String(d || '').match(/^(\d{4})/);
            return m ? parseInt(m[1], 10) : 0;
        };

        results.sort((a,b) => {
            if(b.pref !== a.pref) return b.pref - a.pref;
            return parseYear(b.published) - parseYear(a.published);
        });

        console.log('Rendering title picker with', results.length, 'results');
        renderTitlePicker(title, results);

    } catch(e) {
        console.error('searchByTitle error:', e.message, e.stack);
        closeTitlePicker();
        alert(`Keepa Search Error: ${e.message}. \n\nTip: Check your API key and try toggling the Proxy setting.`);
    } finally {
        document.getElementById('processing').classList.add('hidden');
    }
}


function toggleFocusLock() {
    focusLock = !focusLock;
    document.getElementById('btnLock').classList.toggle('active', focusLock);
    if(focusLock) input.focus();
}

function addToQueue(query) {
    console.log('addToQueue:', query, 'Queue length:', scanQueue.length, 'isProcessing:', isProcessing);
    scanQueue.push(query);
    processQueue();
}

async function processQueue() {
    console.log('processQueue called. isProcessing:', isProcessing, 'Queue length:', scanQueue.length);
    if(isProcessing || scanQueue.length === 0) {
        console.log('processQueue exiting early:', { isProcessing, queueEmpty: scanQueue.length === 0 });
        return;
    }
    
    if(tokens <= 0) {
        setTimeout(processQueue, 3000);
        return;
    }

    isProcessing = true;
    const query = scanQueue.shift();
    
    document.getElementById('processing').classList.remove('hidden');
    document.getElementById('resultCard').classList.add('hidden');
    
    const safety = setTimeout(() => {
        if(isProcessing) {
            isProcessing = false;
            document.getElementById('processing').classList.add('hidden');
            alert("Scan Timed Out (Network too slow)");
        }
    }, 15000); // Increased timeout to 15s to allow for retries

    let attempts = 0;
    const maxAttempts = 2;
    const is10DigitNumeric = /^\d{10}$/.test(query.replace(/-/g,''));
    
    while(attempts < maxAttempts) {
        try {
            if(tokens > 0 && attempts === 0) tokens--; // Only decrement on first attempt
            updateTokenUI();
            
            // On second attempt for 10-digit numeric, try as ISBN instead of ASIN
            const retryAsISBN = (attempts === 1 && is10DigitNumeric);
            const data = await fetchKeepa(query, retryAsISBN);
            
            clearTimeout(safety);
            lastData = data;
            const result = analyze(data);
            render(result, data);
            addToHistory(result, data);
            
            // FIX #2: Clear input after camera scan so it doesn't block future scans
            setTimeout(() => {
                document.getElementById('scanInput').value = '';
            }, 100);
            
            break; // Success, exit retry loop
            
        } catch(e) {
            attempts++;
            console.log(`Attempt ${attempts} failed:`, e.message);
            
            // For 10-digit numeric codes, if first attempt (as ASIN) fails with "Product Not Found", try as ISBN
            if(attempts === 1 && is10DigitNumeric && e.message.includes("Product Not Found")) {
                console.log('10-digit numeric failed as ASIN, will retry as ISBN...');
                continue; // Retry immediately
            }
            
            if(attempts >= maxAttempts) {
                clearTimeout(safety);
                // More helpful error message based on error type
                let tipMsg = "Tip: Check your Keepa API Key and try toggling the Proxy setting.";
                if(e.message.includes("CORS")) {
                    tipMsg = "Tip: Try enabling 'Use Proxy Server' in Settings.";
                } else if(e.message.includes("Invalid product code") || e.message.includes("Product Not Found")) {
                    tipMsg = "Tip: This ISBN/ASIN may not exist in Amazon's catalog.";
                } else if(e.message.includes("HTTP 429")) {
                    tipMsg = "Tip: You may have exceeded Keepa's rate limit. Wait a moment and try again.";
                }
                alert(`Error: ${e.message}\n\n${tipMsg}`);
            } else {
                // Wait briefly before retry
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }
    
    isProcessing = false;
    document.getElementById('processing').classList.add('hidden');
    
    // --- FINAL AUTOSCROLL FIX (Double-Check Scroll) ---
    // Executes scrolling twice with a tiny delay to overcome browser resistance on mobile.
    setTimeout(() => {
        window.scrollTo({ top: 0, behavior: 'smooth' }); 
        
        // Secondary check right after the first one is registered
        setTimeout(() => {
            window.scrollTo({ top: 0, behavior: 'smooth' }); 
        }, 50); // Wait 50ms for the second check
    }, 10); // Start the process immediately after hiding the spinner
    // ----------------------------------------------------
    
    if(scanQueue.length > 0) setTimeout(processQueue, 2500);
}

function clearHistory() {
    if(!confirm('Clear all scan history? This cannot be undone.')) return;
    
    scanHistory = [];
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    const list = document.getElementById('historyList');
    if(list) list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
}

function clearScan() {
    input.value = '';
    document.getElementById('resultCard').classList.add('hidden');
    isProcessing = false;
    scanQueue = [];
    document.getElementById('processing').classList.add('hidden');
    input.focus();
}

/* ================= KEEPA API ================= */
async function fetchKeepa(query, retryAsISBN = false) {
    if(!CONFIG.keepaKey) throw new Error("No API Key");
    
    const clean = query.replace(/-/g,'');
    const days = 180; 
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(clean);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    const is10DigitNumeric = /^\d{10}$/.test(clean);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(clean);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    // OR if we're retrying a 10-digit numeric as ISBN
    const isISBN = isISBN13 || isISBN10WithX || (retryAsISBN && is10DigitNumeric);
    
    // Everything else is ASIN (including 10-digit all-numeric on first try)
    const paramName = isISBN ? 'code' : 'asin';
    
    let url = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=1&${paramName}=${clean}&stats=${days}&history=1`;
    
    console.log('fetchKeepa:', { query, clean, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, paramName, retryAsISBN, url: url.replace(CONFIG.keepaKey, 'KEY_HIDDEN') });

    // PROXY FAILOVER
    if(CONFIG.useProxy) {
        try {
            const proxy1 = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), 5000);
            
            const res = await fetch(proxy1, { signal: controller.signal });
            clearTimeout(id);
            if(res.ok) {
                const json = await res.json();
                return parseKeepaJson(json, true);
            }
        } catch(e) {
            console.log("Proxy 1 failed, trying backup...");
        }
        
        try {
            const proxy2 = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const res2 = await fetch(proxy2);
            if(!res2.ok) throw new Error("Proxy 2 failed");
            const json = await res2.json();
            return parseKeepaJson(json, true);
        } catch(e2) {
            console.log("Both proxies failed, trying direct fetch...");
        }
        
        // LAST RESORT: Try direct fetch (might fail due to CORS)
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e3) {
            throw new Error("Connection Failed: All proxies down and direct fetch blocked by CORS. Try disabling 'Use Proxy Server' in Settings.");
        }
        
    } else {
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e) {
            throw new Error(`Failed to fetch from Keepa: ${e.message}`);
        }
    }
}

function parseKeepaJson(json, isID) {
    console.log('parseKeepaJson called with:', json);
    if(json.error) throw new Error(json.error.message);
    let product;
    if(!json.products || !json.products.length) {
        console.error('Keepa returned no products. Full response:', json);
        throw new Error("Product Not Found - Keepa returned no products for this ID");
    }
    product = json.products[0];
    
    return parseProduct(product);
}

/* ================= PRICE HISTORY PARSER ================= */
function calculatePriceRange(priceHistory, daysBack = 90) {
    // Keepa price history format: [timestamp1, price1, timestamp2, price2, ...]
    // Timestamps are in "Keepa time" (minutes since epoch 2011-01-01)
    // Prices are in cents, or -1 for no data
    
    if (!priceHistory || priceHistory.length < 2) {
        return { min: 0, max: 0, spread: 0, hasData: false };
    }
    
    const now = Date.now();
    const cutoffTime = now - (daysBack * 24 * 60 * 60 * 1000);
    const keepaEpoch = new Date('2011-01-01').getTime();
    
    let minPrice = Infinity;
    let maxPrice = -Infinity;
    let validPrices = 0;
    
    // Iterate through pairs: [time, price, time, price, ...]
    for (let i = 0; i < priceHistory.length; i += 2) {
        const keepaTime = priceHistory[i];
        const priceValue = priceHistory[i + 1];
        
        // Convert Keepa time to JS timestamp
        const timestamp = keepaEpoch + (keepaTime * 60 * 1000);
        
        // Only consider prices within our time window
        if (timestamp >= cutoffTime && priceValue > 0) {
            const price = priceValue / 100; // Convert cents to dollars
            minPrice = Math.min(minPrice, price);
            maxPrice = Math.max(maxPrice, price);
            validPrices++;
        }
    }
    
    if (validPrices === 0 || minPrice === Infinity) {
        return { min: 0, max: 0, spread: 0, hasData: false };
    }
    
    return {
        min: minPrice,
        max: maxPrice,
        spread: maxPrice - minPrice,
        hasData: true
    };
}

function parseProduct(p) {
    const s = p.stats.current;
    const avg = p.stats.avg90 || [];
    const toPrice = (v) => (v && v > 0) ? v / 100 : 0;
    const toVal = (v) => (v == -1 || v == null) ? 0 : v;
    
    // Check for restriction flag
    // productType: 0 = standard, 1 = restricted, 2 = meltable
    const isRestricted = p.productType === 1 || 
                       p.hazMat === 1 || 
                       (p.title && /international edition|instructor|review copy|not for resale|teacher edition/i.test(p.title));
    
    // --- START: NEW BUY BOX INFERENCE LOGIC (FIXED) ---
    let inferredBbPrice = 0;
    let bbOwnerType = 'SUPPRESSED'; // Default: No offers or BB available

    const keepaBb = toPrice(s[18]); // Explicit Keepa BB price
    const fbaPrice = toPrice(s[10]);
    const usedPrice = toPrice(s[2]); // Lowest MF Used price
    const fbaCount = toVal(s[16]) || 0;
    const amzPrice = toPrice(s[0]);

    if (keepaBb > 0) {
        // CASE 1: Explicit Buy Box (Highest confidence)
        inferredBbPrice = keepaBb;
        bbOwnerType = (amzPrice > 0 && Math.abs(amzPrice - keepaBb) < 0.05) ? 'AMZ' : 'EXPLICIT_BB';
    } else if (fbaCount > 0 && fbaPrice > 0) {
        // CASE 2: FBA Rotation (MOST BOOKS LIVE HERE)
        // If FBA offers exist, the effective BB is the lowest FBA price.
        inferredBbPrice = fbaPrice;
        bbOwnerType = 'ROTATING_FBA';
    } else if (usedPrice > 0) {
        // CASE 3: FBM/MF-driven Buy Box (Lowest offer price if no FBA)
        // We use usedPrice as proxy for lowest FBM price.
        inferredBbPrice = usedPrice;
        bbOwnerType = 'FBM_PRICE_DRIVEN';
    }
    // --- END: NEW BUY BOX INFERENCE LOGIC ---
    
    // --- START: BUY BOX PRICE RANGE ANALYSIS (90 DAYS) - CONDITION AWARE ---
    console.log('Keepa product data:', { hasCsv: !!p.csv, csvLength: p.csv?.[18]?.length || 0 });
    console.log('BB data check:', { 
        csvBB: p.csv?.[18]?.length || 0,
        csvNew: p.csv?.[1]?.length || 0,
        csvUsed: p.csv?.[2]?.length || 0,
        avgBB: avg[18], 
        currentBB: s[18],
        keepaBb: keepaBb 
    });
    
    // Parse BOTH new and used price ranges separately
    let newPriceRange = calculatePriceRange(p.csv?.[1] || [], 90); // csv[1] = New price history
    let usedPriceRange = calculatePriceRange(p.csv?.[2] || [], 90); // csv[2] = Used price history
    let bbPriceRange = calculatePriceRange(p.csv?.[18] || [], 90); // csv[18] = Generic Buy Box history
    
    console.log('Price ranges:', { newPriceRange, usedPriceRange, bbPriceRange });
    
    // FALLBACK 1: If no csv history for new, estimate from current/avg data
    if (!newPriceRange.hasData && s[1] > 0) {
        const currentNew = toPrice(s[1]);
        const avgNew = avg[1] > 0 ? toPrice(avg[1]) : currentNew;
        
        newPriceRange = {
            min: Math.min(currentNew * 0.90, avgNew * 0.85),
            max: Math.max(currentNew * 1.10, avgNew * 1.15),
            spread: 0,
            hasData: true,
            isEstimated: true
        };
        newPriceRange.spread = newPriceRange.max - newPriceRange.min;
        console.log('Using estimated NEW range:', newPriceRange);
    }
    
    // FALLBACK 2: If no csv history for used, estimate from current/avg data
    if (!usedPriceRange.hasData && s[2] > 0) {
        const currentUsed = toPrice(s[2]);
        const avgUsed = avg[2] > 0 ? toPrice(avg[2]) : currentUsed;
        
        usedPriceRange = {
            min: Math.min(currentUsed * 0.90, avgUsed * 0.85),
            max: Math.max(currentUsed * 1.10, avgUsed * 1.15),
            spread: 0,
            hasData: true,
            isEstimated: true
        };
        usedPriceRange.spread = usedPriceRange.max - usedPriceRange.min;
        console.log('Using estimated USED range:', usedPriceRange);
    }
    
    // FALLBACK 3: If still no new/used ranges, fall back to generic BB range
    if (!bbPriceRange.hasData && avg[18] > 0) {
        const avgBbPrice = toPrice(avg[18]);
        const currentBbPrice = keepaBb > 0 ? keepaBb : avgBbPrice;
        
        console.log('Fallback 1 calculation:', { avgBbPrice, currentBbPrice });
        
        // Estimate a range: +/- 15% from average, or use current if different
        const estimatedMin = Math.min(avgBbPrice * 0.85, currentBbPrice * 0.90);
        const estimatedMax = Math.max(avgBbPrice * 1.15, currentBbPrice * 1.10);
        
        bbPriceRange = {
            min: estimatedMin,
            max: estimatedMax,
            spread: estimatedMax - estimatedMin,
            hasData: true,
            isEstimated: true
        };
        
        console.log('Using estimated BB range from avg90:', bbPriceRange);
    }
    
    // FALLBACK 2: If still no data AND we have current prices, use those to estimate
    if (!bbPriceRange.hasData && (fbaPrice > 0 || usedPrice > 0)) {
        const basePrice = fbaPrice > 0 ? fbaPrice : usedPrice;
        
        console.log('Fallback 2 calculation - using current prices:', { fbaPrice, usedPrice, basePrice });
        
        // Estimate range: +/- 20% from current price
        const estimatedMin = basePrice * 0.80;
        const estimatedMax = basePrice * 1.20;
        
        bbPriceRange = {
            min: estimatedMin,
            max: estimatedMax,
            spread: estimatedMax - estimatedMin,
            hasData: true,
            isEstimated: true,
            isHighlyEstimated: true // Flag for very rough estimate
        };
        
        console.log('Using highly estimated BB range from current prices:', bbPriceRange);
    }
    
    console.log('Final bbPriceRange:', bbPriceRange);
    
    // Determine strategy type based on spread
    let strategyType = 'TIGHT_RANGE';
    let pricingNotes = '';
    
    if (!bbPriceRange.hasData) {
        strategyType = 'NO_HISTORY';
        pricingNotes = 'Insufficient price history';
    } else if (bbPriceRange.spread >= 5 && bbPriceRange.spread / bbPriceRange.min >= 0.20) {
        // Wide range: $5+ spread AND 20%+ variation
        strategyType = 'WIDE_RANGE';
        const estimatedNote = bbPriceRange.isHighlyEstimated ? ' (rough estimate from current prices)' : 
                              bbPriceRange.isEstimated ? ' (estimated from averages)' : '';
        pricingNotes = `Wide pricing range ($${bbPriceRange.min.toFixed(2)}-$${bbPriceRange.max.toFixed(2)})${estimatedNote}. Start high, lower gradually.`;
    } else if (bbOwnerType === 'FBM_PRICE_DRIVEN') {
        strategyType = 'FBM_DRIVEN';
        pricingNotes = 'FBM controls Buy Box. Must match lowest price to compete.';
    } else {
        // Tight range
        const estimatedNote = bbPriceRange.isHighlyEstimated ? ' (rough estimate from current prices)' : 
                              bbPriceRange.isEstimated ? ' (estimated from averages)' : '';
        pricingNotes = `Tight pricing ($${bbPriceRange.min.toFixed(2)}-$${bbPriceRange.max.toFixed(2)})${estimatedNote}. Match competitive FBA price.`;
    }
    
    // Calculate FBA premium if applicable
    const fbaPremium = (fbaPrice > 0 && usedPrice > 0 && fbaPrice > usedPrice) ? {
        exists: true,
        amount: fbaPrice - usedPrice,
        percentage: Math.round(((fbaPrice - usedPrice) / usedPrice) * 100)
    } : {
        exists: false,
        amount: 0,
        percentage: 0
    };
    // --- END: BUY BOX PRICE RANGE ANALYSIS ---
    
    return {
        title: p.title || "Unknown",
        asin: p.asin,
        isbn: p.eanList?.[0] || '',
        rank: toVal(s[3]),
        avgRank: toVal(avg[3]),
        drops30: p.stats.salesRankDrops30 || 0,
        drops90: p.stats.salesRankDrops90 || 0,
        drops180: p.stats.salesRankDrops180 || 0,
        drops360: p.stats.salesRankDrops360 || 0,
        newPrice: toPrice(s[1]),
        usedPrice: usedPrice, 
        fbaPrice: fbaPrice,   
        amzPrice: amzPrice,
        buyBoxPrice: keepaBb,
        // --- NEW/UPDATED FIELDS ---
        inferredBbPrice: inferredBbPrice,
        bbOwnerType: bbOwnerType,
        bbPriceRange: bbPriceRange,
        newPriceRange: newPriceRange,  // NEW: Separate price range for NEW condition
        usedPriceRange: usedPriceRange, // NEW: Separate price range for USED condition
        strategyType: strategyType,
        pricingNotes: pricingNotes,
        fbaPremium: fbaPremium,
        // -------------------------
        avgNew: toPrice(avg[1]),
        avgUsed: toPrice(avg[2]),
        avgBb: toPrice(avg[18]),
        weight: p.packageWeight ? p.packageWeight / 100 : 1,
        fbaCount: fbaCount,
        totalOffers: toVal(s[11]) || 0,
        category: p.categoryTree?.[0]?.name || 'Unknown',
        reviewCount: p.reviewCount || 0,
        rating: p.rating || 0,
        restricted: isRestricted
    };
}

/* ================= CATEGORY ICON HELPER ================= */
function getCategoryIcon(category) {
    const cat = (category || '').toLowerCase();
    
    if(cat.includes('book')) return 'üìö';
    if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) return 'üíø';
    if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray') || cat.includes('movie')) return 'üé¨';
    if(cat.includes('video game') || cat.includes('game')) return 'üéÆ';
    if(cat.includes('toy')) return 'üß∏';
    if(cat.includes('electronic')) return 'üì±';
    if(cat.includes('home') || cat.includes('kitchen')) return 'üè†';
    if(cat.includes('sport')) return '‚öΩ';
    if(cat.includes('clothing') || cat.includes('apparel')) return 'üëï';
    if(cat.includes('health') || cat.includes('beauty')) return 'üíä';
    
    return 'üì¶'; // Default for unknown categories
}

/* ================= CATEGORY-AWARE RANK THRESHOLDS ================= */
function getRankThresholds(category) {
    const cat = (category || '').toLowerCase();
    
    // Each category has different rank scales
    if(cat.includes('book')) {
        return { good: 500000, decent: 2000000, poor: 5000000 };
    } else if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) {
        return { good: 200000, decent: 800000, poor: 2000000 };
    } else if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray')) {
        return { good: 300000, decent: 1200000, poor: 3000000 };
    } else if(cat.includes('video game')) {
        return { good: 100000, decent: 500000, poor: 1500000 };
    } else if(cat.includes('toy')) {
        return { good: 300000, decent: 1500000, poor: 4000000 };
    } else {
        // Default for unknown categories
        return { good: 500000, decent: 2000000, poor: 5000000 };
    }
}

/* ================= CATEGORY-AWARE FEE CALCULATION ================= */
function calculateFees(price, weight, category) {
    const closingFee = 1.80;
    let referralFee = 0;
    let fulfillmentFee = 0;
    
    // Determine category type
    const cat = (category || '').toLowerCase();
    const isBooks = cat.includes('book');
    const isMedia = cat.includes('music') || cat.includes('video') || cat.includes('dvd') || cat.includes('cd') || cat.includes('vinyl') || cat.includes('blu-ray');
    const isGames = cat.includes('game') || cat.includes('toy');
    
    // REFERRAL FEES (Amazon's cut)
    if(isBooks) {
        referralFee = price * 0.15; // 15% for books
    } else if(isMedia) {
        referralFee = price * 0.15; // 15% for media
    } else if(isGames) {
        referralFee = price * 0.15; // 15% for toys & games
    } else {
        referralFee = price * 0.15; // Default 15%
    }
    
    // FULFILLMENT FEES (FBA shipping/handling)
    if(isBooks) {
        // Books: weight-based
        if(weight <= 0.5) fulfillmentFee = 3.07;
        else if(weight <= 1) fulfillmentFee = 3.37;
        else if(weight <= 2) fulfillmentFee = 4.16;
        else if(weight <= 3) fulfillmentFee = 5.32;
        else fulfillmentFee = 5.32 + ((weight - 3) * 0.38);
    } else if(isMedia) {
        // Media: standard + weight
        if(weight <= 0.5) fulfillmentFee = 2.92;
        else if(weight <= 1) fulfillmentFee = 3.16;
        else if(weight <= 2) fulfillmentFee = 3.74;
        else fulfillmentFee = 3.74 + ((weight - 2) * 0.38);
    } else {
        // Other: standard small/large item
        if(weight <= 1) fulfillmentFee = 3.22;
        else if(weight <= 2) fulfillmentFee = 4.40;
        else fulfillmentFee = 4.40 + ((weight - 2) * 0.38);
    }
    
    return closingFee + referralFee + fulfillmentFee;
}

/* ================= MARVEL HELPERS ================= */
function getFBAFee(weight) {
    if (!weight || weight <= 0) return 5.50;
    if (weight <= 1) return 3.66;
    if (weight <= 2) return 4.75;
    if (weight <= 3) return 5.50;
    if (weight <= 4) return 6.10;
    if (weight <= 5) return 7.15;
    if (weight <= 10) return 8.26;
    if (weight <= 20) return 15.06;
    return 18.00;
}

function getMarvelReturnRate(condition) {
    return MARVEL_CONFIG.returnRates[condition] || 15;
}

function detectMarvelUniverse(title) {
    for (const [universe, config] of Object.entries(MARVEL_CONFIG.universes)) {
        if (config.keywords.some(kw => title.toLowerCase().includes(kw.toLowerCase()))) {
            return { universe, config };
        }
    }
    return null;
}

function detectSeriesMatch(title) {
    const patterns = [
        /(.+?)\s+Vol\.?\s*(\d+)/i,
        /(.+?)\s+Volume\s+(\d+)/i,
        /(.+?)\s+Book\s+(\d+)/i,
        /(.+?)\s+#(\d+)/i
    ];
    
    for (const pattern of patterns) {
        const match = title.match(pattern);
        if (match) {
            const seriesName = match[1].trim();
            const volume = parseInt(match[2]);
            
            const adjacentVolumes = marvelInventory.filter(item => {
                const itemMatch = item.title.match(pattern);
                if (!itemMatch) return false;
                
                const itemSeries = itemMatch[1].trim();
                const itemVolume = parseInt(itemMatch[2]);
                
                return itemSeries.toLowerCase() === seriesName.toLowerCase() &&
                       (itemVolume === volume - 1 || itemVolume === volume + 1);
            });
            
            if (adjacentVolumes.length > 0) {
                return { seriesName, volume, adjacentVolumes };
            }
        }
    }
    return null;
}

function triggerMarvelAnimation() {
    const burst = document.createElement('div');
    burst.className = 'comic-burst';
    burst.innerHTML = 'POW!';
    document.body.appendChild(burst);
    
    setTimeout(() => burst.classList.add('show'), 100);
    
    if (navigator.vibrate) {
        navigator.vibrate([100, 30, 100, 30, 300]);
    }
    
    setTimeout(() => {
        burst.classList.remove('show');
        setTimeout(() => burst.remove(), 300);
    }, 2000);
}

/* ================= ANALYSIS (UPGRADED TO BUY/CONSIDER/REJECT) ================= */
function analyze(data) {
    // --- 1. MARKET PRICE SELECTION (Condition-Aware) ---
    console.log('analyze() called with condition:', CONFIG.condition);
    console.log('Available prices:', {
        newPrice: data.newPrice,
        usedPrice: data.usedPrice,
        inferredBbPrice: data.inferredBbPrice,
        avgBb: data.avgBb,
        fbaPrice: data.fbaPrice,
        amzPrice: data.amzPrice
    });
    
    let market = 0;
    let hasNewCompetition = false;
    let noNewOpportunity = false; // Flag for "no new sellers" opportunity
    
    const newBuyBox = data.newPrice || data.amzPrice || 999999;
    
    if(CONFIG.condition === 'NEW') {
        // Check if there's actual new competition
        hasNewCompetition = data.newPrice > 0;
        
        if(hasNewCompetition) {
            // Standard case: use new price
            market = data.newPrice;
            console.log('NEW condition with competition, market price:', market);
        } else {
            // OPPORTUNITY: No new sellers! Price above used BB with premium
            const usedReference = data.usedPrice || data.inferredBbPrice || data.avgBb || 0;
            if(usedReference > 0) {
                // Apply 25% premium over used price for new condition
                market = usedReference * 1.25;
                noNewOpportunity = true;
                console.log('NEW condition with NO competition! Pricing at 25% premium over used:', market);
            } else {
                // No pricing data at all - use fallback
                market = data.inferredBbPrice || data.avgBb || 0;
                console.log('NEW condition, no data, using fallback:', market);
            }
        }
    } else {
        // USED condition - standard logic
        market = data.usedPrice || data.inferredBbPrice || data.avgBb || 0;
        console.log('USED condition selected, market price:', market);
    }
    
    // Ceiling Check (used price shouldn't beat new if new exists)
    if(CONFIG.condition === 'USED' && hasNewCompetition && market > newBuyBox) {
        market = newBuyBox * 0.95;
    }
    
    // Final safety check: ensure price is at least a minimum for meaningful calculation
    market = Math.max(10.00, market);

    // --- 2. PROFIT & FEES CALCULATION ---
    const fees = calculateFees(market, data.weight, data.category);
    const profit = market - fees - CONFIG.buyCost;
    
    console.log('üí∞ PROFIT CALCULATION:', {
        market: market.toFixed(2),
        fees: fees.toFixed(2),
        buyCost: CONFIG.buyCost.toFixed(2),
        profit: profit.toFixed(2)
    });
    
    let verdict = 'CONSIDER';
    let score = 50;
    let isGem = false;
    let allTags = [];
    let estimatedDaysOptimistic = 0; // Initialize here so it's always defined
    let estimatedDaysConservative = 0; // Initialize here so it's always defined
    let queuePosition = 1; // Initialize here so it's always defined
    let queuePositionOptimistic = 1; // Initialize here so it's always defined
    let salesPerMonth = 0; // Initialize here so it's always defined
    
    const thresholds = getRankThresholds(data.category);
    
    // --- 3. BASE SCORING & GEM LOGIC (Modified) ---
    
    // GEM TRIGGERS (Keepa flags & Heuristics)
    const isSleeper = (data.drops30 === 0 && market > 35);
    const isFbaVoid = (data.fbaCount === 0 && data.avgRank < thresholds.decent && profit > 10); // Use fbaCount
    const isDip = (data.usedPrice > 0 && data.avgUsed > 0 && data.usedPrice < (data.avgUsed * 0.4) && profit > 5);
    const isTextbook = (data.newPrice > 80 && data.usedPrice < 20 && data.category && data.category.toLowerCase().includes('book'));
    const isRare = (data.avgRank !== -1 && data.avgRank < thresholds.poor && data.totalOffers < 3 && market > 20);
    const isSprinter = (data.drops30 > 3 && data.drops30 > (data.drops90/3 * 1.5)); 
    const isPhantom = (data.totalOffers > 50 && market > 15);
    const isFbaPrem = (data.fbaPrice > 0 && data.usedPrice > 0 && data.fbaPrice > (data.usedPrice * 1.4) && Math.abs(data.fbaPrice - data.inferredBbPrice) < 2); 

    // TAGS
    if(isSleeper) { allTags.push({text: "üíé Patience for Big Payout", type: "gem"}); }
    if(isFbaVoid) { allTags.push({text: "üíé Zero FBA Offers", type: "gem"}); }
    if(isDip)     { allTags.push({text: "üíé Buy The Dip", type: "gem"}); }
    if(isTextbook){ allTags.push({text: "üíé Sell Cheaper Used Textbook", type: "gem"}); }
    if(isRare)    { allTags.push({text: "üíé Low Comp Rewards", type: "gem"}); }
    if(isSprinter){ allTags.push({text: "üíé Picking Up Pace", type: "gem"}); }
    if(isPhantom) { allTags.push({text: "üíé Crowded But Fine", type: "gem"}); }
    if(isFbaPrem) { allTags.push({text: "üíé FBA Premium", type: "gem"}); }

    // --- 3B. PLAIN ENGLISH TRIGGERS (2025 AGNOSTIC BUY BOX STRATEGY) ---
    // These signals help navigate the new Featured Offer landscape where MFN can compete directly
    let signals = []; // Strategic trigger labels for UI display
    let triggerScoreAdjustment = 0; // Cumulative score impact from all triggers
    
    // TRIGGER 1: LONE WOLF - You're the only FBA option (massive advantage)
    const isLoneWolf = (data.fbaCount === 0);
    if (isLoneWolf) {
        signals.push({text: "üíé LONE WOLF", type: "signal-good", tooltip: "Zero FBA competition - Prime members will choose you"});
        triggerScoreAdjustment += 20;
    }
    
    // TRIGGER 2: MFN CROWDED - MFN sellers are 20%+ cheaper (high risk)
    const isMfnCrowded = (data.usedPrice > 0 && data.fbaPrice > 0 && data.usedPrice < (data.fbaPrice * 0.8));
    if (isMfnCrowded) {
        signals.push({text: "‚ö†Ô∏è MFN CROWDED", type: "signal-warn", tooltip: "MFN sellers are 20%+ cheaper - they may win Featured Offer"});
        triggerScoreAdjustment -= 10;
    }
    
    // TRIGGER 3: AMZ CAMPING - Amazon is on the listing (slow turns expected)
    const isAmzCamping = (data.amzPrice > 0);
    if (isAmzCamping) {
        signals.push({text: "üõë AMZ CAMPING", type: "signal-bad", tooltip: "Amazon is selling - you'll only get sales when they stock out"});
        triggerScoreAdjustment -= 15;
    }
    
    // TRIGGER 4: QUALITY LEAD - Your condition is better than Buy Box holder
    // Note: We can't easily determine BB holder's condition from Keepa, so we'll use a proxy:
    // If you're NEW and BB is held by FBM (likely used), you have quality advantage
    const isQualityLead = (CONFIG.condition === 'NEW' && data.bbOwnerType === 'FBM_PRICE_DRIVEN');
    if (isQualityLead) {
        signals.push({text: "‚ú® QUALITY LEAD", type: "signal-good", tooltip: "Your condition is superior - can price higher and still win"});
        triggerScoreAdjustment += 10;
    }
    
    // TRIGGER 5: JUNK COMP - Low-rated sellers in competition (easy to beat)
    // Note: Keepa doesn't provide seller ratings, so we use low offer count + low FBA as proxy
    // Items with very few total offers (<5) but market activity suggest poor quality competition
    const isJunkComp = (data.totalOffers > 0 && data.totalOffers < 5 && data.drops30 > 2);
    if (isJunkComp) {
        signals.push({text: "üìâ JUNK COMP", type: "signal-good", tooltip: "Low offer count with sales activity - competitors likely low-rated"});
        triggerScoreAdjustment += 5;
    }

    // --- 4. SMART SCORE CALCULATION (TIME-TO-SALE + ROI MODEL) ---
    
    // Initialize score breakdown variables (always defined)
    let velocityScore = 0;
    let bbScore = 0;
    let compScore = 0;
    let bbConfidence = 0.0;
    let estimatedDaysToSale = 0;
    let roiScore = 0;
    
    // A. PROFIT FLOOR CHECK (CRITICAL)
    if(profit < CONFIG.profitFloor) {
        verdict = 'REJECT';
        score = Math.round(Math.max(0, 40 - (CONFIG.profitFloor - profit)));
        isGem = false; // Cannot be a gem with low profit
    } else {
        // B. ESTIMATE TIME TO SALE (The Core Calculation)
        // This combines velocity (how often book sells) with competition (queue position)
        
        // Step 1: Determine sales per month based on drops data
        let salesPerMonth = 0;
        if (data.drops30 > 0) {
            // Recent velocity (most reliable)
            salesPerMonth = data.drops30;
        } else if (data.drops90 > 0) {
            // Medium-term velocity (scale to monthly)
            salesPerMonth = data.drops90 / 3;
        } else if (data.drops180 > 0) {
            // Long-term velocity (scale to monthly)
            salesPerMonth = data.drops180 / 6;
        } else {
            // No sales history - very risky
            salesPerMonth = 0.1; // Assume one sale per 10 months
        }
        
        // Step 2: Calculate queue position (BOTH optimistic and conservative for range display)
        // Optimistic = fair rotation assumption (old model)
        // Conservative = Buy Box concentration assumption (realistic for crowded markets)
        // Note: variables already declared at top of function, this is just assignment
        queuePosition = 1; // Conservative number (used for scoring)
        queuePositionOptimistic = 1; // Optimistic number (for range display)
        
        if (data.bbOwnerType === 'ROTATING_FBA' || data.bbOwnerType === 'EXPLICIT_BB') {
            let effectiveCompetitors = Math.max(1, data.fbaCount);
            
            // ALWAYS calculate optimistic (old fair rotation model)
            queuePositionOptimistic = effectiveCompetitors / 2;
            
            // CONSERVATIVE varies by competition level
            if (effectiveCompetitors <= 2) {
                // LOW COMPETITION: both numbers are the same
                queuePosition = effectiveCompetitors / 2;
            } else if (effectiveCompetitors <= 7) {
                // MEDIUM COMPETITION: 0.6x multiplier
                queuePosition = effectiveCompetitors * 0.6;
            } else {
                // HIGH COMPETITION: 0.8x multiplier
                queuePosition = effectiveCompetitors * 0.8;
            }
        } else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') {
            queuePositionOptimistic = Math.max(2, data.fbaCount);
            queuePosition = Math.max(3, data.fbaCount + 2);
        } else {
            // Suppressed BB
            queuePositionOptimistic = 8;
            queuePosition = 12;
        }
        
        // Step 3: Calculate expected days to sale (BOTH optimistic and conservative)
        let monthsToSaleConservative = queuePosition / Math.max(0.1, salesPerMonth);
        let monthsToSaleOptimistic = queuePositionOptimistic / Math.max(0.1, salesPerMonth);
        
        estimatedDaysToSale = Math.round(monthsToSaleConservative * 30); // Use conservative for scoring
        estimatedDaysOptimistic = Math.round(monthsToSaleOptimistic * 30); // Assignment, not declaration
        estimatedDaysConservative = Math.round(monthsToSaleConservative * 30); // Assignment, not declaration
        
        // Step 4: Calculate ROI-based score (Profit vs Wait Time)
        // This is the key insight: same profit is worth MORE if you don't wait as long
        
        // Velocity Score: How fast will you sell? (0-25 points)
        if (estimatedDaysToSale <= 14) {
            velocityScore = 25; // Sell within 2 weeks = excellent
        } else if (estimatedDaysToSale <= 30) {
            velocityScore = 20; // Sell within 1 month = very good
        } else if (estimatedDaysToSale <= 60) {
            velocityScore = 15; // Sell within 2 months = good
        } else if (estimatedDaysToSale <= 90) {
            velocityScore = 10; // Sell within 3 months = moderate
        } else if (estimatedDaysToSale <= 180) {
            velocityScore = 5;  // Sell within 6 months = patient inventory
        } else {
            velocityScore = 0;  // Over 6 months = very slow
        }
        
        // C. BUY BOX ACCESSIBILITY SCORE (Can you even compete?)
        if (data.bbOwnerType === 'EXPLICIT_BB') { bbScore = 18; bbConfidence = 1.0; }
        else if (data.bbOwnerType === 'ROTATING_FBA') { bbScore = 15; bbConfidence = 0.85; }
        else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') { bbScore = 5; bbConfidence = 0.6; }
        else { bbScore = -15; bbConfidence = 0.0; } // Truly suppressed

        // D. COMPETITION BONUS (Fewer competitors = higher share of sales)
        if(data.fbaCount === 0) compScore = 12; // No competition!
        else if(data.fbaCount <= 2) compScore = 8;  // Very low competition
        else if(data.fbaCount <= 5) compScore = 4;  // Low competition
        else if(data.fbaCount <= 10) compScore = 0; // Moderate competition
        else compScore = -5; // High competition

        // E. PROFIT MULTIPLIER (Higher profit compensates for longer wait)
        // This is where we apply your insight: profit matters MORE for slow movers
        let profitMultiplier = 1.0;
        
        if (estimatedDaysToSale > 90) {
            // For slow movers (90+ days), profit needs to be higher to justify the wait
            if (profit >= 15) profitMultiplier = 1.4;      // $15+ justifies 6-month wait
            else if (profit >= 12) profitMultiplier = 1.2; // $12+ justifies 4-month wait
            else if (profit >= 10) profitMultiplier = 1.0; // $10 is breakeven
            else if (profit >= 8) profitMultiplier = 0.8;  // $8 is marginal
            else profitMultiplier = 0.6;                    // Under $8 is weak
        } else if (estimatedDaysToSale > 30) {
            // For medium movers (30-90 days), profit matters but less critically
            if (profit >= 12) profitMultiplier = 1.3;
            else if (profit >= 8) profitMultiplier = 1.1;
            else if (profit >= 6) profitMultiplier = 0.9;
            else profitMultiplier = 0.7;
        } else {
            // For fast movers (under 30 days), even modest profit is fine
            if (profit >= 10) profitMultiplier = 1.2;
            else if (profit >= 6) profitMultiplier = 1.0;
            else profitMultiplier = 0.8;
        }
        
        // Apply profit multiplier to velocity score
        velocityScore = Math.round(velocityScore * profitMultiplier);
        
        // F. CALCULATE FINAL SCORE
        score = 50 + velocityScore + bbScore + compScore;
        
        console.log('üìä SMART SCORE BREAKDOWN:', {
            estimatedDaysToSale: estimatedDaysToSale,
            salesPerMonth: salesPerMonth.toFixed(1),
            queuePosition: queuePosition.toFixed(1),
            profit: profit.toFixed(2),
            profitMultiplier: profitMultiplier.toFixed(2),
            velocityScore: velocityScore,
            bbScore: bbScore,
            compScore: compScore,
            baseScore: score
        });
        
        // G. APPLY RESTRICTION PENALTY
        if(data.restricted) { 
            score = score - 8;
        }
        
        // G2. APPLY PLAIN ENGLISH TRIGGER ADJUSTMENTS (2025 Strategy)
        score = score + triggerScoreAdjustment;
        
        console.log('üéØ TRIGGER ADJUSTMENTS:', {
            signals: signals.map(s => s.text),
            triggerScoreAdjustment: triggerScoreAdjustment,
            scoreAfterTriggers: score
        });
        
        // H. CLAMP SCORE TO 0-100 RANGE
        score = Math.round(Math.max(0, Math.min(100, score)));

        // H. FINAL VERDICT ASSIGNMENT (Based on adjusted score)
        if (score >= 75) {
            verdict = 'BUY';
            // Gems are BUY-tier items (75+) with hidden opportunity characteristics
            if (allTags.filter(t => t.type === 'gem').length > 0) {
                isGem = true;
            }
        } else if (score >= 50) {
            verdict = 'CONSIDER';
        } else {
            verdict = 'REJECT';
        }
    }
    
    // --- 5. TAG GENERATION (Cleaned up) ---
    
    // BB AWARE TAGS
    if (data.bbOwnerType === 'SUPPRESSED') {
        allTags.push({text: "BB Suppressed/Unavailable", type: "bad"});
    } else if (data.bbOwnerType === 'ROTATING_FBA') {
        allTags.push({text: "BB Rotating - FBA is key", type: "good"});
    } else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') {
        allTags.push({text: "FBM Buy Box - Highly Price Sensitive", type: "warn"});
    }
    
    if (data.amzPrice > 0 && Math.abs(data.amzPrice - data.inferredBbPrice) < 0.05) {
        allTags.push({text: "BB Held by Amazon", type: "bad"});
    }

    // RESTRICTION TAG (penalty already applied to score above)
    if(data.restricted) { 
        allTags.push({text: "‚ö†Ô∏è Restricted Item - Check Seller Central", type: "warn"});
    }

    // Sales/Rank/Profit Tags
    if(data.drops30 > 5) allTags.push({text: "Good Velocity", type: "good"});
    if(data.avgRank !== -1 && data.avgRank < 500000) allTags.push({text: "Solid Rank", type: "good"});
    if(data.avgRank > 2000000) allTags.push({text: "High Rank", type: "bad"});

    if(profit >= CONFIG.profitFloor) allTags.push({text: "Profitable", type: "good"});
    if(profit < 0) allTags.push({text: "Negative Profit", type: "bad"});
    else if(profit < CONFIG.profitFloor) allTags.push({text: "Thin Margins", type: "warn"});
    
    if(data.drops30 === 0 && data.drops180 === 0) allTags.push({text: "0 Sales (180d)", type: "bad"});
    if(market < 10) allTags.push({text: "Low Value Item", type: "warn"});
    
    const posTags = allTags.filter(t => t.type === 'good' || t.type === 'gem');
    const negTags = allTags.filter(t => t.type === 'bad' || t.type === 'warn');
    
    if(posTags.length === 0) posTags.push({text: "None", type: "warn"});
    if(negTags.length === 0) negTags.push({text: "None", type: "good"});

    // --- MARVEL ENHANCEMENTS ---
    const isMarvel = data.title && data.title.toLowerCase().includes('marvel');
    let marvelData = {
        isMarvel: false,
        returnAdjustedProfit: profit,
        returnRate: 0,
        fbaFee: 0,
        referralFee: 0,
        universeMatch: null,
        seriesMatch: null
    };
    
    if (isMarvel) {
        marvelData.isMarvel = true;
        marvelData.fbaFee = getFBAFee(data.weight);
        marvelData.referralFee = market * 0.15;
        
        if (CONFIG.condition !== 'NEW') {
            marvelData.returnRate = getMarvelReturnRate(CONFIG.condition);
            const returnCost = marvelData.referralFee + marvelData.fbaFee;
            const expectedReturnLoss = returnCost * (marvelData.returnRate / 100);
            marvelData.returnAdjustedProfit = profit - expectedReturnLoss;
        }
        
        if (data.fbaCount === 0) score += 15;
        if (data.drops30 >= 10) score += 10;
        
        if (data.weight > 4) {
            if (profit < 12) {
                score -= 20;
            } else {
                score += 5;
            }
        }
        
        if (CONFIG.condition !== 'NEW' && marvelData.returnRate > 20) {
            score -= (marvelData.returnRate / 5);
        }
        
        marvelData.universeMatch = detectMarvelUniverse(data.title);
        if (marvelData.universeMatch) {
            score += marvelData.universeMatch.config.scoreBonus;
        }
        
        marvelData.seriesMatch = detectSeriesMatch(data.title);
        if (marvelData.seriesMatch) {
            score += 15;
        }
        
        score = Math.min(100, Math.max(0, score));
        
        if (score >= 75) {
            verdict = 'BUY';
            if (allTags.filter(t => t.type === 'gem').length > 0) {
                isGem = true;
            }
        } else if (score >= 50) {
            verdict = 'CONSIDER';
        } else {
            verdict = 'REJECT';
        }
    }

    console.log('üéØ FINAL ANALYSIS RESULT:', {
        condition: CONFIG.condition,
        market: market.toFixed(2),
        profit: profit.toFixed(2),
        score: Math.round(score),
        verdict: verdict
    });

    return { 
        verdict, 
        profit, 
        score: Math.round(score), 
        market,
        noNewOpportunity, // Flag when NEW condition but no new sellers
        estimatedDaysToSale, // Conservative estimate (used for scoring)
        estimatedDaysOptimistic, // Optimistic estimate (for range display)
        estimatedDaysConservative, // Conservative estimate (for range display)
        posTags, 
        negTags, 
        isGem,
        signals, // Plain English Triggers for 2025 strategy
        marvelData, // Marvel enhancements
        // FIXED: Expose all breakdown metrics for the explanation panel
        breakdown: { 
            velocityScore, 
            bbScore, 
            compScore,
            salesPerMonth: salesPerMonth,
            queuePosition: queuePosition,
            queuePositionOptimistic: queuePositionOptimistic,
            triggerScoreAdjustment: triggerScoreAdjustment, // Show trigger impact
            // Calculate penalty amount for the breakdown UI
            profitPenalty: profit < CONFIG.profitFloor ? (CONFIG.profitFloor - profit) : 0 
        }
    };
}

/* ================= RENDER (SAFE MODE) ================= */
function render(res, data) {
    // FAIL-SAFE HELPER
    const setText = (id, val) => {
        const el = document.getElementById(id);
        if(el) el.innerText = val;
    };

    const card = document.getElementById('resultCard');
    const banner = document.getElementById('banner');
    const decisionEl = document.getElementById('decision');
    
    // Update banner and verdict
    banner.className = `banner ${res.isGem ? 'gem' : res.verdict.toLowerCase()}`;
    setText('confidence', res.score);
    setText('decision', res.verdict);
    if(decisionEl) {
        decisionEl.className = `decision-label ${res.verdict.toLowerCase()}`;
    }
    
    // Show/hide gem icon
    document.getElementById('gemIcon').classList.toggle('visible', res.isGem);
    
    // Show/hide Keepa restricted badge
    const restrictedBadge = document.getElementById('keepaRestricted');
    if(restrictedBadge) {
        restrictedBadge.classList.toggle('hidden', !data.restricted);
    }
    
    // Update score ring
    const offset = 440 - (440 * res.score / 100);
    const ring = document.getElementById('scoreRing');
    if(ring) {
        ring.style.strokeDashoffset = offset;
        if(res.isGem) ring.style.color = 'var(--diamond)';
        else if(res.verdict === 'BUY') ring.style.color = 'var(--green)';
        else if(res.verdict === 'CONSIDER') ring.style.color = 'var(--yellow)';
        else ring.style.color = 'var(--red)';
    }

    // Update book title
    setText('itemTitle', data.title);
    
    // Update category badge
    const categoryBadge = document.getElementById('categoryBadge');
    if(categoryBadge) {
        const cat = data.category || 'Unknown';
        const icon = getCategoryIcon(cat);
        categoryBadge.textContent = `${icon} ${cat}`;
    }
    
    // Update price and profit boxes WITH FLASH ANIMATION
    const priceBox = document.querySelector('.info-box.price-box');
    const profitBox = document.querySelector('.info-box.profit-box');
    
    // Flash animation on change
    if (priceBox) {
        priceBox.style.animation = 'none';
        setTimeout(() => { priceBox.style.animation = 'flashBlue 0.5s ease-out'; }, 10);
    }
    if (profitBox) {
        profitBox.style.animation = 'none';
        setTimeout(() => { profitBox.style.animation = 'flashGreen 0.5s ease-out'; }, 10);
    }
    
    setText('recommendedPrice', '$' + res.market.toFixed(2));

    const profitValue = document.getElementById('profitValue');
    if(profitValue) {
        profitValue.textContent = '$' + res.profit.toFixed(2);
        profitValue.style.color = res.profit >= 0 ? 'var(--green)' : 'var(--red)';
    }
    
    // Update time badge based on estimated days to sale
    const timeBadge = document.getElementById('timeBadge');
    if(timeBadge && res.estimatedDaysToSale !== undefined) {
        let badgeText = `~${Math.round(res.estimatedDaysToSale)} Days`;
        timeBadge.textContent = badgeText;
        timeBadge.className = 'time-badge';
        timeBadge.classList.remove('hidden');
    }
    
    // Render Plain English Signals (2025 Strategy)
    const signalsContainer = document.getElementById('signalsContainer');
    const signalsBadges = document.getElementById('signalsBadges');
    if (signalsContainer && signalsBadges && res.signals && res.signals.length > 0) {
        signalsContainer.classList.remove('hidden');
        signalsBadges.innerHTML = '';
        
        res.signals.forEach(signal => {
            const badge = document.createElement('div');
            badge.className = `signal-badge ${signal.type}`;
            badge.textContent = signal.text;
            badge.title = signal.tooltip || signal.text;
            signalsBadges.appendChild(badge);
        });
    } else if (signalsContainer) {
        signalsContainer.classList.add('hidden');
    }

    // --- MARVEL BADGE RENDERING ---
    if (res.marvelData && res.marvelData.isMarvel) {
        const marvelBadges = [];
        
        if (res.score >= 90) marvelBadges.push('<div class="badge-marvel knockout">TOTAL KNOCKOUT</div>');
        if (data.fbaCount === 0) marvelBadges.push('<div class="badge-marvel solo">SOLO MISSION</div>');
        if (CONFIG.condition === 'NEW') marvelBadges.push('<div class="badge-marvel mint">MINT</div>');
        if (data.drops30 >= 10) marvelBadges.push('<div class="badge-marvel fast-turn">SALES BEAST</div>');
        
        if (data.weight > 4) {
            if (res.profit >= 12) {
                marvelBadges.push('<div class="badge-marvel big-margin">‚úì HEAVY BUT PROFITABLE</div>');
            } else {
                marvelBadges.push('<div class="badge-marvel reject-marvel">‚ö†Ô∏è WEIGHT KILLS MARGIN</div>');
            }
        }
        
        if (CONFIG.condition !== 'NEW' && res.marvelData.returnRate >= 25) {
            marvelBadges.push(`<div class="badge-marvel collector-warn">‚ö†Ô∏è ${res.marvelData.returnRate}% RETURN RISK</div>`);
        }
        
        if (res.marvelData.universeMatch) {
            marvelBadges.push(`<div class="badge-marvel ${res.marvelData.universeMatch.config.color}">${res.marvelData.universeMatch.config.badge}</div>`);
        }
        
        if (res.marvelData.seriesMatch) {
            marvelBadges.push(`<div class="badge-marvel knockout">üìö BUNDLE: ${res.marvelData.seriesMatch.adjacentVolumes.length} VOL IN STOCK</div>`);
        }
        
        if (data.drops30 === 0 && res.market > 30) {
            marvelBadges.push('<div class="badge-marvel collector-warn">‚ö†Ô∏è COLLECTOR RISK</div>');
        }
        
        if (res.profit >= 40) marvelBadges.push('<div class="badge-marvel big-margin">HIGH PROFIT</div>');
        
        if (marvelBadges.length > 0 && signalsContainer && signalsBadges) {
            signalsContainer.classList.remove('hidden');
            signalsBadges.innerHTML += marvelBadges.join('');
        }
        
        // Marvel Math Breakdown
        if (res.score >= 60) {
            let mathHTML = `<div class="marvel-math">
                <div><span>List Price</span><span>$${res.market.toFixed(2)}</span></div>
                <div><span>- Amazon (15%)</span><span>-$${res.marvelData.referralFee.toFixed(2)}</span></div>
                <div><span>- FBA Fee (${data.weight.toFixed(1)}lb)</span><span>-$${res.marvelData.fbaFee.toFixed(2)}</span></div>
                <div><span>- Closing Fee</span><span>-$1.80</span></div>
                <div><span>- Buy Cost</span><span>-$${CONFIG.buyCost.toFixed(2)}</span></div>`;
            
            if (res.marvelData.returnRate > 0) {
                const returnCost = res.profit - res.marvelData.returnAdjustedProfit;
                mathHTML += `<div><span>- Return Risk (${res.marvelData.returnRate}%)</span><span>-$${returnCost.toFixed(2)}</span></div>`;
            }
            
            mathHTML += `<div><span>= Net Profit</span><span>$${(res.marvelData.returnRate > 0 ? res.marvelData.returnAdjustedProfit : res.profit).toFixed(2)}</span></div>`;
            
            if (res.marvelData.seriesMatch) {
                const bundleBonus = res.profit * 0.30;
                mathHTML += `<div class="bundle-bonus"><span>+ Bundle Bonus (30%)</span><span>+$${bundleBonus.toFixed(2)}</span></div>`;
            }
            
            mathHTML += `</div>`;
            
            // Insert after signals container
            if (signalsContainer.nextSibling) {
                signalsContainer.parentNode.insertBefore(
                    document.createRange().createContextualFragment(mathHTML),
                    signalsContainer.nextSibling
                );
            } else {
                signalsContainer.parentNode.appendChild(
                    document.createRange().createContextualFragment(mathHTML)
                );
            }
        }
        
        // Trigger superhero animation for 90+ scores
        if (res.score >= 90) {
            triggerMarvelAnimation();
        }
        
        // Update profit display with return-adjusted value
        const profitValue = document.getElementById('profitValue');
        if (profitValue && CONFIG.condition !== 'NEW' && res.marvelData.returnRate > 0) {
            profitValue.textContent = '$' + res.marvelData.returnAdjustedProfit.toFixed(2);
        }
    }

    // Update slider displays
    updateSliderDisplays();
    
    // Initialize collapsible sections (closed by default)
    const whyScoreSection = document.getElementById('whyScoreSection');
    const pricingStrategySection = document.getElementById('pricingStrategySection');
    if (whyScoreSection && !whyScoreSection.classList.contains('open')) {
        whyScoreSection.classList.remove('open');
    }
    if (pricingStrategySection) {
        pricingStrategySection.classList.add('open'); // Open by default
    }

    // --- Buy Box Status and Price Update (FIXED) ---
    const isUsedCondition = CONFIG.condition === 'USED';
    const bbPrice = data.inferredBbPrice;
    const bbOwner = data.bbOwnerType;
    const bbPriceValEl = document.getElementById('bbPriceVal');
    const bbCondEl = document.getElementById('bbCond');
    const bbStatusText = document.getElementById('bbStatusText');
    let bbOwnerText = "";
    let bbColor = "var(--red)";

    // Inject historical context warning if live BB is very low
    let historicalContext = '';
    const recommended = res.market;
    
    // NEW CLARIFICATION LOGIC
    // Check if the recommended price is significantly higher than the live BB/inferred price.
    // Use a $5 margin and a 50% ratio as threshold for a strong warning.
    if (bbPrice > 0 && recommended > (bbPrice + 5.00) && recommended > (bbPrice * 1.5)) {
        historicalContext = `
            <span style="color:var(--yellow); font-weight:800; display:block; margin-top: 5px;">
                ‚ö†Ô∏è Market Anomaly Detected:
            </span>
            <span style="font-size:11px; line-height:1.4; color:rgba(255,255,255,0.8);">
                The current \$${bbPrice.toFixed(2)} price is being ignored for profitability because it's severely underpriced. The Recommended Sell Price (\$${recommended.toFixed(2)}) is based on higher historical Buy Box averages for the ${CONFIG.condition.toLowerCase()} condition.
            </span>
        `;
    } else if (bbPrice > 0 && recommended > (bbPrice + 1.00)) {
        // Keep the mild warning if the price is just slightly higher
        historicalContext = `<span style="color:var(--yellow); font-weight:800; display:block; margin-top: 5px;">‚ö†Ô∏è Recommended price (\$${recommended.toFixed(2)}) is based on higher historical sales data.</span>`;
    }

    if (bbPrice > 0) {
        bbCondEl.innerText = CONFIG.condition === 'USED' ? 'USED' : 'NEW';
        
        if (bbOwner === 'ROTATING_FBA' || bbOwner === 'EXPLICIT_BB') {
            bbColor = 'var(--green)';
            if (bbOwner === 'ROTATING_FBA') {
                // FIXED TEXT: Informative, not mandatory
                bbOwnerText = `<span style="color:var(--green); font-weight:800;">FBA Rotation Buy Box.</span> This price reflects the current lowest FBA offer.`;
            } else if (data.amzPrice > 0 && Math.abs(data.amzPrice - bbPrice) < 0.05) {
                bbColor = 'var(--blue)';
                bbOwnerText = `<span style="color:var(--blue); font-weight:800;">Amazon</span> holds the Buy Box.`;
            } else {
                bbOwnerText = `<span style="color:var(--green); font-weight:800;">Explicit Buy Box.</span> A single FBA/MF seller currently wins.`;
            }
        } else if (bbOwner === 'FBM_PRICE_DRIVEN') {
            bbColor = 'var(--yellow)';
            // FIXED TEXT: Informative, not mandatory
            bbOwnerText = `<span style="color:var(--yellow); font-weight:800;">FBM/MF Buy Box.</span> Competition is price-sensitive and driven by the lowest merchant-fulfilled offer.`;
        }

        // Update BB status text
        bbStatusText.innerHTML = `${bbOwnerText} The current price is $${bbPrice.toFixed(2)}.${historicalContext}`;
    } else {
        // CASE: Truly Suppressed / No Offers
        bbCondEl.innerText = CONFIG.condition === 'USED' ? 'USED' : 'NEW';
        bbStatusText.innerHTML = `<span style="color:var(--red); font-weight:800;">Buy Box is truly suppressed or no offers exist.</span> Pricing is based on historical averages.${historicalContext}`;
    }

    if (bbPriceValEl) {
      bbPriceValEl.innerText = bbPrice > 0 ? `$${bbPrice.toFixed(2)}` : 'N/A';
      bbPriceValEl.style.color = bbColor;
    }
    // --- End Buy Box Status Update ---
    
    // --- Generate Buy Box Narrative ---
    const bbNarrativeEl = document.getElementById('bbNarrativeText');
    if (bbNarrativeEl) {
        let narrative = '';
        
        // Determine Buy Box ownership pattern
        const fbaCount = data.fbaCount || 0;
        const totalOffers = data.totalOffers || 0;
        const amzActive = data.amzPrice > 0;
        const currentBbPrice = bbPrice > 0 ? bbPrice : res.market;
        
        // Build narrative based on Buy Box dynamics
        if (bbOwner === 'ROTATING_FBA' && fbaCount > 1) {
            narrative = `The Buy Box rotates cleanly among ${fbaCount} FBA sellers at $${currentBbPrice.toFixed(2)}. `;
            
            if (!amzActive) {
                narrative += `Amazon hasn't touched this listing in ${data.lastAmzDays || 90}+ days. `;
            } else {
                narrative += `Amazon occasionally appears (last seen at $${data.amzPrice.toFixed(2)}), but isn't dominating. `;
            }
            
            // Add price stability context
            if (data.avgUsed && Math.abs(currentBbPrice - data.avgUsed) < 2) {
                narrative += `The price has held steady at $${(data.avgUsed - 1).toFixed(0)}-${(data.avgUsed + 1).toFixed(0)} for the past month with only brief dips when new sellers undercut. `;
            } else if (currentBbPrice < data.avgUsed * 0.85) {
                narrative += `Price has dropped ${Math.round((1 - currentBbPrice/data.avgUsed) * 100)}% recently - likely temporary dump from a weak seller. `;
            }
            
            narrative += `Your recommended price puts you in the rotation immediately. Expect to win the BB ${Math.round(100 / fbaCount)}-${Math.round(100 / (fbaCount + 1))}% of the time.`;
            
        } else if (bbOwner === 'FBM_PRICE_DRIVEN' || (fbaCount === 0 && totalOffers > 0)) {
            narrative = `The Buy Box is currently controlled by MFN sellers at $${currentBbPrice.toFixed(2)}`;
            
            if (data.avgUsed && currentBbPrice < data.avgUsed * 0.9) {
                narrative += `, but it was FBA-dominated at $${(data.avgUsed - 2).toFixed(0)}-${(data.avgUsed + 2).toFixed(0)} just recently. `;
            } else {
                narrative += `. `;
            }
            
            if (amzActive) {
                narrative += `Amazon pops in occasionally (last seen ${data.lastAmzDays || 12} days ago at $${data.amzPrice.toFixed(2)}). `;
            }
            
            if (fbaCount === 0) {
                narrative += `No FBA sellers are active. List at $${res.market.toFixed(2)} and you'll capture the Prime premium - historically this book sells for $2-3 above MFN when FBA is available. You'll own 100% of Prime customer sales.`;
            } else {
                narrative += `This is a temporary race to the bottom - wait 2-3 weeks for weak sellers to exit before listing.`;
            }
            
        } else if (amzActive && Math.abs(data.amzPrice - currentBbPrice) < 0.50) {
            narrative = `Amazon currently holds the Buy Box at $${data.amzPrice.toFixed(2)}. `;
            
            if (data.lastAmzDays && data.lastAmzDays < 7) {
                narrative += `They've been consistently active (seen ${data.lastAmzDays} days ago). `;
            }
            
            if (res.verdict === 'BUY') {
                narrative += `Despite Amazon's presence, the profit margin ($${res.profit.toFixed(2)}) and velocity justify buying. You'll capture sales when Amazon goes out of stock or raises prices.`;
            } else {
                narrative += `Their presence is suppressing third-party sales. Consider passing unless you can wait for them to exit.`;
            }
            
        } else if (bbPrice > 0) {
            narrative = `The Buy Box is held by a single seller at $${currentBbPrice.toFixed(2)}. `;
            
            if (totalOffers < 5) {
                narrative += `Low competition (${totalOffers} total sellers) means you can likely match or undercut to win. `;
            }
            
            if (data.drops30 > 10) {
                narrative += `Strong velocity (${data.drops30} sales/month) means sales will come quickly once you win the BB.`;
            } else if (data.drops30 > 0) {
                narrative += `Moderate velocity (${data.drops30} sales/month) means patient sellers will eventually convert.`;
            }
            
        } else {
            narrative = `No active Buy Box or offers detected. `;
            
            if (res.verdict === 'BUY') {
                narrative += `This creates an opportunity - historical data shows this book sold for $${res.market.toFixed(2)} at ${CONFIG.condition.toLowerCase()} condition. List at that price and you'll have zero FBA competition.`;
            } else {
                narrative += `Pricing is based on historical averages, which may not reflect current demand. Proceed with caution.`;
            }
        }
        
        bbNarrativeEl.innerHTML = narrative;
    }
    // --- End Buy Box Narrative ---


    // Render the new score explanation panel
    renderScoreExplanation(res, data);


    // Build "Why This Score?" reasoning section
    const reasoningContent = document.getElementById('reasoningContent');
    if(reasoningContent) {
        const signals = [];
        
        // Signal descriptions mapping
        const getSignalInfo = (tagText, isPositive) => {
            const tag = tagText.toLowerCase();
            
            // Positive signals
            if(tag.includes('velocity')) return {
                icon: 'üöÄ',
                desc: `${data.drops30} sales in 30 days shows strong demand. Items moving this fast typically sell within weeks.`
            };
            if(tag.includes('patience for big payout')) return {
                icon: 'üíé',
                desc: `No recent sales but worth $${res.market.toFixed(2)}. Patient sellers can capitalize when demand returns.`
            };
            if(tag.includes('zero fba')) return {
                icon: 'üíé',
                desc: `No FBA competition despite ${data.avgRank < 1000000 ? 'good' : 'decent'} rank. You could dominate Buy Box.`
            };
            if(tag.includes('buy the dip')) return {
                icon: 'üíé',
                desc: `Current price ($${data.usedPrice.toFixed(2)}) is ${Math.round((1 - data.usedPrice/data.avgUsed) * 100)}% below 90-day average. Undervalued opportunity.`
            };
            if(tag.includes('sell cheaper used textbook')) return {
                icon: 'üíé',
                desc: `Expensive new ($${data.newPrice.toFixed(2)}) vs cheap used ($${data.usedPrice.toFixed(2)}). Classic textbook arbitrage play.`
            };
            if(tag.includes('low comp')) return {
                icon: 'üíé',
                desc: `Only ${data.totalOffers} total sellers with decent rank. Less competition = easier sales.`
            };
            if(tag.includes('picking up pace')) return {
                icon: 'üíé',
                desc: `Recent velocity accelerating. ${data.drops30} sales in 30d vs ${Math.round(data.drops90/3)} expected shows momentum.`
            };
            if(tag.includes('crowded but fine')) return {
                icon: 'üíé',
                desc: `${data.totalOffers} sellers seems high, but worth $${res.market.toFixed(2)} with profit above floor. Volume market.`
            };
            if(tag.includes('fba premium')) return {
                icon: 'üíé',
                desc: `FBA price ($${data.fbaPrice.toFixed(2)}) is ${Math.round((data.fbaPrice/data.usedPrice - 1) * 100)}% above MF. Prime customers pay more.`
            };
            if(tag.includes('solid rank')) return {
                icon: 'üìä',
                desc: `Avg rank ${data.avgRank < 100000 ? 'under 100k' : 'under 500k'} indicates consistent demand in this category.`
            };
            if(tag.includes('180d sales')) return {
                icon: 'üìÖ',
                desc: `${data.drops180} sales over 180 days. Slower mover but still active. Expect 2-6 month sell-through.`
            };
            if(tag.includes('recent lull')) return {
                icon: '‚ö†Ô∏è',
                desc: `Historical sales (${data.drops180} in 180d) but none recently. Market cooling or seasonal dip.`
            };
            if(tag.includes('profitable')) return {
                icon: 'üí∞',
                desc: `Net profit of $${res.profit.toFixed(2)} after fees ($${(res.market * 0.15 + (data.weight > 1 ? 5.30 : 4.30)).toFixed(2)}) and your cost ($${CONFIG.buyCost.toFixed(2)}).`
            };
            
            // Negative signals
            if(tag.includes('negative profit')) return {
                icon: '‚ùå',
                desc: `You'd lose $${Math.abs(res.profit).toFixed(2)} per unit after Amazon fees and your cost. Not viable.`
            };
            if(tag.includes('thin margins')) return {
                icon: '‚ö†Ô∏è',
                desc: `Profit ($${res.profit.toFixed(2)}) below your floor ($${CONFIG.profitFloor.toFixed(2)}). Risk not worth reward.`
            };
            if(tag.includes('0 sales')) return {
                icon: 'üìâ',
                desc: `Zero sales in 180 days. Dead inventory risk is very high. Could sit for months or years.`
            };
            if(tag.includes('high rank')) return {
                icon: 'üìà',
                desc: `Rank over 2M indicates very slow sales. Expect 6+ months to sell, or it may never sell.`
            };
            if(tag.includes('low value')) return {
                icon: 'üíµ',
                desc: `Selling for under $10 means tiny profits after fees. Not worth storage space or shipping hassle.`
            };
            if(tag.includes('slow & cheap')) return {
                icon: '‚ö†Ô∏è',
                desc: `Under $20 AND slow sales (180d only). Low profit potential with high risk of long storage.`
            };
            if(tag.includes('bb suppressed')) return {
                icon: 'üõë',
                desc: `The Buy Box is suppressed. Listing price is critical. Use the Recommended Price, which accounts for past BB averages.`
            };
            if(tag.includes('bb held by amazon')) return {
                icon: 'üëë',
                desc: `Amazon currently holds the Buy Box. They often price match the lowest FBA price, limiting your short-term profit unless they run out of stock.`
            };
            if(tag.includes('restricted item')) return {
                icon: 'üö®',
                desc: `This product is potentially gated or Hazmat. **DO NOT BUY** without confirming selling eligibility in your Seller Central account first.`
            };
            
            // Default
            return {
                icon: isPositive ? '‚ú®' : '‚ö†Ô∏è',
                desc: ''
            };
        };
        
        // Map positive tags
        res.posTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, true);
            signals.push({
                icon: info.icon,
                title: tag.text.replace('üíé ', ''),
                text: info.desc,
                type: 'positive'
            });
        });
        
        // Map negative tags
        res.negTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, false);
            signals.push({
                icon: info.icon,
                title: tag.text,
                text: info.desc,
                type: 'negative'
            });
        });
        
        // Render signals with time-to-sale insight at the top
        if(signals.length === 0) {
            reasoningContent.innerHTML = '<div style="text-align: center; color: var(--muted); font-size: 11px; padding: 8px;">No specific signals</div>';
        } else {
            // Build time-to-sale insight box (always at the top)
            let timeInsightHTML = '';
            if (res.estimatedDaysToSale !== undefined && res.breakdown) {
                const days = res.estimatedDaysToSale;
                const salesPerMonth = res.breakdown.salesPerMonth || 0;
                const queuePos = res.breakdown.queuePosition || 0;
                
                let timeColor = days <= 30 ? 'var(--green)' : days <= 90 ? 'var(--yellow)' : 'var(--red)';
                let timeLabel = days <= 7 ? '~1 week' : 
                                days <= 14 ? '~2 weeks' :
                                days <= 30 ? '~1 month' :
                                days <= 60 ? '~2 months' :
                                days <= 90 ? '~3 months' :
                                `~${Math.round(days/30)} months`;
                
                let waitDescription = days <= 30 ? 'Quick flip ‚Äî your capital turns over fast' :
                                      days <= 90 ? 'Medium wait ‚Äî acceptable for this profit margin' :
                                      days <= 180 ? 'Patient inventory ‚Äî longer hold but manageable' :
                                      'Very slow mover ‚Äî requires patience and shelf space';
                
                timeInsightHTML = `
                    <div style="background: rgba(34,211,238,0.1); border-radius: 8px; padding: 12px; margin-bottom: 12px; border-left: 3px solid var(--diamond);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 10px; font-weight: 700; color: var(--diamond); text-transform: uppercase;">‚è±Ô∏è Expected Time to Sale</span>
                            <span style="font-size: 16px; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: ${timeColor};">${timeLabel}</span>
                        </div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.7); line-height: 1.5; margin-bottom: 8px;">
                            ${waitDescription}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div style="background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 8px; color: var(--muted); text-transform: uppercase; font-weight: 700; margin-bottom: 2px;">Sales/Month</div>
                                <div style="font-size: 12px; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: var(--text);">${salesPerMonth.toFixed(1)}</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 8px; color: var(--muted); text-transform: uppercase; font-weight: 700; margin-bottom: 2px;">Queue Position</div>
                                <div style="font-size: 12px; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: var(--text);">${queuePos.toFixed(1)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            reasoningContent.innerHTML = timeInsightHTML + signals.map(sig => `
                <div class="signal-item">
                    <span class="signal-icon">${sig.icon}</span>
                    <div class="signal-text">
                        <strong>${sig.title}</strong>
                        ${sig.text ? `<p>${sig.text}</p>` : ''}
                    </div>
                </div>
            `).join('');
        }
    }
    
    // --- Render Pricing Strategy Section ---
    renderPricingStrategy(data, res.market, res.profit);
    
    // --- Auto-load Gemini Opinion (No Badge Needed) ---
    const geminiOpinion = document.getElementById('geminiOpinion');
    
    // Check if Gemini API key exists AND the verdict is 'CONSIDER'
    // BUT: Don't re-run if we already have a Gemini response (from condition toggle)
    if(CONFIG.geminiKey && res.verdict === 'CONSIDER' && currentScan && !currentScan.geminiScore) {
        // Auto-load Gemini opinion for CONSIDER items (only once)
        loadGeminiOpinion(); 
    } else if(currentScan && currentScan.geminiScore && res.verdict === 'CONSIDER') {
        // If we already have Gemini data and verdict is still CONSIDER, just render it
        renderGeminiOpinion(currentScan.geminiVerdict, currentScan.geminiScore, currentScan.geminiReasoning);
        geminiOpinion.classList.remove('hidden');
    } else {
        geminiOpinion.classList.add('hidden');
    }
    // --- End Gemini Auto-load Logic ---

    card.classList.remove('hidden');
}

/* ================= PRICING STRATEGY RENDERER ================= */
function renderPricingStrategy(data, recommendedPrice, profit) {
    const strategyBody = document.getElementById('pricingStrategyBody');
    const strategySection = document.getElementById('pricingStrategySection');
    if (!strategyBody || !strategySection) return;
    
    // Select the appropriate price range based on current condition
    const isNewCondition = CONFIG.condition === 'NEW';
    const activeRange = isNewCondition ? data.newPriceRange : data.usedPriceRange;
    const currentPrice = isNewCondition ? data.newPrice : data.usedPrice;
    const conditionLabel = isNewCondition ? 'NEW' : 'USED';
    
    console.log('renderPricingStrategy:', { 
        condition: CONFIG.condition, 
        activeRange, 
        currentPrice,
        hasNewRange: data.newPriceRange?.hasData,
        hasUsedRange: data.usedPriceRange?.hasData
    });
    
    // Hide section if no price history data for this condition
    if (!activeRange || !activeRange.hasData) {
        strategySection.style.display = 'none';
        return;
    }
    
    strategySection.style.display = 'block';
    
    const range = activeRange;
    const isEstimated = range.isEstimated;
    
    // Determine strategy based on spread
    let strategyType = 'TIGHT_RANGE';
    let strategyNotes = '';
    
    if (range.spread >= 5 && range.spread / range.min >= 0.20) {
        strategyType = 'WIDE_RANGE';
        strategyNotes = `Wide pricing range for ${conditionLabel}. Start at recommended price, lower gradually if no BB wins.`;
    } else {
        strategyType = 'TIGHT_RANGE';
        strategyNotes = `Tight pricing for ${conditionLabel}. Match competitive price immediately.`;
    }
    
    // Build HTML content
    strategyBody.innerHTML = `
        <div style="background: rgba(251,191,36,0.1); border-radius: 8px; padding: 12px; margin-bottom: 12px; border-left: 3px solid var(--yellow);">
            <div style="font-size: 9px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; letter-spacing: 0.05em;">
                Current ${conditionLabel} Buy Box Price
            </div>
            <div style="font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: var(--yellow);">
                ${currentPrice > 0 ? '$' + currentPrice.toFixed(2) : 'No ' + conditionLabel + ' Sellers'}
            </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 12px;">
            <span style="font-size: 10px; color: var(--muted); font-weight: 600;">Historical ${conditionLabel} Range (90d${isEstimated ? ', est.' : ''}):</span>
            <span style="font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 12px;">
                <span style="color: var(--red);">$${range.min.toFixed(2)}</span>
                <span style="color: var(--muted); margin: 0 6px;">‚Üí</span>
                <span style="color: var(--green);">$${range.max.toFixed(2)}</span>
            </span>
        </div>
        
        <div style="font-size: 11px; color: rgba(255,255,255,0.8); line-height: 1.5; padding: 10px; background: rgba(34,211,238,0.1); border-radius: 8px; border-left: 3px solid var(--diamond);">
            <strong style="color: var(--diamond);">${strategyType === 'WIDE_RANGE' ? 'Wide Range Strategy' : 'Tight Range Strategy'}:</strong> 
            ${strategyNotes}
        </div>
        
        ${currentPrice === 0 && !isNewCondition ? `
            <div style="margin-top: 10px; padding: 10px; background: rgba(34,211,238,0.15); border-radius: 8px; border-left: 3px solid var(--diamond);">
                <strong style="color: var(--diamond); font-size: 11px;">üí° Opportunity:</strong>
                <div style="font-size: 10px; color: rgba(255,255,255,0.8); margin-top: 4px; line-height: 1.4;">
                    No ${conditionLabel} sellers! You have pricing power. Consider listing above typical range.
                </div>
            </div>
        ` : ''}
        
        ${data.amzPrice > 0 ? `
            <div style="margin-top: 10px; padding: 8px; background: rgba(239,68,68,0.1); border-radius: 6px; font-size: 10px; border-left: 3px solid var(--red);">
                <strong style="color: var(--red);">‚ö†Ô∏è Amazon Present:</strong> 
                <span style="color: rgba(255,255,255,0.8);">
                    Amazon is selling at $${data.amzPrice.toFixed(2)}. They often control Buy Box.
                </span>
            </div>
        ` : ''}
    `;
}

/* ================= SCORE EXPLANATION LOGIC (NEW) ================= */

function toggleScoreExplanation() {
    const content = document.getElementById('scoreExplanationContent');
    const icon = document.getElementById('scoreExplanationToggleIcon');
    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        icon.classList.replace('fa-chevron-down', 'fa-chevron-up');
    } else {
        content.classList.add('hidden');
        icon.classList.replace('fa-chevron-up', 'fa-chevron-down');
    }
}

function renderScoreExplanation(res, data) {
    const content = document.getElementById('scoreExplanationContent');
    if (!content) return;

    const b = res.breakdown;
    const bbPrice = data.inferredBbPrice;
    
    let bbTypeInfo = '';
    if (data.bbOwnerType === 'ROTATING_FBA') {
        bbTypeInfo = `The Buy Box is typically **FBA-rotated** at the price of the lowest FBA offer ($${data.fbaPrice.toFixed(2)}). This is a stable, high-confidence BB type.`;
    } else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') {
        bbTypeInfo = `The Buy Box is currently driven by **FBM/MF sellers** at the lowest price ($${data.usedPrice.toFixed(2)}). FBA offers must be priced aggressively to win against this competition.`;
    } else {
        bbTypeInfo = `The Buy Box is **suppressed**. Pricing is based on historical averages and is volatile.`;
    }

    let bbRotation = 'N/A';
    // Logic for BB rotation frequency based on velocity and competition
    if (data.drops30 > 0 && data.fbaCount > 0) {
        const estSellsPerDay = data.drops30 / 30;
        const estDaysToSellout = data.fbaCount / estSellsPerDay;
        
        if (estDaysToSellout < 7) {
            bbRotation = 'HIGH (Daily)';
        } else if (estDaysToSellout < 30) {
            bbRotation = 'MEDIUM (Weekly)';
        } else {
            bbRotation = 'LOW (Monthly+)';
        }
    } else if (data.drops30 > 0) {
         bbRotation = 'HIGH (No FBA competition)';
    }


    const historicalPriceRange = `
        <span style="color:var(--green);">$${data.avgUsed.toFixed(2)} (Avg Used)</span> to 
        <span style="color:var(--blue);">$${data.avgNew.toFixed(2)} (Avg New)</span>
    `;

    content.innerHTML = `
        <div class="score-details-content">
            
            <div class="score-details-section">
                <div class="score-details-title"><i class="fas fa-calculator"></i> Score Calculation (Base 50)</div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Base Score</span>
                    <span class="metric-value-num">50</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Velocity (30d Sales: ${data.drops30})</span>
                    <span class="metric-value-num" style="color:${b.velocityScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.velocityScore > 0 ? '+' : ''}${b.velocityScore}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Buy Box Quality (${data.bbOwnerType.replace('_', ' ')})</span>
                    <span class="metric-value-num" style="color:${b.bbScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.bbScore > 0 ? '+' : ''}${b.bbScore}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Competition (FBA Offers: ${data.fbaCount})</span>
                    <span class="metric-value-num" style="color:${b.compScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.compScore > 0 ? '+' : ''}${b.compScore}</span>
                </div>
                ${b.profitPenalty > 0 ? `
                <div class="score-details-metric-row" style="border-top: 1px dashed rgba(255,255,255,0.1); margin-top: 5px; padding-top: 5px;">
                    <span class="metric-name">PROFIT PENALTY (Below $${CONFIG.profitFloor.toFixed(2)} Floor)</span>
                    <span class="metric-value-num" style="color:var(--red);">- ${b.profitPenalty.toFixed(2)}</span>
                </div>
                ` : ''}
                <div class="score-details-metric-row" style="border-top: 2px solid var(--border); margin-top: 10px; padding-top: 5px;">
                    <span class="metric-name">FINAL SCORE</span>
                    <span class="metric-value-num" style="color:var(--diamond); font-size:14px;">${res.score}</span>
                </div>
            </div>
            
            <div class="score-details-section">
                <div class="score-details-title"><i class="fas fa-chart-line"></i> Market & Buy Box Dynamics</div>
                <p>
                    ${bbTypeInfo}
                </p>
                <div class="score-details-metric-row" style="margin-top: 10px;">
                    <span class="metric-name">BB Rotation Frequency (Est.)</span>
                    <span class="metric-value-num">${bbRotation}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">90-Day Historical Range (Avg)</span>
                    <span class="metric-value-num">${historicalPriceRange}</span>
                </div>
            </div>
        </div>
    `;
}

/* ================= TOGGLE FUNCTIONS (CLEANED) ================= */

function updateSliderDisplays() {
    const cost = parseFloat(document.getElementById('sliderCost').value);
    const floor = parseFloat(document.getElementById('sliderFloor').value);
    
    const costValueEl = document.getElementById('costValue');
    const floorValueEl = document.getElementById('floorValue');
    
    if(costValueEl) costValueEl.textContent = '$' + cost.toFixed(2);
    if(floorValueEl) floorValueEl.textContent = '$' + floor.toFixed(2);
}

function renderTags(id, tags) {
    const el = document.getElementById(id);
    if(!el) return;
    el.innerHTML = '';
    tags.forEach(t => {
        el.innerHTML += `<span class="tag ${t.type}">${t.text}</span>`;
    });
}

/* ================= CAMERA (ROBUST) ================= */
let html5QrCode;
let scanMode = 'barcode'; // 'barcode' or 'isbn'
let ocrInterval = null;

function openCamera() {
    startCamera();
}

function switchScanMode(mode) {
    scanMode = mode;
    
    // Update button states
    document.getElementById('mode-barcode').classList.toggle('active', mode === 'barcode');
    document.getElementById('mode-isbn').classList.toggle('active', mode === 'isbn');
    
    // Update frame visibility
    document.getElementById('scan-frame-barcode').classList.toggle('hidden', mode === 'barcode');
    document.getElementById('scan-frame-isbn').classList.toggle('hidden', mode === 'barcode');
    
    // Restart camera with new mode
    if(html5QrCode) {
        stopCamera();
        setTimeout(() => startCamera(), 500);
    }
}

function updateCameraStatus(state, text) {
    const status = document.getElementById('camera-status');
    if(!status) return;
    
    status.className = 'camera-status ' + state;
    status.textContent = text;
}

function startCamera() {
    const overlay = document.getElementById('camera-overlay');
    overlay.classList.remove('hidden');
    
    if(scanMode === 'barcode') {
        startBarcodeScanner();
    } else {
        startISBNScanner();
    }
}

function startBarcodeScanner() {
    updateCameraStatus('', 'Ready to scan barcode...');
    
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" }, 
        { fps: 10, qrbox: { width: 250, height: 150 } },
        (decodedText) => {
            // Success!
            updateCameraStatus('success', '‚úì Barcode Detected!');
            
            if(navigator.vibrate) navigator.vibrate(200);
            
            setTimeout(() => {
                stopCamera();
                document.getElementById('scanInput').value = decodedText;
                addToQueue(decodedText);
            }, 500);
        },
        (errorMessage) => {
            // Scanning...
            if(!errorMessage.includes('No MultiFormat Readers')) {
                updateCameraStatus('detecting', 'üîç Scanning...');
            }
        }
    ).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startISBNScanner() {
    updateCameraStatus('', 'Position ISBN in frame...');
    
    // Start video stream
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: { width: 280, height: 80 } },
        () => {}, // Not using barcode callback
        () => {}  // Not using error callback
    ).then(() => {
        // Start OCR processing
        startOCRProcessing();
    }).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startOCRProcessing() {
    let isProcessing = false;
    let attemptCount = 0;
    
    // Update status with helpful instruction
    updateCameraStatus('detecting', 'üìñ HOLD STEADY - Reading ISBN...');
    
    ocrInterval = setInterval(async () => {
        if(isProcessing) return;
        
        isProcessing = true;
        attemptCount++;
        
        // Show progress
        updateCameraStatus('detecting', `üìñ HOLD STEADY - Attempt ${attemptCount}...`);
        
        try {
            // Capture frame from video
            const video = document.querySelector('#reader video');
            if(!video) {
                isProcessing = false;
                return;
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw video frame
            ctx.drawImage(video, 0, 0);
            
            // FIX #1: IMAGE PREPROCESSING for better OCR
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert to grayscale and increase contrast
            for(let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                // Increase contrast: make darks darker, lights lighter
                const contrast = avg < 128 ? avg * 0.7 : avg * 1.3;
                data[i] = data[i + 1] = data[i + 2] = Math.min(255, Math.max(0, contrast));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Run OCR on preprocessed frame
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                logger: () => {}, // Suppress logs
                tessedit_char_whitelist: '0123456789X' // Only numbers and X for ISBN
            });
            
            // Extract ISBN from text
            const isbn = extractISBN(text);
            
            if(isbn) {
                // Success!
                updateCameraStatus('success', '‚úì ISBN Detected!');
                
                if(navigator.vibrate) navigator.vibrate(200);
                
                clearInterval(ocrInterval);
                
                setTimeout(() => {
                    stopCamera();
                    document.getElementById('scanInput').value = isbn;
                    addToQueue(isbn);
                }, 500);
            } else {
                isProcessing = false;
            }
            
        } catch(err) {
            console.error('OCR error:', err.message || err);
            isProcessing = false;
        }
    }, 1000); // FIX #1: Check every 1 second (was 2 seconds)
}

function extractISBN(text) {
    // Remove all spaces and hyphens
    const cleaned = text.replace(/[\s\-]/g, '');
    
    // Look for ISBN-13 (starts with 978 or 979)
    const isbn13Match = cleaned.match(/97[89]\d{10}/);
    if(isbn13Match) return isbn13Match[0];
    
    // Look for ISBN-10 (10 digits or 9 digits + X)
    const isbn10Match = cleaned.match(/\d{9}[0-9X]/i);
    if(isbn10Match) return isbn10Match[0];
    
    return null;
}

function stopCamera() {
    document.getElementById('camera-overlay').classList.add('hidden');
    
    if(ocrInterval) {
        clearInterval(ocrInterval);
        ocrInterval = null;
    }
    
    if(html5QrCode) {
        html5QrCode.stop().then(() => html5QrCode.clear()).catch(() => {});
    }
}

/* ================= GEMINI (AUTO-LOAD FOR CONSIDER) ================= */
async function loadGeminiOpinion() {
    if(!lastData || !currentScan) return;
    if(!CONFIG.geminiKey) return; 
    
    const geminiOpinion = document.getElementById('geminiOpinion');
    if(!geminiOpinion) return;
    
    if (currentScan.geminiScore) {
        renderGeminiOpinion(currentScan.geminiVerdict, currentScan.geminiScore, currentScan.geminiReasoning);
        return;
    }
    
    const result = analyze(lastData);
    const baseScore = result.score;
    
    geminiOpinion.className = 'gemini-opinion loading';
    geminiOpinion.innerHTML = `
        <div class="gemini-header">
            <div class="gemini-title">
                <span>ü§ñ</span>
                <span>GEMINI SECOND OPINION</span>
            </div>
        </div>
        <div style="text-align:center; padding:30px; color:var(--muted);">
            <i class="fas fa-circle-notch fa-spin" style="font-size:24px; margin-bottom:10px;"></i>
            <div>Analyzing item...</div>
        </div>
    `;
    geminiOpinion.classList.remove('hidden');
    
    const itemType = lastData.category || 'item';
    const prompt = `Analyze this ${itemType} for Amazon FBA resale:

ITEM DETAILS:
Title: ${lastData.title}
Category: ${lastData.category || 'Unknown'}
Sales Rank: ${lastData.rank ? lastData.rank.toLocaleString() : 'Unknown'}

FINANCIAL ANALYSIS:
Your Cost: $${CONFIG.buyCost.toFixed(2)}
Recommended Sell Price: $${result.market.toFixed(2)}
CALCULATED NET PROFIT: $${result.profit.toFixed(2)} 
(This includes ALL Amazon FBA fees, referral fees, closing fees, and your cost. This is the FINAL profit number - do NOT recalculate.)

MARKET DATA:
Sales Velocity (30 days): ${lastData.drops30} drops
Sales Velocity (180 days): ${lastData.drops180} drops
Total Competition: ${lastData.totalOffers} sellers
Current Buy Box: $${lastData.inferredBbPrice > 0 ? lastData.inferredBbPrice.toFixed(2) : 'N/A'}

INITIAL ASSESSMENT:
Your Algorithm Score: ${baseScore}/100 (CONSIDER tier - needs second opinion)

YOUR TASK: Provide a decisive second opinion. Refine the algorithm's score based on the qualitative data (title, profit-to-wait ratio, and competition).

BUSINESS CONTEXT:
- Inventory with 3-6 month sell-through is acceptable if profit is solid
- Books don't expire or go out of style quickly
- Storage costs are already factored into the profit calculation
- Higher profit can justify slower velocity

EVALUATION CRITERIA:
1. Refine the algorithm's score (0-100 scale).
2. Use the $${result.profit.toFixed(2)} profit figure provided above. Do NOT recalculate fees or profit.
3. Focus on whether the profit justifies the wait time, not just velocity alone.
4. Slower sales are acceptable if profit margin is solid relative to effort.

SCORE RANGES:
- 75-100: BUY (Highly recommended)
- 50-74: CONSIDER (Marginal/Needs caution)
- 0-49: REJECT (High risk/Low reward)

Provide a brief explanation (2-3 sentences) focusing on the profit-to-wait-time value proposition.

Respond EXACTLY in this format:
VERDICT: [BUY, CONSIDER, or REJECT]
SCORE: [0-100]
REASONING: [Your explanation]`;

    const model = 'gemini-2.0-flash-exp';
    const cleanKey = CONFIG.geminiKey.trim();

    try {
        let url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${cleanKey}`;
        
        if(CONFIG.useProxy) {
            url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });
        
        const json = await response.json();
        
        if(json.error) throw new Error(json.error.message);

        if(json.candidates && json.candidates[0] && json.candidates[0].content) {
            const text = json.candidates[0].content.parts[0].text;
            
            const verdictMatch = text.match(/VERDICT:\s*(BUY|CONSIDER|REJECT)/i);
            const scoreMatch = text.match(/SCORE:\s*(\d+)/);
            const reasoningMatch = text.match(/REASONING:\s*(.+)/s);

            const geminiVerdict = verdictMatch ? verdictMatch[1].toUpperCase() : 'CONSIDER';
            const geminiScore = scoreMatch ? parseInt(scoreMatch[1]) : 50;
            const geminiReasoning = reasoningMatch ? reasoningMatch[1].trim() : text;

            if(currentScan) {
                currentScan.geminiVerdict = geminiVerdict;
                currentScan.geminiScore = geminiScore;
                currentScan.geminiReasoning = geminiReasoning;
                
                if(scanHistory[0]) {
                    scanHistory[0].geminiVerdict = geminiVerdict;
                    scanHistory[0].geminiScore = geminiScore;
                    scanHistory[0].geminiReasoning = geminiReasoning;
                    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
                }
            }
            
            renderGeminiOpinion(geminiVerdict, geminiScore, geminiReasoning, baseScore);
        }
    } catch(e) { 
        console.error('Gemini error:', e.message);
        geminiOpinion.innerHTML = `
            <div class="gemini-header">
                <div class="gemini-title">
                    <span>ü§ñ</span>
                    <span>GEMINI UNAVAILABLE</span>
                </div>
            </div>
            <div style="text-align:center; padding:20px; color:var(--muted); font-size:12px;">
                ${e.message.includes('API') ? 'Check your API key in Settings' : 'Connection error'}
            </div>
        `;
    }
}

function renderGeminiOpinion(geminiVerdict, geminiScore, geminiReasoning, baseScoreOverride) {
    const geminiOpinion = document.getElementById('geminiOpinion');
    const result = analyze(lastData);
    const baseScore = baseScoreOverride !== undefined ? baseScoreOverride : result.score;
    
    // Determine the Trend (Upgrade, Downgrade, Refined)
    const isUpgrade = geminiScore > baseScore;
    const isDowngrade = geminiScore < baseScore;
    const trendIcon = isUpgrade ? '‚Üë' : isDowngrade ? '‚Üì' : '‚Üí';
    const trendText = isUpgrade ? 'UPGRADED' : isDowngrade ? 'DOWNGRADED' : 'REFINED';
    const trendClass = isUpgrade ? 'up' : isDowngrade ? 'down' : '';

    // Determine the Visual Tier (Color Coding based on destination)
    let tierClass = 'downgrade'; // Default REJECT (Red)
    if (geminiScore >= 75) {
        tierClass = 'upgrade'; // BUY (Green)
    } else if (geminiScore >= 50) {
        tierClass = 'loading'; // CONSIDER (Amber/Blue)
    }

    if (geminiScore >= 75) {
        const hasGemTags = result.posTags.concat(result.negTags).some(tag => tag.type === 'gem');
        if (hasGemTags) {
            const gemIcon = document.getElementById('gemIcon');
            if (gemIcon) gemIcon.classList.add('visible');
        }
    }

    geminiOpinion.className = 'gemini-opinion ' + tierClass;
    geminiOpinion.innerHTML = `
        <div class="gemini-header">
            <div class="gemini-title ${tierClass}">
                <span>ü§ñ</span>
                <span>GEMINI ${trendText}</span>
            </div>
            <div class="collapse-icon" onclick="toggleGeminiCollapse()">‚àí</div>
        </div>

        <div class="gemini-content" id="geminiContent">
            <div class="score-comparison">
                <div class="score-box">
                    <div class="score-box-label">Algo Score</div>
                    <div class="score-box-value amber">${baseScore}</div>
                </div>

                <div class="score-arrow ${trendClass}">${trendIcon}</div>

                <div class="score-box">
                    <div class="score-box-label">Gemini Score</div>
                    <div class="score-box-value ${tierClass}">${geminiScore}</div>
                </div>
            </div>

            <div class="gemini-verdict ${tierClass}">
                ${geminiVerdict} Tier
            </div>

            <div class="gemini-text">${geminiReasoning}</div>
        </div>
    `;

    geminiOpinion.classList.remove('hidden');
}

function toggleGeminiCollapse() {
    const content = document.getElementById('geminiContent');
    const icon = document.querySelector('.collapse-icon');
    if(content && icon) {
        content.classList.toggle('hidden');
        icon.textContent = content.classList.contains('hidden') ? '+' : '‚àí';
    }
}

/* ================= SETTINGS ================= */
function showSettings() {
    document.getElementById('settingsPage').classList.remove('hidden');
    document.getElementById('keepaKey').value = CONFIG.keepaKey;
    document.getElementById('geminiKey').value = CONFIG.geminiKey;
    document.getElementById('defCost').value = CONFIG.buyCost;
    document.getElementById('defFloor').value = CONFIG.profitFloor;
}

function closeSettings() {
    document.getElementById('settingsPage').classList.add('hidden');
}

function saveSettings() {
    CONFIG.keepaKey = document.getElementById('keepaKey').value.trim();
    CONFIG.geminiKey = document.getElementById('geminiKey').value.trim();
    CONFIG.buyCost = parseFloat(document.getElementById('defCost').value);
    CONFIG.profitFloor = parseFloat(document.getElementById('defFloor').value);
    CONFIG.useProxy = document.getElementById('toggleProxy').classList.contains('active');
    CONFIG.fastScan = document.getElementById('toggleFastScan').classList.contains('active');
    
    localStorage.setItem('keepaKey', CONFIG.keepaKey);
    localStorage.setItem('geminiKey', CONFIG.geminiKey);
    localStorage.setItem('buyCost', CONFIG.buyCost);
    localStorage.setItem('profitFloor', CONFIG.profitFloor);
    localStorage.setItem('useProxy', CONFIG.useProxy);
    localStorage.setItem('fastScan', CONFIG.fastScan);
    
    updateTokenUI();
    updateConditionUI();
    closeSettings();
}

/* ================= HISTORY MANAGEMENT (VIEW & DELETE) ================= */

let focusedDeleteTimestamp = null;

function toggleDeleteConfirmation(timestamp) {
    const wrapper = document.querySelector(`.history-item-wrapper[data-timestamp="${timestamp}"]`);
    const overlay = wrapper ? wrapper.querySelector('.delete-confirm-overlay') : null;
    
    // If we click the same item again (to cancel), or cancel
    if(focusedDeleteTimestamp === timestamp) {
        if(overlay) overlay.classList.remove('active');
        focusedDeleteTimestamp = null;
        return;
    }
    
    // First, close any currently open confirmation
    if (focusedDeleteTimestamp) {
        toggleDeleteConfirmation(focusedDeleteTimestamp);
    }
    
    // Then, open the new confirmation
    if (overlay) {
        overlay.classList.add('active');
        focusedDeleteTimestamp = timestamp;
    }
}

function deleteScan(timestamp) {
    // We already have a confirmation built into the UI, so we only need the filter/re-render logic
    
    const initialLength = scanHistory.length;
    
    scanHistory = scanHistory.filter(item => item.timestamp !== timestamp);
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    if (scanHistory.length < initialLength) {
        // Successful deletion
        if (navigator.vibrate) navigator.vibrate(50);
        focusedDeleteTimestamp = null;
        showHistory(); // Re-render the history page
    } else {
        alert("Error deleting item.");
    }
}


function showHistory() {
    const page = document.getElementById('historyPage');
    const list = document.getElementById('historyList');
    
    if(!list) return;
    
    focusedDeleteTimestamp = null; // Reset focus when opening history
    
    // Calculate restricted count
    const restrictedCount = scanHistory.filter(item => item.restricted).length;
    const restrictedCountEl = document.getElementById('restrictedCount');
    const restrictedCountText = document.getElementById('restrictedCountText');
    const btnRemoveRestricted = document.getElementById('btnRemoveRestricted');
    
    if(restrictedCount > 0) {
        restrictedCountEl.style.display = 'flex';
        btnRemoveRestricted.style.display = 'block';
        restrictedCountText.textContent = `${restrictedCount} restricted`;
    } else {
        restrictedCountEl.style.display = 'none';
        btnRemoveRestricted.style.display = 'none';
    }
    
    // Render all history items
    if(scanHistory.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
    } else {
        list.innerHTML = scanHistory.map(item => {
            let color = 'var(--red)';
            if(item.verdict === 'BUY') color = 'var(--green)';
            if(item.verdict === 'CONSIDER') color = 'var(--yellow)';
            
            // Decision badge
            let decisionBadge = '';
            if(item.decision === 'BOUGHT') {
                decisionBadge = `<span style="background:rgba(16,185,129,0.2); color:var(--green); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úì BOUGHT</span>`;
            } else if(item.decision === 'PASSED') {
                decisionBadge = `<span style="background:rgba(239,68,68,0.2); color:var(--red); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úó PASSED</span>`;
            }
            
            // Restricted badge
            let restrictedBadge = '';
            if(item.restricted) {
                restrictedBadge = `<span class="restricted-badge">üîí RESTRICTED</span>`;
            }
            
            // The new history item structure with click handler
            return `
                <div class="history-item-wrapper" data-timestamp="${item.timestamp}">
                    <div class="history-item-content" onclick="toggleDeleteConfirmation(${item.timestamp})">
                        <div style="display:flex; justify-content:space-between; align-items:center; font-weight:700;">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="color:${color}">${item.verdict}</span>
                                ${decisionBadge}
                                ${restrictedBadge}
                            </div>
                            <span style="color:${item.profit >= 0 ? 'var(--green)' : 'var(--red)'}">$${item.profit.toFixed(2)}</span>
                        </div>
                        <div style="font-size:12px; color:var(--muted); margin-top:4px;">${item.title.substring(0,60)}...</div>
                    </div>
                    
                    <div class="delete-confirm-overlay">
                        <div class="delete-message">Delete this scan?</div>
                        <div class="confirm-buttons">
                            <button class="btn-delete-confirm cancel" onclick="toggleDeleteConfirmation(${item.timestamp}); event.stopPropagation();">Cancel</button>
                            <button class="btn-delete-confirm delete" onclick="deleteScan(${item.timestamp}); event.stopPropagation();">DELETE</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    page.classList.remove('hidden');
}

function closeHistory() {
    document.getElementById('historyPage').classList.add('hidden');
}

function removeRestrictedItems() {
    const restrictedCount = scanHistory.filter(item => item.restricted).length;
    
    if(restrictedCount === 0) {
        alert('No restricted items to remove');
        return;
    }
    
    if(!confirm(`Remove ${restrictedCount} restricted item${restrictedCount > 1 ? 's' : ''} from history?`)) {
        return;
    }
    
    // Filter out restricted items
    scanHistory = scanHistory.filter(item => !item.restricted);
    
    // Save to localStorage
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    // Refresh display
    showHistory();
    
    // Show feedback
    alert(`‚úì Removed ${restrictedCount} restricted item${restrictedCount > 1 ? 's' : ''}`);
}

function addToHistory(res, data) {
    // Generate Smart SKU with error handling
    let smartSKU = '';
    try {
        smartSKU = generateSmartSKU(data, res);
    } catch (err) {
        console.error('Smart SKU generation failed:', err);
        // Fallback to basic SKU
        smartSKU = `FALLBACK-${Date.now().toString(36).toUpperCase()}`;
    }
    
    const item = { 
        verdict: res.verdict, 
        profit: res.profit, 
        score: res.score,
        market: res.market, // Add market price for CSV export
        title: data.title,
        asin: data.asin,
        isbn: data.isbn || '', // Add ISBN for CSV export
        category: data.category || 'Unknown',
        sku: smartSKU, // Smart SKU
        buyCost: CONFIG.buyCost, // Capture cost
        profitFloor: CONFIG.profitFloor, // Capture floor
        geminiVerdict: null, // Will be filled when Gemini responds
        geminiScore: null,
        geminiReasoning: null,
        decision: null, // 'BOUGHT', 'PASSED', or null
        timestamp: Date.now()
    };
    
    scanHistory.unshift(item);
    
    // Keep only last 100 scans
    if(scanHistory.length > 100) {
        scanHistory = scanHistory.slice(0, 100);
    }
    
    // Save to localStorage
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    // Set as current scan for decision tracking
    currentScan = item;
}

/* ================= DECISION TRACKING ================= */
function recordDecision(decision) {
    if(!currentScan) {
        alert('No active scan to record decision for');
        return;
    }
    
    // Update current scan
    currentScan.decision = decision;
    
    // Update in scanHistory (it's the first item)
    if(scanHistory[0]) {
        scanHistory[0].decision = decision;
        localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    }
    
    // Visual feedback
    const buttons = document.querySelectorAll('.decision-btn');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.closest('.decision-btn').classList.add('selected');
    
    const note = document.getElementById('decisionNote');
    if(note) {
        const emoji = decision === 'BOUGHT' ? '‚úì' : '‚úó';
        const action = decision === 'BOUGHT' ? 'BUYING' : 'PASSING ON';
        note.textContent = `${emoji} Decision saved: ${action} this item`;
        note.className = 'decision-note success';
    }
    
    // Vibrate if available
    if(navigator.vibrate) navigator.vibrate(100);
}

/* ================= CSV EXPORT (UPDATED) ================= */
function exportCSV() {
    console.log('Export called. Total history items:', scanHistory.length);
    console.log('History verdicts:', scanHistory.map(i => i.verdict));
    
    // Export BUY and CONSIDER items (exclude REJECT)
    const exportable = scanHistory.filter(item => item.verdict !== 'REJECT');
    
    console.log('Exportable items:', exportable.length); 
    
    if(exportable.length === 0) {
        alert(`No items to export!
        
Total items in history: ${scanHistory.length}
Items by verdict:
- BUY: ${scanHistory.filter(i => i.verdict === 'BUY').length}
- CONSIDER: ${scanHistory.filter(i => i.verdict === 'CONSIDER').length}  
- REJECT: ${scanHistory.filter(i => i.verdict === 'REJECT').length}

Only BUY and CONSIDER items are exported.`);
        return;
    }
    
    // Calculate stats
    const exportableLength = exportable.length;
    const totalProfit = exportable.reduce((sum, item) => sum + item.profit, 0);
    
    // Build CSV matching scout_scans_template.csv format
    // Format: TITLE,SCAN DATE,RATING,ISBN,ASIN,RECOMMENDED PRICE
    const headers = ['TITLE', 'SKU', 'ISBN', 'ASIN', 'PRICE'];
    
    const rows = exportable.map(item => {
        // Format date as MM/DD/YYYY
        const date = item.timestamp ? new Date(item.timestamp).toLocaleDateString('en-US') : '';
        
        // Title - escape quotes
        const title = (item.title || '').replace(/"/g, '""');
        
        // RATING = score (0-100)
        const rating = item.score || 0;
        
        // ISBN - extract from stored data
        const isbn = item.isbn || '';
        
        // ASIN
        const asin = item.asin || '';
        
        // RECOMMENDED PRICE - market price without $ or formatting
        const price = item.market ? item.market.toFixed(2) : '0.00';
        
        // Ensure values are wrapped in quotes if they contain commas or quotes
        const safeTitle = `"${title}"`;
        const safeIsbn = `"${isbn}"`;
        const safeAsin = `"${asin}"`;

        const sku = item.sku || '';
        
        return [safeTitle, sku, safeIsbn, safeAsin, price].join(',');
    });
    
    const csv = [headers.join(','), ...rows].join('\n');
    
    // Download file
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scout-export-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    // Show success toast with decision stats
    const toast = document.getElementById('exportToast');
    if(toast) {
        toast.innerHTML = `üìä ${exportableLength} Items Exported ‚Ä¢ $${totalProfit.toFixed(2)} total profit`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), 4000);
    }
}

/* ================= COLLAPSIBLE SECTION TOGGLE ================= */
function toggleSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (!section) return;
    
    section.classList.toggle('open');
}

/* ================= TOGGLE CONDITION FIX ================= */
function setCondition(c) {
    console.log('setCondition called:', c, 'Previous condition:', CONFIG.condition);
    
    // 1. Update State
    CONFIG.condition = c;
    
    // 2. Update UI (Force Toggle)
    const btnUsed = document.getElementById('btnCondUsed');
    const btnNew = document.getElementById('btnCondNew');
    
    if(btnUsed && btnNew) {
        if(c === 'USED') {
            btnUsed.classList.add('active');
            btnNew.classList.remove('active');
        } else {
            btnUsed.classList.remove('active');
            btnNew.classList.add('active');
        }
    }
    
    // 3. Re-run Analysis if we have data
    if(lastData) {
        console.log('Re-analyzing with condition:', c);
        const result = analyze(lastData);
        console.log('New analysis result:', {
            condition: c,
            market: result.market,
            profit: result.profit,
            score: result.score,
            verdict: result.verdict
        });
        render(result, lastData);
    } else {
        console.log('No lastData available to re-analyze');
    }
}
</script>

<script>
// SPLASH SCREEN - Must be at end of body to ensure DOM exists
(function() {
    const splash = document.getElementById('splash-screen');
    if(!splash) return;
    
    // Hide splash after 1.5 seconds
    setTimeout(() => {
        splash.classList.add('splash-hidden');
    }, 1500);
    
    // Emergency failsafe - force hide after 3 seconds
    setTimeout(() => {
        if(!splash.classList.contains('splash-hidden')) {
            splash.style.display = 'none';
        }
    }, 3000);
})();

/* ================= SMART SKU GENERATION ================= */

// Generate Smart SKU based on schema: U1-SS-TT-CCCC-TTTT-SC-VV-HG-A0-PR
function generateSmartSKU(data, result) {
    const CONFIG_SKU = JSON.parse(localStorage.getItem('skuConfig') || '{"source": "OWN"}');
    
    // PP: Schema Version
    const schema = 'U1';
    
    // SS: Source (2 chars from config)
    const source = (CONFIG_SKU.source || 'OW').substring(0, 2).toUpperCase().padEnd(2, 'X');
    
    // TT: Item Type (detect from category)
    let itemType = 'BK';
    const cat = (data.category || '').toLowerCase();
    if (cat.includes('music') || cat.includes('cd')) itemType = 'CD';
    else if (cat.includes('video') || cat.includes('dvd') || cat.includes('movie')) itemType = 'DV';
    else if (cat.includes('video game') || cat.includes('game')) itemType = 'GM';
    
    // CCCC: Cost in cents (4 digits)
    const costCents = Math.round(CONFIG.buyCost * 100);
    const cost = costCents.toString().padStart(4, '0');
    
    // TTTT: Target Profit in cents (4 digits)
    const profitCents = Math.round(CONFIG.profitFloor * 100);
    const targetProfit = profitCents.toString().padStart(4, '0');
    
    // SC: Scout Score (2 digits, 00-99)
    const scoutScore = Math.min(99, Math.max(0, result.score)).toString().padStart(2, '0');
    
    // VV: Velocity Class (based on drops data)
    let velocity = 'VS'; // Slow
    if (data.drops30 >= 10 || data.drops90 >= 30) {
        velocity = 'VF'; // Fast
    } else if (data.drops30 >= 5 || data.drops90 >= 15) {
        velocity = 'VM'; // Medium
    }
    
    // HG: Hidden Gem Type (map from existing gem detection)
    let gemType = 'H0'; // None
    if (result.isGem) {
        // Map based on the gem flags from analyze()
        const isSleeper = (data.drops30 === 0 && result.market > 35);
        const isFbaVoid = (data.fbaCount === 0);
        const isDip = (data.usedPrice > 0 && data.avgUsed > 0 && data.usedPrice < (data.avgUsed * 0.4));
        const isTextbook = (data.newPrice > 80 && data.usedPrice < 20);
        const isRare = (data.totalOffers < 3);
        const isSprinter = (data.drops30 > 3 && data.drops30 > (data.drops90/3 * 1.5));
        const isPhantom = (data.totalOffers > 50);
        const isFbaPrem = (data.fbaPrice > 0 && data.usedPrice > 0 && data.fbaPrice > (data.usedPrice * 1.4));
        
        // Priority mapping (first match wins)
        if (isSleeper) gemType = 'HL';      // Long Tail
        else if (isSprinter) gemType = 'HV'; // Velocity Spike  
        else if (isFbaVoid) gemType = 'HA';  // Amazon Absent (close to FBA void)
        else if (isDip) gemType = 'HB';      // Buy Box Rotation (price dip opportunity)
        else if (isTextbook) gemType = 'HC'; // Condition Arbitrage
        else if (isFbaPrem) gemType = 'HF';  // FBM Delta (FBA premium)
        else if (isRare) gemType = 'HN';     // Niche Audience
        else if (isPhantom) gemType = 'HO';  // Offer Depth
        else gemType = 'HD';                 // Deep Rank (fallback for other gems)
    }
    
    // AG: Age Bucket (always A0 at scan time - 0-30 days)
    const ageBucket = 'A0';
    
    // PR: Pricing Rule (based on scout score per Option B)
    let pricingRule = 'TB'; // Tight Buy Box (default)
    if (result.score >= 85) {
        pricingRule = 'TB'; // Tight Buy Box - protect margin
    } else if (result.score >= 70) {
        pricingRule = 'WB'; // Wide Buy Box - explore ceiling
    } else {
        pricingRule = 'CB'; // Chase Buy Box - chase for velocity
    }
    
    // Assemble SKU
    const sku = `${schema}-${source}-${itemType}-${cost}-${targetProfit}-${scoutScore}-${velocity}-${gemType}-${ageBucket}-${pricingRule}`;
    
    return sku;
}

// Source configuration management
function loadSourceConfig() {
    const config = JSON.parse(localStorage.getItem('skuConfig') || '{"source": "OWN", "sources": []}');
    return config;
}

function saveSourceConfig(config) {
    localStorage.setItem('skuConfig', JSON.stringify(config));
}

function parseSourcesCSV(csvText) {
    const lines = csvText.trim().split('\n');
    const sources = [];
    
    for (const line of lines) {
        const parts = line.split(',').map(p => p.trim());
        if (parts.length >= 2) {
            sources.push({
                code: parts[0].substring(0, 2).toUpperCase(),
                name: parts[1]
            });
        }
    }
    
    return sources;
}

function showSourceSettings() {
    const config = loadSourceConfig();
    
    let sourcesHTML = '';
    if (config.sources && config.sources.length > 0) {
        sourcesHTML = config.sources.map(s => 
            `<option value="${s.code}">${s.name} (${s.code})</option>`
        ).join('');
    } else {
        sourcesHTML = '<option value="OW">Personal (OW)</option>';
    }
    
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:10000;display:flex;align-items:center;justify-content:center;';
    modal.innerHTML = `
        <div style="background:#1e1e1e;border-radius:16px;padding:24px;max-width:500px;width:90%;border:1px solid #333;">
            <h3 style="margin:0 0 16px;color:#fff;font-size:18px;">‚öôÔ∏è SKU Source Settings</h3>
            
            <div style="margin-bottom:16px;">
                <label style="display:block;color:#888;font-size:12px;margin-bottom:8px;font-weight:600;">CURRENT SOURCE</label>
                <select id="sourceSelect" style="width:100%;padding:12px;background:#111;border:1px solid #333;color:#fff;border-radius:8px;font-size:14px;">
                    ${sourcesHTML}
                </select>
            </div>
            
            <div style="margin-bottom:16px;">
                <label style="display:block;color:#888;font-size:12px;margin-bottom:8px;font-weight:600;">UPLOAD SOURCES CSV</label>
                <input type="file" id="csvUpload" accept=".csv" style="width:100%;padding:8px;background:#111;border:1px solid #333;color:#fff;border-radius:8px;font-size:13px;"/>
                <div style="color:#666;font-size:11px;margin-top:4px;">Format: CODE,Name (e.g., NA,Natick)</div>
            </div>
            
            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:20px;">
                <button onclick="this.closest('div').closest('div').parentElement.remove()" style="padding:10px 20px;background:#333;border:1px solid #555;color:#fff;border-radius:8px;cursor:pointer;font-weight:600;">Cancel</button>
                <button id="saveSrcBtn" style="padding:10px 20px;background:#38bdf8;border:none;color:#000;border-radius:8px;cursor:pointer;font-weight:600;">Save</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    const select = document.getElementById('sourceSelect');
    select.value = config.source || 'OW';
    
    document.getElementById('csvUpload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const sources = parseSourcesCSV(evt.target.result);
                config.sources = sources;
                
                select.innerHTML = sources.map(s => 
                    `<option value="${s.code}">${s.name} (${s.code})</option>`
                ).join('');
                
                alert(`‚úì Loaded ${sources.length} sources`);
            };
            reader.readAsText(file);
        }
    });
    
    document.getElementById('saveSrcBtn').onclick = () => {
        config.source = select.value;
        saveSourceConfig(config);
        modal.remove();
        alert('‚úì Source settings saved!');
    };
}
</script>
</body>
</html>