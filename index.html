<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ScoutPro AI v3.1</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

<style>
:root {
  --bg: #0a0e1a;
  --panel: #141b2d;
  --card: #1a2332;
  --border: rgba(255,255,255,.08);
  --text: #ffffff;
  --muted: #8b92ab;
  --green: #10b981;
  --yellow: #fbbf24;
  --red: #ef4444;
  --blue: #3b82f6;
  --purple: #8b5cf6;
}

* { 
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app { 
  max-width: 480px;
  margin: 0 auto;
  min-height: 100vh;
  padding-bottom: 140px;
}

/* Header */
header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--bg);
  padding: 12px;
  border-bottom: 1px solid var(--border);
}

.brand {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.brand-title {
  font-size: 18px;
  font-weight: 800;
  letter-spacing: -0.02em;
}

.brand-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 999px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--blue);
  font-weight: 600;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: var(--blue);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.input-row {
  display: grid;
  grid-template-columns: 1fr auto auto;
  gap: 8px;
  width: 100%;
}

input[type="text"] {
  min-width: 0;
  padding: 14px 16px;
  border-radius: 12px;
  background: var(--panel);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 15px;
  outline: none;
  transition: border-color 0.2s;
}

input[type="text"]:focus {
  border-color: var(--blue);
}

input[type="text"]::placeholder {
  color: var(--muted);
}

button {
  padding: 14px 20px;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: transform 0.1s, opacity 0.2s;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

button:active {
  transform: scale(0.98);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Status Bar */
.status-bar {
  padding: 10px 16px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 12px;
  color: var(--muted);
  background: var(--panel);
  margin: 12px 12px 0;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  pointer-events: none; /* FIX: don't block taps */
}

.status-label {
  color: var(--blue);
}

/* Duplicate Warning */
#dupeWarning {
  padding: 10px 16px;
  margin: 12px;
  background: rgba(251, 191, 36, 0.1);
  border: 1px solid var(--yellow);
  border-radius: 8px;
  color: var(--yellow);
  font-size: 13px;
  display: none;
}

/* Processing State */
.processing {
  margin: 12px;
  padding: 24px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  text-align: center;
  display: none;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto 16px;
  border: 3px solid var(--border);
  border-top-color: var(--blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.processing-text {
  font-size: 14px;
  color: var(--muted);
}

/* Cards */
.card {
  margin: 12px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  overflow: hidden;
}

/* Decision Banner */
.banner {
  padding: 24px 20px;
  text-align: center;
  position: relative;
}

.banner.buy { 
  background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), transparent);
  border-bottom: 2px solid rgba(16, 185, 129, 0.3);
}

.banner.pass { 
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), transparent);
  border-bottom: 2px solid rgba(239, 68, 68, 0.3);
}

.banner.gem {
  background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(16, 185, 129, 0.1));
  border-bottom: 2px solid rgba(251, 191, 36, 0.5);
  box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
}

.gem-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
  border-radius: 999px;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: #000;
  margin-bottom: 8px;
  box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  animation: gem-pulse 2s ease-in-out infinite;
}

.gem-sparkle {
  font-size: 14px;
  animation: sparkle 1.5s ease-in-out infinite;
}

@keyframes gem-pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  }
  50% { 
    transform: scale(1.05);
    box-shadow: 0 6px 20px rgba(251, 191, 36, 0.6);
  }
}

@keyframes sparkle {
  0%, 100% { 
    opacity: 1;
    transform: rotate(0deg);
  }
  50% { 
    opacity: 0.7;
    transform: rotate(180deg);
  }
}

.gem-reasons {
  margin-top: 16px;
  background: rgba(251, 191, 36, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(251, 191, 36, 0.3);
  overflow: hidden;
}

.gem-reasons summary {
  padding: 12px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 700;
  color: #fbbf24;
  user-select: none;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 8px;
}

.gem-reasons summary::-webkit-details-marker {
  display: none;
}

.gem-reasons summary::before {
  content: '‚ñ∂';
  font-size: 10px;
  transition: transform 0.2s;
}

.gem-reasons[open] summary::before {
  transform: rotate(90deg);
}

.gem-reasons-content {
  padding: 0 12px 12px 12px;
  font-size: 12px;
  color: var(--text);
  text-align: left;
  line-height: 1.6;
}

.decision {
  font-size: 32px;
  font-weight: 800;
  letter-spacing: -0.02em;
  margin-bottom: 8px;
}

.banner.buy .decision {
  color: var(--green);
}

.banner.pass .decision {
  color: var(--red);
}

.reason {
  font-size: 14px;
  color: var(--muted);
  margin-bottom: 20px;
}

.stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  margin-bottom: 20px;
  align-items: start;
}

.stat {
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
}

.stat-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--muted);
  margin-bottom: 6px;
  font-weight: 600;
  min-height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  width: 100%;
}

.stat-value {
  font-size: 16px;
  font-weight: 700;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  min-height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.stat-value.negative {
  color: var(--red);
}

.explanation {
  font-size: 13px;
  line-height: 1.6;
  color: var(--muted);
}

/* Sections */
.section {
  padding: 20px;
  border-top: 1px solid var(--border);
}

.section-title {
  font-size: 13px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--muted);
  margin-bottom: 16px;
}

/* Sliders */
.slider-group {
  margin-bottom: 16px;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
}

.slider-value {
  font-weight: 700;
  color: var(--blue);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--card);
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--blue);
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--blue);
  cursor: pointer;
  border: none;
}

/* Buttons */
.btn-toggle {
  width: 100%;
  background: var(--card);
  color: var(--text);
  border: 1px solid var(--border);
  margin-top: 12px;
}

.btn-toggle:hover {
  border-color: var(--blue);
}

/* Settings */
.settings-group {
  margin-bottom: 20px;
}

.settings-label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text);
}

.settings-input {
  width: 100%;
  padding: 12px 14px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 13px;
}

.settings-input:focus {
  outline: none;
  border-color: var(--blue);
}

.settings-hint {
  font-size: 11px;
  color: var(--muted);
  margin-top: 6px;
}

/* History */
.history-item {
  padding: 16px;
  background: var(--card);
  border-radius: 12px;
  margin-bottom: 12px;
  border: 1px solid var(--border);
}

.history-decision {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 8px;
}

.history-decision.ACCEPT {
  background: rgba(16, 185, 129, 0.2);
  color: var(--green);
}

.history-decision.REJECT {
  background: rgba(239, 68, 68, 0.2);
  color: var(--red);
}

.history-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text);
}

.history-meta {
  font-size: 12px;
  color: var(--muted);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  line-height: 1.5;
}

/* Action Buttons */
.actions {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--bg);
  border-top: 1px solid var(--border);
  padding: 12px;
  display: flex;
  gap: 8px;
  max-width: 480px;
  margin: 0 auto;
}

.btn-settings {
  background: var(--card);
  color: var(--text);
  border: 1px solid var(--border);
  flex-shrink: 0;
  width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-download {
  flex: 1;
  background: var(--green);
  color: var(--bg);
  min-width: 0; /* Allow flex item to shrink below content size */
}

.btn-clear {
  flex: 1;
  background: var(--red);
  color: white;
  min-width: 0; /* Allow flex item to shrink below content size */
}

.btn-history {
  flex: 1;
  background: var(--blue);
  color: white;
  min-width: 0; /* Allow flex item to shrink below content size */
}


/* Velocity / Confidence Pills */
.pill-row{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  justify-content:center;
  margin-top:12px;
}
.pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  font-size:11px;
  font-weight:700;
  letter-spacing:0.03em;
  border:1px solid var(--border);
  background: rgba(255,255,255,0.04);
  color: var(--text);
}
.pill .k{
  color: var(--muted);
  font-weight:800;
  text-transform:uppercase;
  letter-spacing:0.06em;
  font-size:10px;
}
.pill.good{ border-color: rgba(16,185,129,0.45); background: rgba(16,185,129,0.08); }
.pill.warn{ border-color: rgba(251,191,36,0.55); background: rgba(251,191,36,0.10); }
.pill.bad{ border-color: rgba(239,68,68,0.55); background: rgba(239,68,68,0.10); }
.pill.info{ border-color: rgba(59,130,246,0.55); background: rgba(59,130,246,0.10); }

/* Utility */
.hidden {
  display: none !important;
}

@keyframes flash {
  0% { opacity: 0; transform: scale(0.95); }
  100% { opacity: 1; transform: scale(1); }
}

.flash {
  animation: flash 0.3s ease-out;
}
</style>
</head>
<body>

<div class="app">

<header>
  <div class="brand">
    <div class="brand-title">ScoutPro AI</div>
    <div class="brand-badge" id="keepaBadge" style="display:none;">
      <div class="status-dot" style="background:var(--green);"></div>
      <span>KEEPA</span>
    </div>
  </div>
  <div class="input-row">
    <input id="scanInput" type="text" placeholder="ISBN, UPC, ASIN, or Title..." autocomplete="off" style="grid-column: 1 / -1;" />
  </div>
</header>

<div class="status-bar" style="display:none;">
  <span id="statusText">Ready to scan</span>
  <span id="itemCount"><span class="status-label">Queue:</span> 0</span>
</div>

<div id="dupeWarning">‚ö†Ô∏è Already scanned ‚Äî ignored</div>

<div class="processing" id="processing">
  <div class="spinner"></div>
  <div class="processing-text">Analyzing with AI...</div>
</div>

<div id="mainPage">
  <div class="card hidden" id="resultCard">
    <div id="banner" class="banner buy">
      <div id="gemBadge" class="gem-badge" style="display:none;">
        <span class="gem-sparkle">‚ú®</span>
        <span>HIDDEN GEM</span>
        <span class="gem-sparkle">‚ú®</span>
      </div>
      <div class="decision" id="decision">ACCEPT</div>
      <div class="reason" id="reason"></div>
      
      <div class="stats">
        <div class="stat">
          <div class="stat-label">Target Price</div>
          <div class="stat-value" id="targetPrice">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">Profit</div>
          <div class="stat-value" id="profit">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">ROI</div>
          <div class="stat-value" id="roi">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">Buy Box</div>
          <div class="stat-value" id="bb">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">Avg Sales Rank</div>
          <div class="stat-value" id="avgRank">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label"><span id="confidenceLabel">Buy Confidence</span></div>
          <div class="stat-value" id="confidence">‚Äî</div>
        </div>
      </div>
      
      <div class="explanation" id="explanation"></div>

    </div>

    <div class="section">
      <div class="section-title">Scanner Controls</div>
      
      <div class="slider-group">
        <div class="slider-label">
          <span>Buy Cost</span>
          <span class="slider-value">$<span id="buyCostVal">1.00</span></span>
        </div>
        <input type="range" min="0.10" max="10" step="0.10" id="buyCostSlider" value="1.00" />
      </div>

      <div class="slider-group">
        <div class="slider-label">
          <span>Profit Floor</span>
          <span class="slider-value">$<span id="profitFloorVal">5.00</span></span>
        </div>
        <input type="range" min="1" max="20" step="1" id="profitFloorSlider" value="5" />
      </div>
    </div>
  </div>
</div>

<div id="settingsPage" class="card" style="display:none;">
  <div class="section">
    <div class="section-title">Settings</div>
    <details id="integrationsPanel" open style="margin-bottom:16px;">
      <summary style="cursor:pointer; font-weight:800; color: var(--text); margin-bottom:10px;">üîë Integrations (API Keys)</summary>
      <div class="settings-hint" style="margin:-4px 0 12px 0;">Keys are stored locally in your browser (localStorage).</div>

    
    <div class="settings-group">
      <label class="settings-label">Keepa API Key</label>
      <input type="text" id="keepaKey" class="settings-input" placeholder="Enter your Keepa API key" />
      <div class="settings-hint">Get your key at <a href="https://keepa.com/#!api" target="_blank" style="color:var(--blue)">keepa.com/#!api</a></div>
    </div>
    </details>
    
    <button id="saveSettings" style="width:100%; background:var(--green); color:var(--bg); margin-top:16px;">
      Save Settings
    </button>
    
    <button id="backFromSettings" style="width:100%; background:var(--panel); color:var(--text); margin-top:8px; border:1px solid var(--border);">
      Back
    </button>
  </div>
</div>

<div id="historyPage" class="card" style="display:none;">
  <div class="section">
    <div class="section-title">Scan History</div>
    <div id="historyList"></div>
    <button id="backBtn" style="margin-top:16px; background:var(--blue); color:white; width:100%;">Back</button>
  </div>
</div>

<div class="actions">
  <button id="settingsBtn" class="btn-settings">‚öôÔ∏è</button>
  <button id="historyBtn" class="btn-history">History</button>
  <button id="downloadBtn" class="btn-download">Download</button>
  <button id="clearBtn" class="btn-clear">Clear</button>
</div>

</div>

<script>
/* ==================== CONFIG ==================== */
let BUY_COST = 1.00;
let PROFIT_FLOOR = 5.00; // HARD floor set by slider


const CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || ''
};

const seenIdentifiers = new Set();
let scanHistory = [];
let buyList = [];
let lastScanData = null;

const scanInput = document.getElementById("scanInput");

/* ==================== BLUETOOTH SCANNER HANDLER ==================== */
/* ‚úÖ Scanner fix (stable):
   - Uses scanInput.value (what the scanner actually types)
   - Processes after short inactivity OR Enter
   - Clears the field after processing so scans don't concatenate
   - Uses .oninput/.onkeydown (overwrites any other handlers -> avoids multi-listener fights)
*/
let __scan_timer = null;

function __scan_clean(v){
  return String(v || "").replace(/[^0-9xXbB]/g,"").trim();
}

// Override-aware finalize: if the app defines finalizeScan(), we'll call it with a value.
// If finalizeScan takes no args, we'll temporarily set scanInput.value then call it.
function __scan_callFinalize(cleanVal){
  if (!cleanVal) return;

  try { if (navigator.vibrate) navigator.vibrate(40); } catch(e) {}

  // Most robust: if app exposes finalizeScanWithValue
  if (typeof window.finalizeScanWithValue === "function") {
    window.finalizeScanWithValue(cleanVal);
    return;
  }

  // If app has finalizeScan(), make it see this value
  if (typeof window.finalizeScan === "function") {
    const prev = scanInput.value;
    scanInput.value = cleanVal;
    try { window.finalizeScan(); }
    finally { /* finalizeScan usually clears it; if not, restore to empty */ }
    return;
  }

  // Fallback
  console.warn("No finalizeScan() found; scanned:", cleanVal);
}

function __scan_processNow(){
  if (__scan_timer) { clearTimeout(__scan_timer); __scan_timer = null; }
  const raw = scanInput.value;
  const cleaned = __scan_clean(raw);

  // Many scanners type 12-14 digits (UPC/EAN) or 10/13 (ISBN)
  if (cleaned.length >= 10) {
    // Clear immediately so next scan doesn't append
    scanInput.value = "";
    __scan_callFinalize(cleaned);
  }
}

scanInput.oninput = () => {
  if (__scan_timer) clearTimeout(__scan_timer);
  // short inactivity window; scanners type in ~50ms bursts
  __scan_timer = setTimeout(__scan_processNow, 80);
};

scanInput.onkeydown = (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    __scan_processNow();
  }
};

// Keep focus for scanner
setTimeout(()=>{ try{ scanInput.focus(); }catch(e){} }, 50);
scanInput.focus();

/* ==================== UPDATE ENGINE BADGE ==================== */
function updateKeepaIndicator() {
  const keepaBadge = document.getElementById("keepaBadge");
  if (CONFIG.keepaKey) {
    keepaBadge.style.display = "flex";
  } else {
    keepaBadge.style.display = "none";
  }
}

// Update on load
updateKeepaIndicator();

/* ==================== SLIDERS ==================== */
const bcSlider = document.getElementById("buyCostSlider");
const pfSlider = document.getElementById("profitFloorSlider");

let sliderTimeout = null;

// Slider UX (no-jitter):
// - oninput only updates labels (no reflow)
// - reanalysis happens on change / pointerup / keyup (after user finishes adjusting)
function scheduleReanalysisAfterAdjust() {
  clearTimeout(sliderTimeout);
  sliderTimeout = setTimeout(() => {
    if (lastScanData) reanalyzeWithNewThresholds();
  }, 120);
}

bcSlider.oninput = () => {
  BUY_COST = parseFloat(bcSlider.value);
  document.getElementById("buyCostVal").textContent = BUY_COST.toFixed(2);
};
bcSlider.onchange = scheduleReanalysisAfterAdjust;
bcSlider.onpointerup = scheduleReanalysisAfterAdjust;
bcSlider.onkeyup = (e) => { if (e.key === "ArrowLeft" || e.key === "ArrowRight") scheduleReanalysisAfterAdjust(); };

pfSlider.oninput = () => {
  PROFIT_FLOOR = parseFloat(pfSlider.value);
  document.getElementById("profitFloorVal").textContent = PROFIT_FLOOR.toFixed(2);
};
pfSlider.onchange = scheduleReanalysisAfterAdjust;
pfSlider.onpointerup = scheduleReanalysisAfterAdjust;
pfSlider.onkeyup = (e) => { if (e.key === "ArrowLeft" || e.key === "ArrowRight") scheduleReanalysisAfterAdjust(); };

/* ==================== SETTINGS ==================== */
document.getElementById("settingsBtn").onclick = () => {
  document.getElementById("mainPage").style.display = "none";
  document.getElementById("settingsPage").style.display = "block";
  document.getElementById("keepaKey").value = CONFIG.keepaKey;
};

document.getElementById("saveSettings").onclick = () => {
  CONFIG.keepaKey = document.getElementById("keepaKey").value.trim();
  
  localStorage.setItem('keepaKey', CONFIG.keepaKey);
  
  updateKeepaIndicator();
  
  alert('‚úÖ Settings saved!');
  document.getElementById("settingsPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

document.getElementById("backFromSettings").onclick = () => {
  document.getElementById("settingsPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

/* ==================== FINALIZE SCAN ==================== */
async function finalizeScan() {
  const input = scanInput.value.trim();
  scanInput.value = "";
  scanInput.focus();

  if (!input) return;
  
  // Vibrate feedback
  if (navigator.vibrate) navigator.vibrate(40);
  
  // Check API keys
  if (!CONFIG.keepaKey) {
    console.warn('No Keepa key - using mock data');
  }
  
  if (CONFIG.useGemini && !CONFIG.geminiKey) {
    alert('‚ö†Ô∏è Gemini is enabled but no API key provided. Falling back to local engine.');
    CONFIG.useGemini = false;
  }
  
  // Detect input type
  const identifier = detectInputType(input);
  
  if (checkDuplicate(identifier)) return;
  
  document.getElementById("statusText").textContent = `Processing: ${identifier}`;
  
  // Show processing state
  document.getElementById("processing").style.display = "block";
  document.getElementById("resultCard").classList.add("hidden");
  
  try {
    // Step 1: Query Keepa
    const keepaData = await queryKeepa(identifier, input);
    
    if (!keepaData) {
      throw new Error("Item not found in Keepa database");
    }
    
    // Step 2: Analyze with local engine (not Gemini - that's only for double-checking)
    const decision = localDecisionEngine(keepaData);
    
    // Step 3: Display result
    displayResult(decision, keepaData);
    
    // Step 4: Add to history
    addToHistory(decision, keepaData);
    
    document.getElementById("statusText").textContent = keepaData.title;
    document.getElementById("processing").style.display = "none";
    
  } catch (error) {
    console.error('Scan error:', error);
    
    // More specific error messages
    let errorMsg = error.message;
    if (errorMsg.includes('Failed to fetch')) {
      errorMsg = 'Network error. Check your internet connection.';
    } else if (errorMsg.includes('API key')) {
      errorMsg = 'Invalid API key. Check Settings.';
    } else if (errorMsg.includes('not found')) {
      errorMsg = 'Product not found in database.';
    }
    
    document.getElementById("statusText").textContent = "Error ‚Äî try again";
    document.getElementById("processing").style.display = "none";
    
    // Show error in result card
    document.getElementById("resultCard").classList.remove("hidden");
    document.getElementById("banner").className = "banner pass";
    document.getElementById("decision").textContent = "ERROR";
    document.getElementById("reason").textContent = errorMsg;
    document.getElementById("explanation").innerHTML = `‚ö†Ô∏è ${error.message}`;
  }
}

/* ==================== INPUT DETECTION ==================== */
function detectInputType(input) {
  const cleaned = input.replace(/[^0-9X]/gi, '');
  
  // ISBN-10 or ISBN-13
  if (cleaned.length === 10 || cleaned.length === 13) {
    return cleaned;
  }
  
  // UPC/EAN (12-14 digits)
  if (cleaned.length >= 12 && cleaned.length <= 14) {
    return cleaned;
  }
  
  // ASIN (B + 9 alphanumeric)
  if (/^B[0-9A-Z]{9}$/i.test(input)) {
    return input.toUpperCase();
  }
  
  // Otherwise treat as title search
  return input;
}

/* ==================== DUPLICATE CHECK ==================== */
function checkDuplicate(identifier) {
  if (seenIdentifiers.has(identifier)) {
    document.getElementById("dupeWarning").style.display = "block";
    setTimeout(() => document.getElementById("dupeWarning").style.display = "none", 2000);
    return true;
  }
  seenIdentifiers.add(identifier);
  return false;
}

/* ==================== KEEPA API ==================== */
async function queryKeepa(identifier, rawInput) {
  // Check if we have a Keepa key
  if (!CONFIG.keepaKey) {
    console.warn('No Keepa key - using mock data');
    return getMockKeepaData(identifier, rawInput);
  }
  
  try {
    // Keepa Product API endpoint
    const domain = 1; // 1 = US Amazon (.com)
    
    // Build query based on identifier type
    let queryParam = '';
    const isNumeric = /^[0-9X]+$/i.test(identifier);
    
    if (isNumeric) {
      // ISBN/UPC/EAN
      queryParam = `code=${encodeURIComponent(identifier)}`;
    } else if (/^B[0-9A-Z]{9}$/i.test(identifier)) {
      // ASIN
      queryParam = `asin=${encodeURIComponent(identifier)}`;
    } else {
      // Title search - need to get ASIN first
      // For now, throw error - title search is complex
      throw new Error('Title search not yet implemented. Please scan ISBN/UPC or enter ASIN.');
    }
    
    // Keepa API parameters:
    // stats: 0 = no stats, 1 = include stats like sales rank drops
    // history: 0 = no history, 1 = price history (we need this for csv arrays!)
    const stats = 1; // Include stats (sales rank drops, etc)
    const history = 1; // Include price history (needed for csv arrays!)
    
    const keepaUrl = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=${domain}&${queryParam}&stats=${stats}&history=${history}`;
    
    // Use CORS proxy to avoid browser CORS restrictions
    const corsProxy = 'https://corsproxy.io/?';
    const url = corsProxy + encodeURIComponent(keepaUrl);
    
    console.log('Keepa API call:', keepaUrl.replace(CONFIG.keepaKey, 'HIDDEN'));
    
    const response = await fetch(url);
    
    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit reached. Please wait a moment.');
      }
      throw new Error(`Keepa API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Check if product found
    if (!data.products || data.products.length === 0) {
      throw new Error('Product not found in Keepa database');
    }
    
    const product = data.products[0];
    
    // Parse Keepa data
    return parseKeepaProduct(product);
    
  } catch (error) {
    console.error('Keepa query error:', error);
    throw error;
  }
}

/* ==================== PARSE KEEPA PRODUCT ==================== */
function parseKeepaProduct(product) {
  console.log('Raw Keepa product data:', product);

  // Keepa uses -1 to indicate no data. Prices are returned in cents.
  const toDollars = (v) => (v === -1 || v === null || v === undefined) ? 0 : (v / 100);
  const toCount   = (v) => (v === -1 || v === null || v === undefined) ? 0 : v;

  // Prefer the stats.current array when stats is requested.
  // CsvType mapping (Keepa): AMAZON=0, NEW=1, USED=2, SALES=3, ... NEW_FBM_SHIPPING=7, NEW_FBA=10, BUY_BOX_SHIPPING=18
  // See Keepa CsvType docs listing NEW_FBA + BUY_BOX_SHIPPING. 
  const cur = product.stats && Array.isArray(product.stats.current) ? product.stats.current : null;

  const pAmazon = cur ? toDollars(cur[0])  : 0;
  const pNew    = cur ? toDollars(cur[1])  : 0;
  const pUsed   = cur ? toDollars(cur[2])  : 0;
  const pFBMShip= cur ? toDollars(cur[7])  : 0;   // FBM new incl shipping
  const pFBA    = cur ? toDollars(cur[10]) : 0;   // lowest 3P FBA new
  const pBuyBox = cur ? toDollars(cur[18]) : 0;   // buy box incl shipping

  // Rank
  const salesRank = cur ? toCount(cur[3]) : 999999;

  // Offer counts (not split FBA/FBM unless offers=... is requested; we avoid that to save tokens)
  const countNew = cur ? toCount(cur[11]) : 0; // COUNT_NEW
  const countUsed = cur ? toCount(cur[12]) : 0; // COUNT_USED

  // Derive "competitive sell price" for *your* listing:
  // For books, Buy Box and "Marketplace New" can be FBM-heavy. NEW_FBA is usually the best proxy for Prime-competitive pricing.
  // Strategy:
  // 1) If Buy Box exists AND it's close to NEW_FBA -> treat as FBA market
  // 2) Else prefer NEW_FBA (Prime price) if present
  // 3) Else fall back to FBM+shipping, then NEW, then USED, then AMAZON
  const competitiveFBA = pFBA > 0 ? pFBA : 0;
  const competitiveFBM = pFBMShip > 0 ? pFBMShip : (pNew > 0 ? pNew : 0);

  // Guess winner
  let buyBoxWinner = "NONE";
  if (pBuyBox > 0 && pAmazon > 0 && Math.abs(pBuyBox - pAmazon) <= 0.01) {
    buyBoxWinner = "AMAZON";
  } else if (pBuyBox > 0 && competitiveFBA > 0 && (Math.abs(pBuyBox - competitiveFBA) / competitiveFBA) <= 0.03) {
    buyBoxWinner = "FBA";
  } else if (pBuyBox > 0 && competitiveFBM > 0 && (Math.abs(pBuyBox - competitiveFBM) / competitiveFBM) <= 0.03) {
    buyBoxWinner = "FBM";
  } else if (competitiveFBA > 0) {
    buyBoxWinner = "FBA";
  } else if (competitiveFBM > 0) {
    buyBoxWinner = "FBM";
  }

  // Choose the market price anchor we will price against
  const marketPrice = (competitiveFBA > 0) ? competitiveFBA : (pBuyBox > 0 ? pBuyBox : (competitiveFBM > 0 ? competitiveFBM : (pUsed > 0 ? pUsed : pAmazon)));

  const approxFBA = (competitiveFBA > 0) ? Math.max(1, Math.min(8, Math.round(countNew * 0.4) || 1)) : 0;
  const approxFBM = Math.max(0, countNew - approxFBA);

  const parsedData = {
    asin: product.asin,
    title: product.title || 'Unknown Title',
    brand: product.brand || '',
    manufacturer: product.manufacturer || '',
    categoryTree: product.categoryTree || [],
    salesRank: salesRank,
    salesRankDrops30: toCount(product.stats?.salesRankDrops30) || 0,
    salesRankDrops90: toCount(product.stats?.salesRankDrops90) || 0,

    // Price signals
    currentPriceAmazon: pAmazon,
    currentPriceNew: pNew,
    currentPriceUsed: pUsed,
    currentPriceFBM: competitiveFBM,
    currentPriceFBA: competitiveFBA,
    currentPriceBuyBox: pBuyBox,
    marketPrice: marketPrice,

    buyBoxWinner: buyBoxWinner,

    // Counts (approx; Keepa doesn't split FBA/FBM counts unless offers=... is requested)
    offerCountNew: countNew,
    offerCountUsed: countUsed,
    offerCountFBA: approxFBA,
    offerCountFBM: approxFBM,

    // Weight: Keepa stores in 0.01 lb units
    weight: product.packageWeight ? (product.packageWeight / 100) : 1.0,

    publicationDate: product.releaseDate ? new Date(product.releaseDate * 60000) : null
  };

  console.log('Parsed Keepa data:', parsedData);
  
  // Check for restricted brands specific to books/media
  const restrictedBrands = ['universal', 'national geographic', 'scholastic'];
  const brandLower = (parsedData.brand || '').toLowerCase();
  const isPotentiallyRestricted = restrictedBrands.some(b => brandLower.includes(b));
  
  if (isPotentiallyRestricted) {
    parsedData.restrictionWarning = `‚ö†Ô∏è ${parsedData.brand} may require approval`;
  }
  
  return parsedData;

  console.log('Final parsed data:', parsedData);
  return parsedData;
}


/* ==================== MOCK KEEPA DATA (for testing) ==================== */
function getMockKeepaData(identifier, rawInput) {
  console.log('Using mock data for:', identifier);
  
  // Generate semi-random but consistent data based on identifier
  const hash = identifier.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  
  return {
    asin: `B${identifier.slice(0, 9).padEnd(9, '0')}`,
    title: `Mock Book: ${rawInput}`,
    salesRank: 50000 + (hash % 200000),
    salesRankDrops30: Math.floor(hash % 50),
    salesRankDrops90: Math.floor(hash % 150),
    currentPriceAmazon: hash % 3 === 0 ? 15 + (hash % 20) : 0,
    currentPriceFBA: 12 + (hash % 15),
    currentPriceFBM: 10 + (hash % 18),
    buyBoxWinner: hash % 3 === 0 ? "AMAZON" : (hash % 2 === 0 ? "FBA" : "FBM"),
    offerCountFBA: Math.floor(hash % 15) + 1,
    offerCountFBM: Math.floor(hash % 10),
    priceVolatility: "STABLE",
    weight: 0.5 + (hash % 20) / 10,
    publicationDate: new Date(2020 + (hash % 5), hash % 12, 1)
  };
}

/* ==================== GEMINI ANALYSIS ENGINE (FIXED) ==================== */

/* ==================== HIDDEN GEMS DETECTION ==================== */
function detectHiddenGems(keepaData, decision) {
  const gems = [];
  const title = keepaData.title.toLowerCase();
  
  // CRITICAL: Only detect gems for ACCEPT decisions with:
  // 1. Positive profit above floor
  // 2. High confidence (75%+) - we don't call borderline buys "hidden gems"
  if (decision.verdict !== "ACCEPT" || decision.profit < PROFIT_FLOOR) {
    return gems; // No gems for rejects or unprofitable items
  }
  
  const confidence = decision.confidence || 0;
  if (confidence < 75) {
    return gems; // No gems for low/medium confidence buys - reserve for strong buys only
  }
  
  // GEM 1: High ROI despite borderline profit
  if (decision.roi >= 200 && decision.profit >= PROFIT_FLOOR * 0.8) {
    gems.push({
      type: 'high-roi',
      icon: 'üöÄ',
      label: 'Exceptional ROI',
      details: `${decision.roi}% return on investment`
    });
  }
  
  // GEM 2: Low competition FBA
  if (keepaData.offerCountFBA <= 3 && keepaData.salesRank < 200000) {
    gems.push({
      type: 'low-competition',
      icon: 'üíé',
      label: 'Low FBA competition',
      details: `Only ${keepaData.offerCountFBA} FBA sellers on good rank`
    });
  }
  
  // GEM 3: Amazon controls BB but we can still profit
  if (keepaData.buyBoxWinner === "AMAZON" && decision.verdict === "ACCEPT") {
    gems.push({
      type: 'amazon-gap',
      icon: 'üéØ',
      label: 'Amazon gap opportunity',
      details: 'Can undercut Amazon profitably'
    });
  }
  
  // GEM 4: High velocity (lots of sales)
  if (keepaData.salesRankDrops30 >= 30) {
    gems.push({
      type: 'high-velocity',
      icon: '‚ö°',
      label: 'Fast seller',
      details: `${keepaData.salesRankDrops30} rank drops in 30 days`
    });
  }
  
  // GEM 5: Price protection (high margin despite fees)
  if (decision.profit >= PROFIT_FLOOR * 1.5) {
    gems.push({
      type: 'price-cushion',
      icon: 'üõ°Ô∏è',
      label: 'Price cushion',
      details: `$${decision.profit.toFixed(2)} profit gives pricing flexibility`
    });
  }
  
  // GEM 6: Top 50k sales rank
  if (keepaData.salesRank < 50000) {
    gems.push({
      type: 'top-rank',
      icon: 'üëë',
      label: 'Top 50k rank',
      details: 'Excellent sales velocity'
    });
  }
  
  // GEM 7: Lightweight (lower fees)
  if (keepaData.weight < 1.0 && decision.profit > PROFIT_FLOOR) {
    gems.push({
      type: 'lightweight',
      icon: 'ü™∂',
      label: 'Lightweight advantage',
      details: 'Lower FBA fees boost margins'
    });
  }
  
  // GEM 8: Steady seller (90-day consistency)
  if (keepaData.salesRankDrops90 >= 60 && keepaData.salesRankDrops30 >= 15) {
    gems.push({
      type: 'steady-seller',
      icon: 'üìà',
      label: 'Consistent sales',
      details: 'Strong 90-day track record'
    });
  }
  
  // GEM 9: FBM dominant but FBA opportunity
  if (keepaData.buyBoxWinner === "FBM" && keepaData.offerCountFBA <= 2 && decision.verdict === "ACCEPT") {
    gems.push({
      type: 'fba-upgrade',
      icon: 'üì¶',
      label: 'FBA upgrade play',
      details: 'Win Buy Box with Prime shipping'
    });
  }
  
  // GEM 10: Monopoly opportunity
  if (keepaData.offerCountFBA === 0 && keepaData.salesRank < 300000) {
    gems.push({
      type: 'monopoly',
      icon: 'üèÜ',
      label: 'FBA monopoly',
      details: 'Be the only FBA seller'
    });
  }
  
  // GEM 11: Rising rank (improving sales)
  const rankImprovement = keepaData.salesRankDrops30 / Math.max(1, keepaData.salesRankDrops90 / 3);
  if (rankImprovement >= 1.5) {
    gems.push({
      type: 'rising-trend',
      icon: 'üìä',
      label: 'Sales trending up',
      details: 'Recent velocity increasing'
    });
  }
  
  // GEM 12: High profit absolute
  if (decision.profit >= 15) {
    gems.push({
      type: 'high-profit',
      icon: 'üí∞',
      label: 'High profit margin',
      details: `$${decision.profit.toFixed(2)} profit per unit`
    });
  }
  
  // GEM 13: Sweet spot rank (100k-200k)
  if (keepaData.salesRank >= 100000 && keepaData.salesRank <= 200000 && decision.profit >= PROFIT_FLOOR) {
    gems.push({
      type: 'sweet-spot',
      icon: 'üé™',
      label: 'Sweet spot rank',
      details: 'Good velocity without high competition'
    });
  }
  
  // GEM 14: No Amazon competition
  if (keepaData.currentPriceAmazon === 0 && keepaData.salesRank < 200000) {
    gems.push({
      type: 'no-amazon',
      icon: 'üö´',
      label: 'Amazon not competing',
      details: 'Third-party sellers only'
    });
  }
  
  // GEM 15: Double ROI minimum
  if (decision.roi >= 100 && decision.profit >= PROFIT_FLOOR) {
    gems.push({
      type: 'double-roi',
      icon: 'üé∞',
      label: 'Double your money',
      details: `${decision.roi}% ROI`
    });
  }
  
  // GEM 16: Underpriced market
  if (keepaData.currentPriceFBA > 0 && decision.targetPrice >= keepaData.currentPriceFBA * 1.1) {
    gems.push({
      type: 'underpriced',
      icon: 'üí∏',
      label: 'Underpriced market',
      details: 'Current pricing leaves room'
    });
  }
  
  // GEM 17: Niche dominance (few sellers, good rank)
  if ((keepaData.offerCountFBA + keepaData.offerCountFBM) <= 5 && keepaData.salesRank < 150000) {
    gems.push({
      type: 'niche',
      icon: 'üéØ',
      label: 'Niche opportunity',
      details: 'Low competition in active market'
    });
  }
  
  // GEM 18: Buy Box ready (can win immediately)
  if (keepaData.buyBoxWinner === "FBA" && decision.targetPrice < keepaData.currentPriceFBA) {
    gems.push({
      type: 'bb-ready',
      icon: 'üéÅ',
      label: 'Buy Box ready',
      details: 'Will win Buy Box immediately'
    });
  }
  
  // GEM 19: Seasonal timing (basic detection)
  const month = new Date().getMonth();
  const seasonal = (month >= 10 || month <= 1) && (title.includes('christmas') || title.includes('holiday') || title.includes('winter'));
  if (seasonal) {
    gems.push({
      type: 'seasonal',
      icon: 'üéØ',
      label: 'Seasonal timing',
      details: 'Peak demand window for this topic'
    });
  }
  
  // GEM 20: New release momentum
  if (keepaData.publicationDate) {
    const pubDate = new Date(keepaData.publicationDate);
    const monthsOld = (Date.now() - pubDate.getTime()) / (1000 * 60 * 60 * 24 * 30);
    if (monthsOld < 6 && keepaData.salesRank < 100000) {
      gems.push({
        type: 'new-release',
        icon: 'üÜï',
        label: 'New release momentum',
        details: `Published ${Math.round(monthsOld)} months ago with strong rank`
      });
    }
  }
  
  // GEM 21: Textbook potential
  if (decision.targetPrice > 30 && (title.includes('edition') || title.includes('textbook'))) {
    gems.push({
      type: 'textbook',
      icon: 'üéì',
      label: 'Textbook potential',
      details: 'High-value educational book'
    });
  }
  
  // GEM 22: Collectible premium
  if (keepaData.condition && keepaData.condition.includes('Collectible') && decision.profit > 8) {
    gems.push({
      type: 'collectible',
      icon: 'üè∫',
      label: 'Collectible premium',
      details: 'Collectible condition commands higher prices'
    });
  }
  
  // GEM 23: First edition
  if (title.includes('first edition') || title.includes('1st edition')) {
    gems.push({
      type: 'first-edition',
      icon: 'üìñ',
      label: 'First edition',
      details: 'First editions have collector value'
    });
  }
  
  // GEM 24: Out of print
  if (keepaData.outOfPrint) {
    gems.push({
      type: 'out-of-print',
      icon: 'üîí',
      label: 'Out of print',
      details: 'Limited supply increases value'
    });
  }
  
  // GEM 25: Floor protection working
  if (decision.targetPrice === 8.00 && decision.profit >= 5) {
    gems.push({
      type: 'floor-protection',
      icon: 'üõ°Ô∏è',
      label: 'Floor protection active',
      details: 'Raised to $8 floor but still profitable'
    });
  }
  
  return gems;
}

/* ==================== LOCAL FALLBACK DECISION ENGINE ==================== */

/* ==================== VELOCITY + ACCELERATION ==================== */
function computeVelocitySignals(keepaData) {
  const d30 = Number(keepaData.salesRankDrops30 || 0);
  const d90 = Number(keepaData.salesRankDrops90 || 0);

  // Weighted toward recent activity
  const velocityScore = (d30 * 3 + d90) / 4;

  let velocityBand = "VERY_SLOW";
  if (d30 >= 30) velocityBand = "FAST";
  else if (d30 >= 15) velocityBand = "STEADY";
  else if (d30 >= 5) velocityBand = "SLOW";

  // Compare recent 30d drops to the 90d average pace
  const expected30 = d90 / 3;
  let trend = "STABLE";
  if (d30 > expected30 * 1.25) trend = "ACCELERATING";
  else if (d30 < expected30 * 0.75) trend = "DECLINING";

  return {
    drops30: d30,
    drops90: d90,
    expected30: Math.round(expected30),
    velocityScore: Math.round(velocityScore),
    velocityBand,
    trend
  };
}

/* Auto-tune profit floor based on velocity + trend (Scoutly-style) */
function getEffectiveProfitFloor(baseFloor, velocity) {
  let soft = baseFloor;

  if (velocity.velocityBand === "FAST") soft = Math.max(baseFloor * 1.25, baseFloor);
  else if (velocity.velocityBand === "STEADY") soft = Math.max(baseFloor * 1.15, baseFloor);
  else if (velocity.velocityBand === "SLOW") soft = Math.max(baseFloor * 1.05, baseFloor);
  else soft = Math.max(baseFloor * 1.5, baseFloor);

  if (velocity.trend === "ACCELERATING") soft *= 1.1;
  if (velocity.trend === "DECLINING") soft *= 0.95;

  // HARD FLOOR: never allow below slider
  return Math.round(Math.max(baseFloor, soft) * 4) / 4;
}

/* Simple confidence heuristic for LOCAL engine (Gemini can override with its own confidence) */
/* ==================== CONFIDENCE CALCULATION ==================== 
 * Confidence score (5-95%) represents how sure we are about the decision.
 * 
 * For ACCEPT decisions:
 *   - 75%+ = Strong buy (good profit, good velocity, clear price signals)
 *   - 50-75% = Moderate buy (acceptable profit but some risk factors)
 *   - <50% = REJECT (auto-converted - we don't recommend low-confidence buys)
 * 
 * For REJECT decisions:
 *   - Higher % = More confident in rejecting (clear reasons to pass)
 *   - Lower % = Borderline reject (might work but too risky)
 * 
 * Factors that increase confidence:
 *   + Clear market price data (FBA/Buy Box prices available)
 *   + Profit well above floor ($5+ cushion)
 *   + Fast/Steady sales velocity (many rank drops)
 *   + Accelerating trend (sales speeding up)
 * 
 * Factors that decrease confidence:
 *   - Missing price data
 *   - Thin margins (profit barely above floor)
 *   - Slow/Very slow velocity
 *   - Declining trend
 *   - Extremely high rank (>1M) with low margin
 */
function computeLocalConfidence(keepaData, velocity, decision, profit, effectiveFloor) {
  let score = 50;

  // Price signal quality
  const hasMarket = (keepaData.currentPriceFBA && keepaData.currentPriceFBA > 0) || (keepaData.currentPriceBuyBox && keepaData.currentPriceBuyBox > 0);
  score += hasMarket ? 10 : -20;

  // Margin strength
  const marginDelta = profit - effectiveFloor;
  if (marginDelta >= 5) score += 20;
  else if (marginDelta >= 2) score += 12;
  else if (marginDelta >= 0) score += 6;
  else score -= 12;

  // Velocity
  if (velocity.velocityBand === "FAST") score += 15;
  else if (velocity.velocityBand === "STEADY") score += 10;
  else if (velocity.velocityBand === "SLOW") score += 2;
  else score -= 12;

  // Trend
  if (velocity.trend === "ACCELERATING") score += 8;
  else if (velocity.trend === "DECLINING") score -= 10;

  // Extreme slow mover penalty unless big margin
  if ((keepaData.salesRank || 0) >= 1000000 && velocity.velocityBand === "VERY_SLOW" && profit < (effectiveFloor * 1.5)) score -= 15;

  // Clamp
  score = Math.max(5, Math.min(95, Math.round(score)));

  // If decision is REJECT but confidence too high, keep it realistic
  if (decision.verdict === "REJECT") score = Math.min(score, 85);

  return score;
}

function localDecisionEngine(keepaData) {
  // -------- Pricing anchor (book-aware) --------
  // Prefer FBA market price (Prime-competitive). If not available, fall back to Buy Box, then FBM.
  const market = (keepaData.currentPriceFBA && keepaData.currentPriceFBA > 0)
    ? keepaData.currentPriceFBA
    : ((keepaData.currentPriceBuyBox && keepaData.currentPriceBuyBox > 0)
        ? keepaData.currentPriceBuyBox
        : (keepaData.currentPriceFBM || keepaData.marketPrice || 0));

  // Undercut strategy by who appears to control the BB
  let targetPrice = market || 0;
  if (keepaData.buyBoxWinner === "AMAZON" && keepaData.currentPriceAmazon > 0) {
    targetPrice = keepaData.currentPriceAmazon * 0.95; // undercut Amazon
  } else if (keepaData.buyBoxWinner === "FBM" && targetPrice > 0) {
    targetPrice = targetPrice * 0.98;
  } else if (keepaData.buyBoxWinner === "FBA" && targetPrice > 0) {
    targetPrice = targetPrice * 0.97;
  }

  // If we don't have any price signal, it's unsafe.
  if (!targetPrice || targetPrice <= 0) {
    return {
      verdict: "REJECT",
      targetPrice: 0,
      profit: -999,
      roi: -999,
      reasoning: "‚úó No reliable price signal from Keepa (missing FBA/BB/New prices)."
    };
  }

  // -------- Fee model (book-aware, Scoutly-ish) --------
  // We don't have exact dimensions, so we use a conservative estimator:
  // - Referral fee: ~15% for most categories
  // - Closing fee (media): ~$1.80 per unit (books are media) 
  // - Fulfillment fee: weight-based approximation; if < $10, apply Low-Price FBA discount (about $0.86 on avg)
  // Sources (high-level): Amazon Seller Central low-price FBA discount + media closing fee references.
  function estimateFbaFees(price, weightLbs) {
    const referral = price * 0.15;

    // Media closing fee (books)
    const closing = 1.80;

    // Fulfillment fee rough model:
    // Base for ~1 lb standard-size is ~3.2; add ~0.35 per extra lb (conservative)
    const w = Math.max(0.25, weightLbs || 1.0);
    let fulfillment = 3.20 + Math.max(0, w - 1.0) * 0.35;

    // Low-Price FBA (under $10) discount
    if (price < 10) fulfillment = Math.max(2.00, fulfillment - 0.86);

    return { referral, closing, fulfillment, total: (referral + closing + fulfillment) };
  }

  const shippingToAmazon = 0.75; // inbound prep/ship estimate
  const totalCOGS = BUY_COST + shippingToAmazon;

  const fees = estimateFbaFees(targetPrice, keepaData.weight);
  const profit = targetPrice - totalCOGS - fees.total;
  const roi = Math.round((profit / Math.max(0.01, totalCOGS)) * 100);

  // Confidence (local heuristic)

  // -------- Decision logic tuned for real-world book scans --------
  // Rank is a snapshot; drops are the story.
  const velocity = computeVelocitySignals(keepaData);

  // Auto-tuned profit floor (soft for FAST/ACCELERATING, stricter for VERY_SLOW/DECLINING)
  const effectiveFloor = getEffectiveProfitFloor(PROFIT_FLOOR, velocity);

  // Slow mover heuristic: very high rank + very low drops
  const slowMover = ((keepaData.salesRank || 0) >= 900000 && velocity.drops30 < 5);



  let verdict = "REJECT";
  let reasoning = "";

  if (profit < 0) {
    reasoning = `‚úó Not profitable<br>‚úó Est. loss: $${Math.abs(profit).toFixed(2)}<br>‚úó Fees (est): $${fees.total.toFixed(2)} (ref $${fees.referral.toFixed(2)} + close $${fees.closing.toFixed(2)} + FBA $${fees.fulfillment.toFixed(2)})`;
  } else if (slowMover && profit < (PROFIT_FLOOR * 1.25)) {
    reasoning = `‚úó Likely slow mover (rank ${keepaData.salesRank.toLocaleString()}, drops30 ${keepaData.salesRankDrops30})<br>‚úó Profit $${profit.toFixed(2)} not high enough to justify storage risk`;
  } else if (profit < effectiveFloor) {
    reasoning = `‚úó Profit $${profit.toFixed(2)} below floor ($${effectiveFloor.toFixed(2)})<br>‚úó ROI: ${roi}%<br>‚úó Price signal: $${targetPrice.toFixed(2)} vs market $${(market||0).toFixed(2)}`;
  } else {
    // Temporarily set to ACCEPT to calculate confidence
    verdict = "ACCEPT";
    
    // Calculate confidence BEFORE finalizing verdict
    const tempConfidence = computeLocalConfidence(keepaData, velocity, { verdict }, profit, effectiveFloor);
    
    // If confidence is too low, reject it - we shouldn't recommend low-confidence buys
    if (tempConfidence < 50) {
      verdict = "REJECT";
      reasoning = `‚úó Low confidence buy (${tempConfidence}%)<br>‚úó Profit $${profit.toFixed(2)} exists but signals are weak<br>‚úó Rank: ${(keepaData.salesRank || 0).toLocaleString()} ‚Ä¢ Drops: ${keepaData.salesRankDrops30}`;
    } else {
      // Good confidence - proceed with ACCEPT
      const velocityTag = velocity.velocityBand === 'FAST' ? "‚úì Good velocity signals" : "‚úì Profit meets target";
      reasoning =
        `‚úì Profit: $${profit.toFixed(2)} (${roi}% ROI)<br>` +
        `${velocityTag}<br>` +
        `‚úì Target: $${targetPrice.toFixed(2)} ‚Ä¢ Market: $${(market||0).toFixed(2)} ‚Ä¢ BB: ${keepaData.buyBoxWinner}`;
    }
  }

    // Finalize local confidence
  const confidence = computeLocalConfidence(keepaData, velocity, { verdict }, profit, effectiveFloor);

  return {
    verdict,
    targetPrice: Math.round(targetPrice * 100) / 100,
    profit: Math.round(profit * 100) / 100,
    roi,
    reasoning,
    confidence,
    velocity
  };
}

/* ==================== DISPLAY RESULT ==================== */
function displayResult(decision, keepaData) {
  lastScanData = { decision, keepaData };
  
  const banner = document.getElementById("banner");
  const cls = decision.verdict === "ACCEPT" ? "buy" : "pass";
  
  // Detect hidden gems
  const gems = detectHiddenGems(keepaData, decision);
  const isGem = gems.length > 0;
  
  banner.className = `banner ${cls}${isGem ? ' gem' : ''}`;
  
  // Show/hide gem badge
  const gemBadge = document.getElementById("gemBadge");
  if (isGem) {
    gemBadge.style.display = "inline-flex";
  } else {
    gemBadge.style.display = "none";
  }
  
  document.getElementById("decision").textContent = decision.verdict;
  document.getElementById("reason").textContent = keepaData.title;
  
  document.getElementById("targetPrice").textContent = `$${decision.targetPrice.toFixed(2)}`;
  document.getElementById("profit").textContent = `$${decision.profit.toFixed(2)}`;
  document.getElementById("roi").textContent = `${decision.roi}%`;
  document.getElementById("bb").textContent = keepaData.buyBoxWinner;
  
  // Calculate average sales rank (simple approximation - current rank)
  const avgRank = keepaData.salesRank;
  document.getElementById("avgRank").textContent = avgRank > 0 ? avgRank.toLocaleString() : "‚Äî";
  
  // Calculate confidence
  const v = (decision && decision.velocity) ? decision.velocity : computeVelocitySignals(keepaData);
  const effFloor = getEffectiveProfitFloor(PROFIT_FLOOR, v);
  const conf = (typeof decision.confidence === "number") ? decision.confidence : computeLocalConfidence(keepaData, v, decision, decision.profit, effFloor);
  
  // Update confidence label and value - show as STRONG/MODERATE/WEAK signal
  const confidenceLabel = document.getElementById("confidenceLabel");
  
  // For REJECT decisions, invert the confidence and change label
  // Low buy confidence = High reject confidence
  let displayConf = conf;
  if (decision.verdict === "REJECT") {
    confidenceLabel.textContent = "Pass Confidence";
    displayConf = 100 - conf;
  } else {
    confidenceLabel.textContent = "Buy Confidence";
  }
  
  let signalStrength = "WEAK";
  if (displayConf >= 75) {
    signalStrength = "STRONG";
  } else if (displayConf >= 50) {
    signalStrength = "MODERATE";
  }
  
  document.getElementById("confidence").textContent = `${signalStrength} (${Math.round(displayConf)}%)`;
  
  const profitEl = document.getElementById("profit");
  profitEl.className = "stat-value"; // Always regular styling, no color change
  
  // Build explanation with gem reasons
  let explanationHTML = decision.reasoning;
  
  // Add brand info if available
  if (keepaData.brand) {
    explanationHTML += `<br><br><strong>Brand:</strong> ${keepaData.brand}`;
  }
  
  // Add restriction warning if present
  if (keepaData.restrictionWarning) {
    explanationHTML += `<br><div style="margin-top:8px;padding:8px;background:rgba(251,191,36,0.1);border:1px solid rgba(251,191,36,0.4);border-radius:6px;color:#fbbf24;font-size:12px;">${keepaData.restrictionWarning}</div>`;
  }
  
  if (isGem) {
    explanationHTML += '<details class="gem-reasons" open><summary>‚ú® Why This is a Hidden Gem</summary><div class="gem-reasons-content">';
    gems.forEach(gem => {
      explanationHTML += `<div style="margin:6px 0;">${gem.icon} <strong>${gem.label}:</strong> ${gem.details}</div>`;
    });
    explanationHTML += '</div></details>';
  }
  
  document.getElementById("explanation").innerHTML = explanationHTML;
  
  document.getElementById("resultCard").classList.remove("hidden");
  document.getElementById("resultCard").classList.add("flash");
  setTimeout(() => document.getElementById("resultCard").classList.remove("flash"), 300);
}

/* ==================== REANALYZE ==================== */
async function reanalyzeWithNewThresholds() {
  if (!lastScanData) return;
  
  // Don't show spinner for reanalysis - update in place
  // Always use local engine for reanalysis (not Gemini)
  try {
    const decision = localDecisionEngine(lastScanData.keepaData);
    displayResult(decision, lastScanData.keepaData);
    document.getElementById("statusText").textContent = lastScanData.keepaData.title;
  } catch (error) {
    console.error('Reanalysis error:', error);
    // Silently fail - keep showing old data
  }
}

/* ==================== HISTORY ==================== */
function addToHistory(decision, keepaData) {
  const gems = detectHiddenGems(keepaData, decision);
  
  const record = {
    verdict: decision.verdict,
    title: keepaData.title,
    asin: keepaData.asin,
    price: decision.targetPrice.toFixed(2),
    profit: decision.profit.toFixed(2),
    roi: decision.roi,
    time: new Date().toLocaleTimeString(),
    isGem: gems.length > 0,
    gemTypes: gems.map(g => g.label).join(', ')
  };
  
  scanHistory.push(record);
  if (decision.verdict === "ACCEPT") {
    buyList.push(record);
  }
  
  updateHistoryUI();
  document.getElementById("itemCount").innerHTML = `<span class="status-label">Queue:</span> ${buyList.length}`;
}

function updateHistoryUI() {
  const list = document.getElementById("historyList");
  list.innerHTML = '';
  
  scanHistory.slice().reverse().forEach(rec => {
    const div = document.createElement("div");
    div.className = "history-item";
    
    const gemBadge = rec.isGem ? `<span style="color:#fbbf24;font-size:14px;margin-right:4px;">‚ú®</span>` : '';
    
    div.innerHTML = `
      <div class="history-decision ${rec.verdict}">${gemBadge}${rec.verdict}</div>
      <div class="history-title">${rec.title}</div>
      <div class="history-meta">
        ASIN: ${rec.asin}<br>
        Price: $${rec.price} ‚Ä¢ Profit: $${rec.profit} ‚Ä¢ ROI: ${rec.roi}%<br>
        ${rec.isGem ? `<span style="color:#fbbf24;">üíé ${rec.gemTypes}</span><br>` : ''}
        ${rec.time}
      </div>
    `;
    list.appendChild(div);
  });
}

/* ==================== NAVIGATION ==================== */
document.getElementById("historyBtn").onclick = () => {
  document.getElementById("mainPage").style.display = "none";
  document.getElementById("historyPage").style.display = "block";
};

document.getElementById("backBtn").onclick = () => {
  document.getElementById("historyPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

/* ==================== CSV DOWNLOAD ==================== */
document.getElementById("downloadBtn").onclick = () => {
  if (buyList.length === 0) return alert("No items in buy queue.");

  let csv = "Title,ASIN,TargetPrice,Profit,ROI,HiddenGem,GemReasons\n";
  buyList.forEach(r => {
    const gemFlag = r.isGem ? 'YES' : 'NO';
    const gemReasons = r.isGem ? `"${r.gemTypes}"` : '';
    csv += `"${r.title}",${r.asin},${r.price},${r.profit},${r.roi}%,${gemFlag},${gemReasons}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `scoutpro_buylist_${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
};

/* ==================== CLEAR DATA ==================== */
document.getElementById("clearBtn").onclick = () => {
  if (!confirm("Clear all scan data and buy queue?")) return;

  scanHistory.length = 0;
  buyList.length = 0;
  lastScanData = null;
  seenIdentifiers.clear();

  document.getElementById("historyList").innerHTML = "";
  document.getElementById("itemCount").innerHTML = `<span class="status-label">Queue:</span> 0`;
  document.getElementById("statusText").textContent = "Ready to scan";
  document.getElementById("resultCard").classList.add("hidden");
};
</script>

</body>
</html>