<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Scout Pro v2.4 - Scouting Only</title>

<!-- html5-qrcode library for barcode scanning -->
<!-- NOTE FOR APK: Download and inline this library locally or replace with native scanner -->
<!-- For now using CDN: https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js -->
<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

<!-- Tesseract.js for OCR ISBN text recognition -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<style>
/* --- THEME & RESET --- */
:root {
  --bg: #1a1a1a;
  --panel: #2d2d2d;
  --card: #1e1e1e;
  --border: #3d3d3d;
  --text: #ffffff;
  --muted: #888;
  --green: #4CAF50;
  --red: #f44336;
  --orange: #ff9800;
  --blue: #2196F3;
  --purple: #9333ea;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  padding: 16px 16px 96px 16px;
  max-width: 480px;
  margin: 0 auto;
  min-height: 100vh;
}

.hidden {
  display: none !important;
}

/* --- HEADER --- */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.header-left {
  flex: 1;
}

.app-title {
  font-size: 28px;
  font-weight: 800;
  background: linear-gradient(135deg, var(--green), var(--blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 4px;
}

.app-subtitle {
  font-size: 12px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.header-buttons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.header-btn {
  width: 36px;
  height: 36px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s;
  padding: 0;
}

.header-btn:active {
  transform: scale(0.9);
  background: rgba(255,255,255,0.1);
}

.settings-icon {
  width: 44px;
  height: 44px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.2s;
}

.settings-icon:hover {
  background: var(--border);
}

.settings-icon:active {
  transform: scale(0.95);
}

/* --- INPUT SECTION --- */
.input-section {
  background: var(--panel);
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  border: 2px solid var(--border);
}

.media-tabs {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}

.media-tab {
  padding: 10px;
  background: #1a1a1a;
  border: 2px solid var(--border);
  border-radius: 10px;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.2s;
}

.media-tab.active {
  background: var(--green);
  border-color: var(--green);
  color: #fff;
}

.media-icon {
  font-size: 20px;
  display: block;
  margin-bottom: 4px;
}

.input-row {
  display: flex;
  gap: 8px;
  align-items: center;
}

input[type="text"] {
  flex: 1;
  min-width: 0;
  padding: 16px;
  background: #1a1a1a;
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--text);
  font-size: 16px;
}

input[type="text"]:focus {
  outline: none;
  border-color: var(--green);
}

.camera-btn {
  flex-shrink: 0;
  width: 52px;
  height: 52px;
  background: linear-gradient(135deg, var(--blue), #1976D2);
  border: none;
  border-radius: 12px;
  color: #fff;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
}

.camera-btn:active {
  transform: scale(0.95);
}

.camera-btn.active {
  background: linear-gradient(135deg, var(--green), #2e7d32);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

/* --- TITLE PICKER --- */
.title-picker-card {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 16px;
  padding: 24px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

.title-picker-label {
  font-size: 11px;
  font-weight: 800;
  letter-spacing: 0.12em;
  color: var(--muted);
  text-transform: uppercase;
  margin-bottom: 8px;
}

.title-picker-title {
  font-size: 18px;
  font-weight: 800;
  margin-bottom: 8px;
}

.title-picker-hint {
  font-size: 12px;
  color: var(--muted);
  line-height: 1.5;
  margin-bottom: 16px;
}

.title-picker-list {
  margin-bottom: 16px;
}

.title-picker-item {
  background: var(--bg);
  border: 2px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.title-picker-item:hover {
  border-color: var(--blue);
  background: rgba(56,189,248,0.05);
}

.title-picker-item:active {
  transform: scale(0.98);
}

.title-picker-item-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.title-picker-item-meta {
  font-size: 11px;
  color: var(--muted);
}

.title-picker-footer {
  display: flex;
  justify-content: center;
  margin-top: 16px;
}

.title-picker-close {
  padding: 10px 24px;
  background: var(--panel);
  border: 2px solid var(--border);
  color: var(--text);
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.title-picker-close:hover {
  border-color: var(--red);
  color: var(--red);
}

.title-picker-close:active {
  transform: scale(0.95);
}

/* --- SCANNER MODAL --- */
.scanner-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.95);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.scanner-container {
  width: 90%;
  max-width: 500px;
}

.scanner-guidance {
  background: rgba(76, 175, 80, 0.2);
  border: 2px solid var(--green);
  border-radius: 12px;
  padding: 12px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  color: var(--green);
  margin-bottom: 16px;
}

#scanner-region {
  border-radius: 12px;
  overflow: hidden;
}

.scanner-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 20px;
}

.scanner-btn {
  flex: 1;
  min-width: 140px;
  padding: 12px;
  background: var(--blue);
  border: none;
  border-radius: 12px;
  color: #fff;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  white-space: nowrap;
}

.scanner-btn:disabled {
  opacity: 0.6;
  cursor: wait;
}

.scanner-close {
  flex: 1;
  min-width: 140px;
  padding: 12px;
  background: var(--red);
  border: none;
  border-radius: 12px;
  color: #fff;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
}

/* --- BOTTOM NAVIGATION --- */

/* --- SCANNER MODAL --- */
.scanner-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.95);
  z-index: 1000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.scanner-container {
  width: 100%;
  max-width: 500px;
  padding: 20px;
}

#scanner-region {
  border-radius: 12px;
  overflow: hidden;
  border: 2px solid var(--green);
}

.scanner-close {
  margin-top: 20px;
  padding: 16px 32px;
  background: var(--red);
  border: none;
  border-radius: 12px;
  color: white;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
}

/* --- VERDICT CARD --- */
.verdict-container {
  margin-bottom: 24px;
}

.verdict-card {
  background: linear-gradient(135deg, #2e7d32 0%, var(--green) 100%);
  border-radius: 20px;
  padding: 32px 24px;
  text-align: center;
  box-shadow: 0 12px 40px rgba(76, 175, 80, 0.4);
  position: relative;
  overflow: hidden;
}

.verdict-card.risk {
  background: linear-gradient(135deg, #f57c00 0%, var(--orange) 100%);
  box-shadow: 0 12px 40px rgba(255, 152, 0, 0.4);
}

.verdict-card.reject {
  background: linear-gradient(135deg, #c62828 0%, var(--red) 100%);
  box-shadow: 0 12px 40px rgba(244, 67, 54, 0.4);
}

.gemini-badge {
  display: inline-block;
  padding: 6px 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 20px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
  font-weight: 700;
}

.verdict-text {
  font-size: 56px;
  font-weight: 900;
  margin-bottom: 16px;
  text-shadow: 0 4px 12px rgba(0,0,0,0.3);
  letter-spacing: 2px;
}

/* --- VERDICT BANNER (Top of screen) --- */
.verdict-banner {
  background: linear-gradient(135deg, var(--green), #45a049);
  padding: 14px 20px;
  border-radius: 12px;
  margin-bottom: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.verdict-banner.consider {
  background: linear-gradient(135deg, #f57c00, var(--orange));
  box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
}

.verdict-banner.reject {
  background: linear-gradient(135deg, #c62828, var(--red));
  box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
}

.verdict-banner.risk {
  background: linear-gradient(135deg, #f57c00, var(--orange));
  box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
}

.verdict-banner-left {
  flex: 1;
}

.verdict-banner-label {
  font-size: 10px;
  color: rgba(255,255,255,0.8);
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 2px;
}

.verdict-banner-text {
  font-size: 20px;
  font-weight: 800;
  color: #fff;
}

.verdict-banner-icon {
  font-size: 32px;
}

/* --- FBM PRICE ANALYSIS BOX --- */
.fbm-price-box {
  background: rgba(33,150,243,0.1);
  border: 2px solid rgba(33,150,243,0.3);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
}

.fbm-price-title {
  font-size: 11px;
  color: #2196F3;
  font-weight: 700;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 12px;
}

.fbm-price-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  font-size: 13px;
}

.fbm-price-label {
  color: #888;
  font-size: 11px;
  font-weight: 600;
}

.fbm-price-value {
  color: #fff;
  font-weight: 600;
}

.fbm-days-note {
  font-size: 10px;
  color: #666;
  margin-top: 8px;
  font-style: italic;
}

.product-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  opacity: 0.95;
  line-height: 1.3;
}

.product-meta {
  font-size: 14px;
  opacity: 0.85;
}

/* --- METRICS --- */
.metrics-section {
  background: var(--panel);
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 20px;
  border: 2px solid var(--border);
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
}

.metric-box {
  text-align: center;
}

.metric-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

.metric-value {
  font-size: 28px;
  font-weight: 800;
  color: var(--green);
}

.metric-value.orange {
  color: var(--orange);
}

.metric-value.gray {
  color: #666;
}

.metric-note {
  font-size: 11px;
  color: #666;
  margin-top: 4px;
}

/* --- WHY SECTION --- */
.why-section {
  background: var(--panel);
  border-radius: 16px;
  overflow: hidden;
  margin-top: 20px;
  margin-bottom: 24px;
  border: 2px solid var(--border);
}

.why-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 18px 20px;
  cursor: pointer;
  user-select: none;
}

.why-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--green);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.why-toggle {
  font-size: 18px;
  color: #666;
  transition: transform 0.3s;
}

.why-toggle.open {
  transform: rotate(180deg);
}

.why-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.why-content.open {
  max-height: 800px;
}

.why-inner {
  padding: 16px 20px 20px;
  background: #1a1a1a;
}

.why-bullet {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  font-size: 14px;
  line-height: 1.6;
  align-items: flex-start;
}

.why-bullet:last-child {
  margin-bottom: 0;
}

/* --- ADD TO LIST BUTTON --- */
.bullet-icon {
  font-size: 18px;
  flex-shrink: 0;
  margin-top: 1px;
  min-width: 20px;
  text-align: center;
}

.bullet-icon.good {
  color: var(--green);
}

.bullet-icon.warn {
  color: var(--orange);
}

.bullet-icon.bad {
  color: var(--red);
}

.bullet-text {
  flex: 1;
}

/* --- ACTION BUTTONS --- */
.action-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-bottom: 24px;
}

.action-btn {
  padding: 16px;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  background: var(--panel);
  color: var(--text);
  border: 2px solid var(--border);
}

.action-btn:active {
  transform: scale(0.97);
}

/* --- LOADING STATE --- */
.loading-state {
  text-align: center;
  padding: 60px 20px;
}

/* --- CONDITION TOGGLE --- */
.condition-toggle {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  background: var(--panel);
  padding: 8px;
  border-radius: 12px;
  border: 2px solid var(--border);
}

.condition-btn {
  flex: 1;
  padding: 12px;
  background: transparent;
  border: 2px solid var(--border);
  border-radius: 8px;
  color: var(--muted);
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
}

.condition-btn:hover {
  background: rgba(255,255,255,0.05);
}

.condition-btn.active {
  background: var(--green);
  border-color: var(--green);
  color: #fff;
}

.condition-btn:active {
  transform: scale(0.97);
}

/* --- LOADING STATE --- */
.loading-state {
  text-align: center;
  padding: 60px 20px;
}

.spinner {
  width: 80px;
  height: 80px;
  border: 6px solid var(--panel);
  border-top: 6px solid var(--green);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 24px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--green);
}

.loading-subtitle {
  font-size: 14px;
  color: var(--muted);
  line-height: 1.5;
}

/* --- SETTINGS MODAL --- */
.settings-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.9);
  z-index: 999;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.settings-panel {
  background: var(--panel);
  border-radius: 20px;
  padding: 24px;
  max-width: 440px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
  border: 2px solid var(--border);
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.settings-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--green);
}

.settings-close {
  width: 36px;
  height: 36px;
  background: var(--red);
  border: none;
  border-radius: 8px;
  color: white;
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.setting-item {
  margin-bottom: 20px;
}

.setting-item:last-child {
  margin-bottom: 0;
}

.setting-label {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
  display: block;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.settings-input, .settings-select {
  width: 100%;
  padding: 12px;
  background: #1a1a1a;
  border: 2px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 14px;
}

.settings-input:focus, .settings-select:focus {
  outline: none;
  border-color: var(--green);
}

.settings-select {
  cursor: pointer;
}

/* Toggle Switch */
.toggle {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #444;
  transition: 0.3s;
  border-radius: 24px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
}

.toggle input:checked + .toggle-slider {
  background-color: var(--green);
}

.toggle input:checked + .toggle-slider:before {
  transform: translateX(26px);
}
</style>
</head>
<body>
  <!-- Header with Settings Gear -->
  <div class="header">
    <div class="header-left">
      <div class="app-title">Scout Pro v2</div>
      <div class="app-subtitle">v3.4 - Camera Diagnostics</div>
    </div>
    <div class="header-buttons">
      <button class="header-btn" id="cameraBtn" title="Scan with Camera">üì∑</button>
      <button class="header-btn" id="testCameraBtn" title="Test Camera Access">üîß</button>
      <button class="header-btn" id="settingsNavBtn" title="Settings">‚öôÔ∏è</button>
    </div>
  </div>
  
  <!-- Input Section -->
  <div class="input-section">
    <div class="media-tabs">
      <div class="media-tab active" data-type="book">
        <span class="media-icon">üìö</span>
        BOOK
      </div>
      <div class="media-tab" data-type="cd">
        <span class="media-icon">üíø</span>
        CD
      </div>
      <div class="media-tab" data-type="dvd">
        <span class="media-icon">üìÄ</span>
        DVD
      </div>
      <div class="media-tab" data-type="game">
        <span class="media-icon">üéÆ</span>
        GAME
      </div>
    </div>
    
    <div class="input-row">
      <input type="text" id="searchInput" placeholder="Scan, type ISBN or title...">
      <button class="camera-btn" id="lockBtn" title="Focus Lock - Keep input focused">üîí</button>
    </div>
  </div>
  
  <!-- Results Container -->
  <div id="resultsContainer" class="hidden" style="padding-bottom: 20px;">
    <!-- Condition Toggle -->
    <div class="condition-toggle">
      <button class="condition-btn active" id="conditionUsed">USED</button>
      <button class="condition-btn" id="conditionNew">NEW</button>
    </div>
    
    <!-- Verdict Banner (above keyboard visibility) -->
    <div class="verdict-banner" id="verdictBanner">
      <div class="verdict-banner-left">
        <div class="verdict-banner-label">GEMINI VERDICT</div>
        <div class="verdict-banner-text" id="verdictBannerText">BUY @ $12.50</div>
      </div>
      <div class="verdict-banner-icon" id="verdictBannerIcon">‚úì</div>
    </div>
    
    <!-- FBM Price Analysis Box -->
    <div class="fbm-price-box" id="fbmPriceBox">
      <div class="fbm-price-title" id="fbmPriceTitle">üìä POST-NOV 3 ANALYSIS (58 DAYS)</div>
      <div class="fbm-price-row">
        <span class="fbm-price-label">LOWEST FBA</span>
        <span class="fbm-price-value" id="fbmLowestFba">$12.50</span>
      </div>
      <div class="fbm-price-row">
        <span class="fbm-price-label">LOWEST FBM</span>
        <span class="fbm-price-value" id="fbmLowestFbm">$8.99 + ship ‚âà $12.98</span>
      </div>
      <div class="fbm-price-row">
        <span class="fbm-price-label">CURRENT BUYBOX</span>
        <span class="fbm-price-value" id="fbmCurrentBb">$12.50</span>
      </div>
      <div class="fbm-price-row">
        <span class="fbm-price-label">FBA BB WIN RATE</span>
        <span class="fbm-price-value" id="fbmBbWinRate">73% ‚≠ê‚≠ê</span>
      </div>
      <div class="fbm-price-row">
        <span class="fbm-price-label">SALES ACTIVITY</span>
        <span class="fbm-price-value" id="fbmSalesActivity">12 drops (9 FBA BB, 3 FBM BB)</span>
      </div>
      <div class="fbm-days-note">Data analyzed from Nov 3, 2025 forward ‚Ä¢ FBA/FBM compete equally for Buybox</div>
    </div>
    
    <!-- Verdict Card -->
    <div class="verdict-container">
      <div class="verdict-card" id="verdictCard">
        <div class="gemini-badge">‚ú® Gemini Verdict</div>
        <div class="verdict-text" id="verdictText">BUY</div>
        <div class="product-title" id="productTitle">Product Title</div>
        <div class="product-meta" id="productMeta">Condition ‚Ä¢ Type</div>
      </div>
    </div>
    
    <!-- Metrics (only for BUY/RISK) -->
    <div class="metrics-section" id="metricsSection">
      <div class="metrics-grid">
        <div class="metric-box">
          <div class="metric-label">Profit</div>
          <div class="metric-value" id="profitValue">$0.00</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Sell For</div>
          <div class="metric-value" id="sellForValue">$0.00</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Time</div>
          <div class="metric-value orange" id="timeValue">--</div>
          <div class="metric-note" id="timeNote"></div>
        </div>
      </div>
    </div>
    
    <!-- Why Section -->
    <div class="why-section">
      <div class="why-header" onclick="toggleWhy()">
        <div class="why-title" id="whyTitle">Why?</div>
        <div class="why-toggle" id="whyToggle">‚ñº</div>
      </div>
      <div class="why-content" id="whyContent">
        <div class="why-inner" id="whyInner">
          <!-- Bullets will be populated by JS -->
        </div>
      </div>
    </div>
    
  </div>
  
  <!-- Title Picker Modal -->
  <div class="title-picker-card hidden" id="titlePickerCard">
    <div class="title-picker-content">
      <div class="title-picker-header">
        <div class="title-picker-label">TITLE RESULTS</div>
        <div class="title-picker-title">Pick an edition</div>
        <div class="title-picker-hint" id="titlePickerHint">
          Click an item to select it
        </div>
      </div>
      <div class="title-picker-list" id="titlePickerList"></div>
      <div class="title-picker-footer">
        <button class="title-picker-close" id="closeTitlePickerBtn">Close ‚úñ</button>
      </div>
    </div>
  </div>
  
  <!-- Loading State -->
  <div id="loadingState" class="loading-state hidden">
    <div class="spinner"></div>
    <div class="loading-title">Gemini is analyzing...</div>
    <div class="loading-subtitle">Reviewing FBA competition, profit margins,<br>and sales velocity</div>
  </div>
  
  <!-- Scanner Modal -->
  <div id="scannerModal" class="scanner-modal hidden">
    <div class="scanner-container">
      <div class="scanner-guidance" style="font-size: 15px; padding: 14px;">
        <div style="font-weight: 800; margin-bottom: 4px;">üìñ BLURRY? TAP FOCUS BUTTON</div>
        <div style="font-size: 13px; opacity: 0.9;">Position barcode in box, use buttons below to fix blur</div>
      </div>
      <div id="scanner-region"></div>
      <div class="scanner-controls">
        <button class="scanner-btn" id="focusBtn" style="background: var(--orange);">üîç Focus</button>
        <button class="scanner-btn" id="ocrScanBtn" style="background: var(--purple);">üìù Text ISBN</button>
        <button class="scanner-btn" id="torchBtn" style="display:none;">üî¶ Light</button>
        <button class="scanner-close" id="closeScannerBtn">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Settings Modal -->
  <div id="settingsModal" class="settings-modal hidden">
    <div class="settings-panel">
      <div class="settings-header">
        <div class="settings-title">‚öôÔ∏è Settings</div>
        <button class="settings-close" id="closeSettingsBtn">‚úï</button>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">Keepa API Key</label>
        <input type="password" id="keepaKey" class="settings-input" placeholder="Paste Keepa API key...">
      </div>
      
      <div class="setting-item">
        <label class="setting-label">Gemini API Key</label>
        <input type="password" id="geminiKey" class="settings-input" placeholder="Paste Gemini API key...">
      </div>
      
      <div class="setting-item">
        <label class="setting-label">Your Cost per Item ($)</label>
        <input type="number" id="buyCost" class="settings-input" value="1.00" step="0.01">
      </div>
      
      <div class="setting-item">
        <label class="setting-label">Minimum Profit Floor ($)</label>
        <input type="number" id="profitFloor" class="settings-input" value="5.00" step="0.50">
      </div>
      
      <div class="setting-item">
        <label class="setting-label">Condition</label>
        <select id="condition" class="settings-select">
          <option value="NEW">New</option>
          <option value="LIKE_NEW">Like New</option>
          <option value="VERY_GOOD">Very Good</option>
          <option value="GOOD">Good</option>
          <option value="ACCEPTABLE">Acceptable</option>
        </select>
      </div>
      
      <div class="setting-item">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <label class="setting-label" style="margin: 0;">Use Proxy Server</label>
          <label class="toggle">
            <input type="checkbox" id="useProxy">
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
          Turn OFF if you have a CORS extension. Direct is faster.
        </div>
      </div>
    </div>
  </div>

<script>
// ===== DEBUG LOGGING (set to true temporarily if you need verbose logs) =====
const DEBUG = false;
const LOG = (...args) => { if (DEBUG) console.log(...args); };
// ===========================================================================

// Configuration
const CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || '',
  geminiKey: localStorage.getItem('geminiKey') || '',
  buyCost: parseFloat(localStorage.getItem('buyCost')) || 1.00,
  profitFloor: parseFloat(localStorage.getItem('profitFloor')) || 5.00,
  condition: localStorage.getItem('condition') || 'USED',
  mediaType: 'book',
  useProxy: localStorage.getItem('useProxy') !== 'false' // Default true
};

// Focus lock for continuous scanning
let focusLock = true;

// DOM Elements - will be initialized in init()
let searchInput, lockBtn, cameraBtn, resultsContainer, loadingState;
let verdictCard, verdictText, productTitle, productMeta, metricsSection;
let profitValue, sellForValue, timeValue, timeNote, whyInner, whyTitle;
let settingsNavBtn, settingsModal, closeSettingsBtn, keepaKeyInput, geminiKeyInput;
let buyCostInput, profitFloorInput, conditionInput, useProxyInput;
let scannerModal, closeScannerBtn;
let html5QrCode = null;

// Current scan data
let currentKeepaData = null;
let currentASIN = null;

// Toggle focus lock
function toggleFocusLock() {
  focusLock = !focusLock;
  lockBtn.classList.toggle('active', focusLock);
  if (focusLock) searchInput.focus();
}

// Re-run Gemini analysis with current condition setting
async function rerunAnalysis() {
  if (!currentKeepaData) return;
  
  LOG('Re-running analysis with condition:', CONFIG.condition);
  
  // Show loading
  loadingState.classList.remove('hidden');
  resultsContainer.classList.add('hidden');
  
  try {
    // Re-analyze with Gemini using new condition
    const geminiResult = await analyzeWithGemini(currentKeepaData);
    
    // Display updated results
    displayResults(currentKeepaData, geminiResult);
    
  } catch (error) {
    console.error('Error re-running analysis:', error);
    alert('Error: ' + error.message);
    loadingState.classList.add('hidden');
  }
}

// Initialize
function init() {
  LOG('üöÄ Initializing Scout Pro v2.4 - Scouting Only Edition...');
  
  // Get DOM elements (now that they exist)
  searchInput = document.getElementById('searchInput');
  lockBtn = document.getElementById('lockBtn');
  cameraBtn = document.getElementById('cameraBtn');
  resultsContainer = document.getElementById('resultsContainer');
  loadingState = document.getElementById('loadingState');
  verdictCard = document.getElementById('verdictCard');
  verdictText = document.getElementById('verdictText');
  productTitle = document.getElementById('productTitle');
  productMeta = document.getElementById('productMeta');
  metricsSection = document.getElementById('metricsSection');
  profitValue = document.getElementById('profitValue');
  sellForValue = document.getElementById('sellForValue');
  timeValue = document.getElementById('timeValue');
  timeNote = document.getElementById('timeNote');
  whyInner = document.getElementById('whyInner');
  whyTitle = document.getElementById('whyTitle');
  settingsNavBtn = document.getElementById('settingsNavBtn');
  settingsModal = document.getElementById('settingsModal');
  closeSettingsBtn = document.getElementById('closeSettingsBtn');
  keepaKeyInput = document.getElementById('keepaKey');
  geminiKeyInput = document.getElementById('geminiKey');
  buyCostInput = document.getElementById('buyCost');
  profitFloorInput = document.getElementById('profitFloor');
  conditionInput = document.getElementById('condition');
  useProxyInput = document.getElementById('useProxy');
  cameraBtn = document.getElementById('cameraBtn');
  scannerModal = document.getElementById('scannerModal');
  closeScannerBtn = document.getElementById('closeScannerBtn');
  
  LOG('Header buttons found:', {
    cameraBtn: cameraBtn,
    cameraBtnId: cameraBtn ? cameraBtn.id : 'NOT FOUND',
    settingsNavBtn: settingsNavBtn,
    settingsNavBtnId: settingsNavBtn ? settingsNavBtn.id : 'NOT FOUND'
  });
  
  // Verify elements are different
  if (cameraBtn === settingsNavBtn) {
    console.error('ERROR: cameraBtn and settingsNavBtn are the SAME element!');
  }
  
  // Load saved settings
  keepaKeyInput.value = CONFIG.keepaKey;
  geminiKeyInput.value = CONFIG.geminiKey;
  buyCostInput.value = CONFIG.buyCost;
  profitFloorInput.value = CONFIG.profitFloor;
  conditionInput.value = CONFIG.condition;
  useProxyInput.checked = CONFIG.useProxy;
  
  // Set lock button to active (green) since focusLock defaults to true
  lockBtn.classList.add('active');
  searchInput.focus();
  
  // Event listeners
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSearch();
  });
  
  lockBtn.addEventListener('click', toggleFocusLock);
  
  cameraBtn.addEventListener('click', (e) => {
    LOG('CAMERA BUTTON CLICKED');
    e.preventDefault();
    e.stopPropagation();
    openScanner();
  });
  
  // Test camera access button
  const testCameraBtn = document.getElementById('testCameraBtn');
  if (testCameraBtn) {
    testCameraBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      try {
        LOG('Testing camera access...');
        const stream = await ensureCameraAccess();
        
        LOG('‚úì Camera access granted!');
        LOG('Stream:', stream);
        LOG('Video tracks:', stream.getVideoTracks());
        
        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings();
        const capabilities = track.getCapabilities();
        
        LOG('Camera settings:', settings);
        LOG('Camera capabilities:', capabilities);
        
        // Stop the stream
        stream.getTracks().forEach(t => t.stop());
        
        alert('‚úì Camera access OK!\n\n' +
              'Camera: ' + (settings.deviceId || 'Unknown') + '\n' +
              'Resolution: ' + settings.width + 'x' + settings.height + '\n' +
              'Focus modes: ' + (capabilities.focusMode || ['none']).join(', ') + '\n\n' +
              'Scanner should work now!');
        
      } catch (err) {
        console.error('Camera test failed:', err);
        alert('‚úó Camera test FAILED\n\n' +
              'Error: ' + err.name + '\n' +
              'Message: ' + err.message + '\n\n' +
              'FIX:\n' +
              '1. Check Chrome permissions\n' +
              '2. Close other camera apps\n' +
              '3. Try restarting Chrome');
      }
    });
  }
  
  // Settings modal
  settingsNavBtn.addEventListener('click', (e) => {
    LOG('SETTINGS BUTTON CLICKED');
    e.preventDefault();
    e.stopPropagation();
    settingsModal.classList.remove('hidden');
  });
  
  closeSettingsBtn.addEventListener('click', () => {
    settingsModal.classList.add('hidden');
  });
  
  // Title picker close button
  const closeTitlePickerBtn = document.getElementById('closeTitlePickerBtn');
  closeTitlePickerBtn.addEventListener('click', closeTitlePicker);
  
  // Close settings when clicking outside
  settingsModal.addEventListener('click', (e) => {
    if (e.target === settingsModal) {
      settingsModal.classList.add('hidden');
    }
  });
  
  // Media type tabs
  document.querySelectorAll('.media-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.media-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      CONFIG.mediaType = tab.dataset.type;
    });
  });
  
  // Settings inputs - save on change
  keepaKeyInput.addEventListener('change', () => {
    CONFIG.keepaKey = keepaKeyInput.value;
    localStorage.setItem('keepaKey', CONFIG.keepaKey);
  });
  
  geminiKeyInput.addEventListener('change', () => {
    CONFIG.geminiKey = geminiKeyInput.value;
    localStorage.setItem('geminiKey', CONFIG.geminiKey);
  });
  
  buyCostInput.addEventListener('change', () => {
    CONFIG.buyCost = parseFloat(buyCostInput.value) || 1.00;
    localStorage.setItem('buyCost', CONFIG.buyCost);
  });
  
  profitFloorInput.addEventListener('change', () => {
    CONFIG.profitFloor = parseFloat(profitFloorInput.value) || 5.00;
    localStorage.setItem('profitFloor', CONFIG.profitFloor);
  });
  
  conditionInput.addEventListener('change', () => {
    CONFIG.condition = conditionInput.value;
    localStorage.setItem('condition', CONFIG.condition);
  });
  
  useProxyInput.addEventListener('change', () => {
    CONFIG.useProxy = useProxyInput.checked;
    localStorage.setItem('useProxy', CONFIG.useProxy);
  });
  
  // Scanner
  closeScannerBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent focus lock from interfering
    closeScanner();
  });
  
  // Focus lock - keep focus on search input for continuous scanning
  document.addEventListener('click', (e) => {
    // Don't refocus if clicking on scanner controls
    if (e.target.closest('.scanner-modal') || e.target.closest('.settings-modal')) {
      return;
    }
    if (focusLock && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON' && e.target.tagName !== 'SELECT') {
      searchInput.focus();
    }
  });
  
  // Focus input on load
  searchInput.focus();
}

// Toggle Why section
function toggleWhy() {
  const content = document.getElementById('whyContent');
  const toggle = document.getElementById('whyToggle');
  content.classList.toggle('open');
  toggle.classList.toggle('open');
}

// Update "Add to List" button based on condition
// Scanner functions
function isProbablySecureOrigin() {
  // getUserMedia requires a secure context (https or localhost). Some embedded webviews may also qualify.
  const isLocalhost = /^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname);
  return window.isSecureContext || location.protocol === 'https:' || isLocalhost;
}

async function ensureCameraAccess() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    throw new Error('Camera API not available in this browser. Try a modern Chrome/Edge/Safari.');
  }

  if (!isProbablySecureOrigin()) {
    // This is the #1 reason Chrome will not even prompt.
    throw new Error(
      'Camera requires HTTPS (secure origin).

' +
      'Open this app via https:// (or localhost).
' +
      'If you opened it as a file (file://) or over http://, Chrome will block camera without prompting.'
    );
  }

  // If Permissions API is available, surface the state.
  try {
    if (navigator.permissions && navigator.permissions.query) {
      const status = await navigator.permissions.query({ name: 'camera' });
      if (status && status.state === 'denied') {
        throw new Error(
          'Camera permission is currently BLOCKED for this site.

' +
          'Fix: Chrome address bar ‚Üí lock icon ‚Üí Site settings ‚Üí Camera ‚Üí Allow, then reload.'
        );
      }
    }
  } catch (e) {
    // Some browsers throw on permissions.query({name:'camera'}). Ignore and continue.
  }

  // Try requesting the environment camera first; fall back to any camera if constraints fail.
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' } },
      audio: false
    });
    return stream;
  } catch (err) {
    // OverconstrainedError means the device can't satisfy facingMode constraint
    if (err && (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError')) {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      return stream;
    }
    throw err;
  }
}

// Scanner functions
function openScanner() {
  scannerModal.classList.remove('hidden');

  if (typeof Html5Qrcode === 'undefined') {
    alert('Camera scanning library not loaded. Please enter ISBN manually.');
    closeScanner();
    return;
  }

  // MUST be called from a user gesture for reliable prompting on mobile.
  ensureCameraAccess()
    .then(stream => {
      LOG('‚úì Camera access granted');
      // Stop the test stream immediately (html5-qrcode will open its own stream).
      stream.getTracks().forEach(track => track.stop());
      startScanner();
    })
    .catch(err => {
      console.error('Camera permission/error:', err);

      // Normalize into a readable message.
      const name = err?.name || 'Error';
      const msg = err?.message || String(err);

      let help = '';
      if (name === 'NotAllowedError' || name === 'PermissionDeniedError') {
        help =
          '

Fix:' +
          '
1) Chrome address bar ‚Üí lock icon ‚Üí Site settings' +
          '
2) Camera ‚Üí Allow' +
          '
3) Reload the page';
      } else if (name === 'NotFoundError' || name === 'DevicesNotFoundError') {
        help = '

No camera found on this device.';
      } else if (name === 'NotReadableError' || name === 'TrackStartError') {
        help = '

Camera is busy (another app/tab is using it). Close other camera apps and try again.';
      } else if (name === 'SecurityError') {
        help = '

This is usually an insecure origin issue. Open via https:// (not file:// or http://).';
      }

      alert('‚úó Camera failed

' + name + ': ' + msg + help);
      closeScanner();
    });
}

function startScanner() {
  html5QrCode = new Html5Qrcode("scanner-region");
  
  // Proven Android barcode scanning config
  const config = { 
    fps: 10,
    qrbox: function(viewfinderWidth, viewfinderHeight) {
      // Wide rectangular box optimized for horizontal barcodes
      const boxWidth = Math.floor(viewfinderWidth * 0.85);
      const boxHeight = Math.floor(viewfinderWidth * 0.25); // Narrow height for barcodes
      return { width: boxWidth, height: boxHeight };
    },
    // Support all common barcode formats including Amazon labels
    formatsToSupport: [
      0,  // QR_CODE
      13, // EAN_13 (ISBN-13 barcodes)
      8,  // EAN_8 (short barcodes)
      3,  // CODE_128 (Amazon FNSKU/LPN labels - MOST IMPORTANT for Amazon)
      2,  // CODE_39 (alternative Amazon format)
      12, // UPC_A (10-digit ISBNs)
      14  // UPC_E (short UPC)
    ]
  };
  
  // Conservative camera config that works on all Android devices
  // Start with basic config - no advanced features that might fail
  html5QrCode.start(
    {
      facingMode: { ideal: "environment" }
    },
    config,
    (decodedText) => {
      LOG('Scanned:', decodedText);
      // Vibrate on successful scan (if supported)
      if (navigator.vibrate) {
        navigator.vibrate(100);
      }
      searchInput.value = decodedText;
      closeScanner();
      handleSearch();
    },
    (error) => {
      // Scanning errors are normal, ignore
    }
  ).then(() => {
    LOG('Camera started successfully');
    
    // Give camera 1 second to stabilize autofocus
    setTimeout(() => {
      // Try to force autofocus
      const scannerRegion = document.getElementById('scanner-region');
      const videoElement = scannerRegion?.querySelector('video');
      
      if (videoElement && videoElement.srcObject) {
        const stream = videoElement.srcObject;
        const videoTrack = stream.getVideoTracks()[0];
        
        // Try to apply autofocus constraints
        videoTrack.applyConstraints({
          advanced: [{ 
            focusMode: 'continuous',
            focusDistance: 0
          }]
        }).then(() => {
          LOG('Autofocus applied successfully');
        }).catch(err => {
          LOG('Autofocus not supported:', err);
          // Try single-shot as fallback
          videoTrack.applyConstraints({
            advanced: [{ focusMode: 'single-shot' }]
          }).catch(e => LOG('No focus control available'));
        });
      }
      
      // Setup other features
      setupFocusButton();
      setupTorch();
      setupOCRScan();
    }, 1000);
  }).catch(err => {
    console.error('Camera failed:', err);
    alert('Camera access denied. Please enable camera permissions in Android settings.');
    closeScanner();
  });
}

function setupFocusButton() {
  const focusBtn = document.getElementById('focusBtn');
  if (!focusBtn) return;
  
  let focusMode = 0; // 0=auto, 1=near, 2=mid, 3=far
  const focusModes = [
    { name: 'Auto', distance: null, mode: 'continuous' },
    { name: 'Near', distance: 0.1, mode: 'manual' },  // 10cm - perfect for barcodes!
    { name: 'Mid', distance: 0.5, mode: 'manual' },   // 50cm
    { name: 'Far', distance: 2.0, mode: 'manual' }    // 2m
  ];
  
  focusBtn.addEventListener('click', async () => {
    const scannerRegion = document.getElementById('scanner-region');
    const videoElement = scannerRegion?.querySelector('video');
    
    if (!videoElement || !videoElement.srcObject) {
      alert('Camera not active');
      return;
    }
    
    try {
      const stream = videoElement.srcObject;
      const videoTrack = stream.getVideoTracks()[0];
      const capabilities = videoTrack.getCapabilities();
      
      LOG('Camera capabilities:', capabilities);
      
      // Cycle to next focus mode
      focusMode = (focusMode + 1) % focusModes.length;
      const currentMode = focusModes[focusMode];
      
      focusBtn.textContent = `üîç ${currentMode.name}...`;
      focusBtn.disabled = true;
      
      // Build constraints
      const constraints = { advanced: [] };
      
      if (currentMode.mode === 'manual' && capabilities.focusMode && capabilities.focusMode.includes('manual')) {
        constraints.advanced.push({ focusMode: 'manual' });
        
        if (currentMode.distance !== null && capabilities.focusDistance) {
          constraints.advanced.push({ focusDistance: currentMode.distance });
        }
      } else {
        // Use continuous autofocus
        if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
          constraints.advanced.push({ focusMode: 'continuous' });
        } else if (capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
          constraints.advanced.push({ focusMode: 'single-shot' });
        }
      }
      
      await videoTrack.applyConstraints(constraints);
      
      // Wait for focus to settle
      await new Promise(resolve => setTimeout(resolve, 500));
      
      focusBtn.textContent = `üîç ${currentMode.name}`;
      focusBtn.disabled = false;
      
      LOG(`Focus set to: ${currentMode.name}`, constraints);
      
    } catch (err) {
      console.error('Focus error:', err);
      focusBtn.textContent = 'üîç Focus';
      focusBtn.disabled = false;
      focusMode = 0;
    }
  });
}

async function setupOCRScan() {
  const ocrBtn = document.getElementById('ocrScanBtn');
  if (!ocrBtn) return;
  
  ocrBtn.addEventListener('click', async () => {
    try {
      ocrBtn.disabled = true;
      ocrBtn.textContent = 'üìù Scanning...';
      
      // Capture current frame from video
      const scannerRegion = document.getElementById('scanner-region');
      const videoElement = scannerRegion.querySelector('video');
      
      if (!videoElement) {
        throw new Error('Camera not active');
      }
      
      // Create canvas to capture frame
      const canvas = document.createElement('canvas');
      canvas.width = videoElement.videoWidth;
      canvas.height = videoElement.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(videoElement, 0, 0);
      
      // Convert to blob for Tesseract
      const imageData = canvas.toDataURL('image/png');
      
      // Run OCR
      LOG('Running OCR on image...');
      const result = await Tesseract.recognize(imageData, 'eng', {
        logger: m => LOG('OCR progress:', m)
      });
      
      LOG('OCR result:', result.data.text);
      
      // Extract ISBN from text using regex
      const isbn = extractISBN(result.data.text);
      
      if (isbn) {
        LOG('Found ISBN:', isbn);
        if (navigator.vibrate) navigator.vibrate(100);
        searchInput.value = isbn;
        closeScanner();
        handleSearch();
      } else {
        alert('No ISBN found. Try positioning the book better and ensure good lighting.');
        ocrBtn.disabled = false;
        ocrBtn.textContent = 'üìù Scan Text ISBN';
      }
      
    } catch (err) {
      console.error('OCR error:', err);
      alert('OCR scan failed: ' + err.message);
      ocrBtn.disabled = false;
      ocrBtn.textContent = 'üìù Scan Text ISBN';
    }
  });
}

function extractISBN(text) {
  // Remove all whitespace and dashes for easier matching
  const cleanText = text.replace(/[\s\-]/g, '');
  
  // Match ISBN-13 (978 or 979 prefix)
  const isbn13Match = cleanText.match(/(?:ISBN)?(?:97[89])(\d{10})/i);
  if (isbn13Match) {
    return isbn13Match[0].replace(/ISBN/i, '');
  }
  
  // Match ISBN-10 (10 digits, possibly with X at end)
  const isbn10Match = cleanText.match(/(?:ISBN)?(\d{9}[\dX])/i);
  if (isbn10Match) {
    return isbn10Match[0].replace(/ISBN/i, '');
  }
  
  // Try with original text (with spaces/dashes)
  const isbn13Spaced = text.match(/ISBN[:\s]*(?:97[89])[\s\-]?(\d[\s\-]?){10}/i);
  if (isbn13Spaced) {
    return isbn13Spaced[0].replace(/[^\d]/g, '');
  }
  
  return null;
}

function setupTorch() {
  // Check if torch is available
  const torchBtn = document.getElementById('torchBtn');
  
  if (html5QrCode && html5QrCode.getRunningTrackCapabilities) {
    const capabilities = html5QrCode.getRunningTrackCapabilities();
    if (capabilities.torch) {
      torchBtn.style.display = 'block';
      let torchOn = false;
      
      torchBtn.onclick = async () => {
        try {
          await html5QrCode.applyVideoConstraints({ advanced: [{ torch: !torchOn }] });
          torchOn = !torchOn;
          torchBtn.textContent = torchOn ? 'üî¶ Flashlight ON' : 'üî¶ Flashlight';
          torchBtn.style.background = torchOn ? 'var(--green)' : 'var(--blue)';
        } catch (err) {
          console.error('Torch toggle failed:', err);
        }
      };
    }
  }
}

function closeScanner() {
  if (html5QrCode) {
    html5QrCode.stop().then(() => {
      html5QrCode.clear();
      html5QrCode = null;
      scannerModal.classList.add('hidden');
    }).catch(err => {
      console.error('Error stopping scanner:', err);
      scannerModal.classList.add('hidden');
    });
  } else {
    scannerModal.classList.add('hidden');
  }
}

// Handle search
async function handleSearch() {
  const query = searchInput.value.trim();
  if (!query) return;
  
  if (!CONFIG.keepaKey) {
    alert('Please enter your Keepa API key in Settings (‚öôÔ∏è)');
    settingsModal.classList.remove('hidden');
    return;
  }
  
  if (!CONFIG.geminiKey) {
    alert('Please enter your Gemini API key in Settings (‚öôÔ∏è)');
    settingsModal.classList.remove('hidden');
    return;
  }
  
  // Reset to USED condition for each new scan
  CONFIG.condition = 'USED';
  localStorage.setItem('condition', 'USED');
  
  // Clear input immediately for next scan
  searchInput.value = '';
  
  // Show loading
  resultsContainer.classList.add('hidden');
  loadingState.classList.remove('hidden');
  
  try {
    // Fetch Keepa data
    const keepaData = await fetchKeepaData(query);
    
    // If null, title picker is being shown (for title searches)
    if (!keepaData) {
      return;
    }
    
    currentKeepaData = keepaData;
    currentASIN = keepaData.asin;
    
    LOG('Keepa data:', keepaData);
    
    // KEEPA HISTORY ANALYSIS: If Keepa shows 0 FBA offers currently, check recent history
    if (keepaData.fbaCount === 0 || keepaData.fbaPrice === 0) {
      LOG('‚ö†Ô∏è Keepa shows 0 current FBA offers - analyzing recent history...');
      const recentActivity = await analyzeRecentFbaActivity(keepaData);
      
      // Add recent FBA data to keepaData
      keepaData.hadRecentFba = recentActivity.hadRecentFba;
      keepaData.recentFbaCount = recentActivity.recentFbaCount;
      keepaData.recentFbaPrices = recentActivity.recentFbaPrices;
      keepaData.recentLowestFba = recentActivity.recentLowestFba;
      keepaData.recentHighestFba = recentActivity.recentHighestFba;
      keepaData.lastSeenDaysAgo = recentActivity.lastSeenDaysAgo;
      keepaData.historicallyVerified = true;
      
      if (recentActivity.hadRecentFba) {
        LOG(`‚úì Found ${recentActivity.recentFbaCount} FBA offers in last 30 days (last seen ${recentActivity.lastSeenDaysAgo} days ago)`);
      } else {
        LOG('‚úì Confirmed: No FBA activity in last 30 days');
      }
    }
    
    // Analyze with Gemini
    const geminiResult = await analyzeWithGemini(keepaData);
    
    LOG('Gemini result:', geminiResult);
    
    // Display results
    displayResults(keepaData, geminiResult);
    
  } catch (error) {
    console.error('Error:', error);
    alert('Error: ' + error.message);
    loadingState.classList.add('hidden');
  }
}

// Fetch Keepa data (from v1)
async function fetchKeepaData(query) {
  if (!CONFIG.keepaKey) throw new Error("No API Key");
  
  const clean = query.replace(/-/g, '');
  const days = 365; // Request 365 days to ensure we get drops360
  
  // Determine query type
  const isUPC = /^\d{12}$/.test(clean);
  const isEAN13 = /^\d{13}$/.test(clean);
  const isGTIN14 = /^\d{14}$/.test(clean);
  const isISBN13 = /^97[89]\d{10}$/.test(clean);
  const is10DigitNumeric = /^\d{10}$/.test(clean);
  const isISBN10WithX = /^\d{9}X$/i.test(clean);
  
  const isISBN = isISBN13 || isISBN10WithX;
  const isProductCode = isUPC || isEAN13 || isGTIN14;
  const isASIN = /^B0[A-Z0-9]{8}$/.test(clean);
  
  // If it's a barcode, ISBN, or ASIN, use product endpoint
  if (isISBN || isProductCode || isASIN || is10DigitNumeric) {
    const paramName = (isISBN || isProductCode) ? 'code' : 'asin';
    let url = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=1&${paramName}=${clean}&stats=${days}&history=1`;
    
    LOG('Fetching Keepa (product):', { query, clean, paramName });
    
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
      const json = await res.json();
      return parseKeepaJson(json);
    } catch (e) {
      throw new Error(`Failed to fetch from Keepa: ${e.message}`);
    }
  } else {
    // It's a title search - use search endpoint (v1 exact implementation)
    const cleanTitle = query.trim();
    const encodedTitle = encodeURIComponent(cleanTitle).replace(/%20/g, '+');
    const baseUrl = `https://api.keepa.com/search?key=${CONFIG.keepaKey}&domain=1&type=product&term=${encodedTitle}`;
    
    LOG('=== TITLE SEARCH ===');
    LOG('Original:', query);
    LOG('Encoded:', encodedTitle);
    
    let data = null;
    
    // Try proxy first if enabled
    if (CONFIG.useProxy) {
      try {
        LOG('Trying with corsproxy.io...');
        const proxyEncodedTitle = encodeURIComponent(cleanTitle); // Use %20 for proxy
        const proxyBaseUrl = `https://api.keepa.com/search?key=${CONFIG.keepaKey}&domain=1&type=product&term=${proxyEncodedTitle}`;
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(proxyBaseUrl)}`;
        const res = await fetch(proxyUrl);
        if (res.ok) {
          data = await res.json();
          if (!data.error && data.products && data.products.length > 0) {
            LOG('Proxy success, got', data.products.length, 'results');
          } else {
            data = null;
          }
        }
      } catch (proxyErr) {
        LOG('Proxy failed:', proxyErr.message);
      }
    }
    
    // Try direct if proxy failed or disabled
    if (!data) {
      LOG('Trying direct fetch...');
      const res = await fetch(baseUrl);
      if (!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
      data = await res.json();
      if (data.error) throw new Error(data.error.message);
      LOG('Direct fetch success, got', data.products?.length || 0, 'results');
    }
    
    if (!data.products || data.products.length === 0) {
      throw new Error(`No products found for: "${query}"`);
    }
    
    LOG(`Found ${data.products.length} results, showing picker`);
    
    // Show title picker with all results
    renderTitlePicker(data.products);
    return null; // Return null to signal we're showing picker, not proceeding
  }
}

// Parse Keepa JSON
function parseKeepaJson(json) {
  if (json.error) throw new Error(json.error.message);
  if (!json.products || !json.products.length) {
    throw new Error("Product Not Found");
  }
  
  const p = json.products[0];
  return parseProduct(p);
}

// Calculate price range from Keepa history (from v1)
function calculatePriceRange(priceHistory, daysBack = 90) {
  if (!priceHistory || priceHistory.length < 2) {
    return { min: 0, max: 0, spread: 0, hasData: false };
  }
  
  const now = Date.now();
  const cutoffTime = now - (daysBack * 24 * 60 * 60 * 1000);
  const keepaEpoch = new Date('2011-01-01').getTime();
  
  let minPrice = Infinity;
  let maxPrice = -Infinity;
  let validPrices = 0;
  
  for (let i = 0; i < priceHistory.length; i += 2) {
    const keepaTime = priceHistory[i];
    const priceValue = priceHistory[i + 1];
    const timestamp = keepaEpoch + (keepaTime * 60 * 1000);
    
    if (timestamp >= cutoffTime && priceValue > 0) {
      const price = priceValue / 100;
      minPrice = Math.min(minPrice, price);
      maxPrice = Math.max(maxPrice, price);
      validPrices++;
    }
  }
  
  if (validPrices === 0 || minPrice === Infinity) {
    return { min: 0, max: 0, spread: 0, hasData: false };
  }
  
  return {
    min: minPrice,
    max: maxPrice,
    spread: maxPrice - minPrice,
    hasData: true
  };
}

// Parse product (complete v1 version)
function parseProduct(p) {
  LOG('=== KEEPA RAW DATA ===');
  LOG('Full product object:', p);
  LOG('p.packageWeight (RAW from Keepa):', p.packageWeight);
  LOG('p.packageWeight / 100 =', p.packageWeight ? p.packageWeight / 100 : 'undefined');
  LOG('p.packageWeight / 16 =', p.packageWeight ? p.packageWeight / 16 : 'undefined');
  LOG('p.packageWeight / 453.592 =', p.packageWeight ? p.packageWeight / 453.592 : 'undefined');
  LOG('p.stats:', p.stats);
  LOG('p.stats.salesRankDrops30:', p.stats.salesRankDrops30);
  LOG('p.stats.salesRankDrops90:', p.stats.salesRankDrops90);
  LOG('p.stats.salesRankDrops180:', p.stats.salesRankDrops180);
  LOG('p.stats.salesRankDrops360:', p.stats.salesRankDrops360);
  
  const s = p.stats.current;
  const avg = p.stats.avg90 || [];
  const avg180 = p.stats.avg180 || [];
  const avg365 = p.stats.avg365 || [];
  const toPrice = (v) => (v && v > 0) ? v / 100 : 0;
  const toVal = (v) => (v == -1 || v == null) ? 0 : v;
  
  const fbaPrice = toPrice(s[10]);
  const usedPrice = toPrice(s[2]);
  const newPrice = toPrice(s[1]);
  const amzPrice = toPrice(s[0]);
  const fbaCount = toVal(s[16]) || 0;
  const keepaBb = toPrice(s[18]);
  
  LOG('=== FBA PRICE DEBUG ===');
  LOG('s[10] (raw FBA price):', s[10]);
  LOG('fbaPrice (converted):', fbaPrice);
  LOG('s[16] (FBA offer count):', s[16]);
  LOG('fbaCount:', fbaCount);
  
  // Buy Box inference
  let inferredBbPrice = 0;
  let bbOwnerType = 'SUPPRESSED';
  
  if (keepaBb > 0) {
    inferredBbPrice = keepaBb;
    
    // Check if Amazon owns it
    if (amzPrice > 0 && Math.abs(amzPrice - keepaBb) < 0.05) {
      bbOwnerType = 'AMZ';
    }
    // Check if FBA is rotating (multiple FBA sellers at or near BB price)
    else if (fbaCount >= 2 && fbaPrice > 0 && Math.abs(fbaPrice - keepaBb) < 0.50) {
      bbOwnerType = 'ROTATING_FBA';
    }
    // Check if FBM controls (no FBA or FBA price much higher than BB)
    else if (fbaCount === 0 || (fbaPrice > 0 && fbaPrice - keepaBb > 1.00)) {
      bbOwnerType = 'FBM_PRICE_DRIVEN';
    }
    // Single seller controls BB (FBA or FBM)
    else {
      bbOwnerType = 'EXPLICIT_BB';
    }
  } else if (fbaCount > 0 && fbaPrice > 0) {
    // No BB but FBA exists - likely suppressed but FBA would rotate if BB appeared
    inferredBbPrice = fbaPrice;
    bbOwnerType = 'ROTATING_FBA';
  } else if (usedPrice > 0 || newPrice > 0) {
    // No BB, no FBA - FBM driven market
    inferredBbPrice = usedPrice || newPrice;
    bbOwnerType = 'FBM_PRICE_DRIVEN';
  }
  
  // Price ranges
  let newPriceRange = calculatePriceRange(p.csv?.[1] || [], 90);
  let usedPriceRange = calculatePriceRange(p.csv?.[2] || [], 90);
  let bbPriceRange = calculatePriceRange(p.csv?.[18] || [], 90);
  
  const parsedData = {
    title: p.title || "Unknown",
    asin: p.asin,
    isbn: p.eanList?.[0] || '',
    rank: toVal(s[3]),
    avgRank: toVal(avg[3]),
    drops30: p.stats.salesRankDrops30 || 0,
    drops90: p.stats.salesRankDrops90 || 0,
    drops180: p.stats.salesRankDrops180 || 0,
    drops360: p.stats.salesRankDrops360 || 0,
    newPrice: newPrice,
    usedPrice: usedPrice,
    fbaPrice: fbaPrice,
    amzPrice: amzPrice,
    buyBoxPrice: keepaBb,
    inferredBbPrice: inferredBbPrice,
    bbOwnerType: bbOwnerType,
    bbPriceRange: bbPriceRange,
    newPriceRange: newPriceRange,
    usedPriceRange: usedPriceRange,
    avgNew: toPrice(avg[1]),
    avgUsed: toPrice(avg[2]),
    avgBb: toPrice(avg[18]),
    avgNew180: toPrice(avg180[1]),
    avgUsed180: toPrice(avg180[2]),
    avgNew365: toPrice(avg365[1]),
    avgUsed365: toPrice(avg365[2]),
    weight: p.packageWeight ? p.packageWeight / 453.592 : 1, // Keepa uses grams, convert to pounds
    fbaCount: fbaCount,
    totalOffers: toVal(s[11]) || 0,
    category: classifyKeepaCategory(p),
    reviewCount: p.reviewCount || 0,
    rating: p.rating || 0,
    csv: p.csv || {} // Include CSV data for historical price analysis
  };
  
  LOG('=== PARSED DATA ===');
  LOG('Sales drops parsed:', {
    drops30: parsedData.drops30,
    drops90: parsedData.drops90,
    drops180: parsedData.drops180,
    drops360: parsedData.drops360
  });
  
  return parsedData;
}

// Calculate FBA Buybox Win % and FBM competition (post-Nov 3, 2025)
function analyzeFbmCompetition(keepaData) {
  // Calculate days since Nov 3, 2025
  const nov3_2025 = new Date('2025-11-03T00:00:00Z');
  const now = new Date();
  const daysSinceChange = Math.floor((now - nov3_2025) / (1000 * 60 * 60 * 24));
  const analysisWindow = Math.min(Math.max(daysSinceChange, 1), 90); // 1-90 days
  
  const csv = keepaData.csv || {};
  const buyBoxHistory = csv[18] || []; // Amazon price (Buybox) history
  const fbaHistory = csv[10] || []; // FBA offers history
  const usedHistory = csv[2] || []; // Used offers (includes FBM)
  const salesRankHistory = csv[3] || []; // Sales rank history
  
  // Keepa time format: minutes since Keepa epoch (Jan 1, 2011 00:00 UTC)
  const keepaEpoch = new Date('2011-01-01T00:00:00Z').getTime();
  const windowStart = nov3_2025.getTime();
  const windowEnd = now.getTime();
  
  let fbaWinCount = 0;
  let totalSamples = 0;
  let lowestFba = Infinity;
  let lowestFbm = Infinity;
  let currentBb = 0;
  let salesDuringFbaBb = 0;
  let salesDuringFbmBb = 0;
  
  // Historical FBA analysis (ALL TIME, not just post-Nov 3)
  let fbaEverWonBb = false;
  let fbaHistoricalPrices = [];
  let fbaHistoricalBbWins = [];
  
  // Sample buybox history every 12 hours (720 minutes) to avoid over-sampling
  const sampleInterval = 720;
  
  // PHASE 1: Analyze ALL-TIME history to see if FBA has EVER won BB
  for (let i = 0; i < buyBoxHistory.length; i += 2) {
    const time = buyBoxHistory[i];
    const price = buyBoxHistory[i + 1];
    
    if (time === undefined || price === undefined || price === -1) continue;
    
    const timestamp = keepaEpoch + (time * 60 * 1000);
    const bbPrice = price / 100;
    
    // Check if FBA had an offer at this price (any time in history)
    for (let j = 0; j < fbaHistory.length; j += 2) {
      const fbaTime = fbaHistory[j];
      const fbaPrice = fbaHistory[j + 1];
      
      if (fbaTime === undefined || fbaPrice === undefined || fbaPrice === -1) continue;
      
      const fbaTimestamp = keepaEpoch + (fbaTime * 60 * 1000);
      
      // Check if this FBA data point is close in time (within 2 hours)
      if (Math.abs(fbaTimestamp - timestamp) < 2 * 60 * 60 * 1000) {
        const fbaVal = fbaPrice / 100;
        if (Math.abs(fbaVal - bbPrice) < 0.50) {
          fbaEverWonBb = true;
          fbaHistoricalBbWins.push({
            timestamp: timestamp,
            price: fbaVal,
            bbPrice: bbPrice
          });
        }
        break;
      }
    }
  }
  
  // PHASE 2: Analyze POST-NOV 3 performance for current win rate
  for (let i = 0; i < buyBoxHistory.length; i += 2) {
    const time = buyBoxHistory[i];
    const price = buyBoxHistory[i + 1];
    
    if (time === undefined || price === undefined || price === -1) continue;
    
    const timestamp = keepaEpoch + (time * 60 * 1000);
    
    // Only analyze data from Nov 3 forward
    if (timestamp < windowStart || timestamp > windowEnd) continue;
    
    // Sample at intervals to avoid bias
    if (i % sampleInterval !== 0) continue;
    
    totalSamples++;
    const bbPrice = price / 100;
    
    // Check if FBA had an offer at this price (within $0.50)
    let fbaHadOffer = false;
    for (let j = 0; j < fbaHistory.length; j += 2) {
      const fbaTime = fbaHistory[j];
      const fbaPrice = fbaHistory[j + 1];
      
      if (fbaTime === undefined || fbaPrice === undefined || fbaPrice === -1) continue;
      
      const fbaTimestamp = keepaEpoch + (fbaTime * 60 * 1000);
      
      // Check if this FBA data point is close in time (within 2 hours)
      if (Math.abs(fbaTimestamp - timestamp) < 2 * 60 * 60 * 1000) {
        const fbaVal = fbaPrice / 100;
        if (Math.abs(fbaVal - bbPrice) < 0.50) {
          fbaHadOffer = true;
          if (fbaVal < lowestFba) lowestFba = fbaVal;
        }
        break;
      }
    }
    
    if (fbaHadOffer) {
      fbaWinCount++;
    }
  }
  
  // Get current lowest FBA and FBM prices
  if (keepaData.fbaPrice > 0) lowestFba = keepaData.fbaPrice;
  if (keepaData.usedPrice > 0) lowestFbm = keepaData.usedPrice;
  
  // Current BB
  if (keepaData.buyBoxPrice > 0) {
    currentBb = keepaData.buyBoxPrice;
  } else if (keepaData.inferredBbPrice > 0) {
    currentBb = keepaData.inferredBbPrice;
  }
  
  // Calculate win percentage (post-Nov 3)
  const fbaWinPct = totalSamples > 0 ? Math.round((fbaWinCount / totalSamples) * 100) : 0;
  
  // Analyze historical FBA BB prices
  let fbaHistoricalBbPriceMin = Infinity;
  let fbaHistoricalBbPriceMax = 0;
  let fbaHistoricalBbPriceAvg = 0;
  
  if (fbaHistoricalBbWins.length > 0) {
    const prices = fbaHistoricalBbWins.map(w => w.price);
    fbaHistoricalBbPriceMin = Math.min(...prices);
    fbaHistoricalBbPriceMax = Math.max(...prices);
    fbaHistoricalBbPriceAvg = prices.reduce((a, b) => a + b, 0) / prices.length;
  }
  
  // Estimate FBM shipping (standard Media Mail ~$3.99)
  const estimatedShipping = 3.99;
  const fbmTotalPrice = lowestFbm < Infinity ? lowestFbm + estimatedShipping : 0;
  
  // Determine win rate stars
  let winStars = '';
  if (fbaWinPct >= 80) winStars = '‚≠ê‚≠ê‚≠ê';
  else if (fbaWinPct >= 50) winStars = '‚≠ê‚≠ê';
  else if (fbaWinPct >= 20) winStars = '‚≠ê';
  else winStars = '‚ùå';
  
  // Estimate sales during FBA BB vs FBM BB (rough approximation)
  const totalDrops = keepaData.drops90 || 0;
  salesDuringFbaBb = Math.round(totalDrops * (fbaWinPct / 100));
  salesDuringFbmBb = totalDrops - salesDuringFbaBb;
  
  // Determine current FBA viability
  let fbaViability = 'UNKNOWN';
  let fbaViabilityNote = '';
  
  // Check if there are currently NO FBA offers
  const noCurrentFbaOffers = keepaData.fbaPrice === 0 || lowestFba === Infinity || lowestFba === 0;
  
  // Check if there were FBA offers in the post-Nov 3 window
  const hadFbaOffersPostNov3 = fbaWinCount > 0 || totalSamples > 0;
  
  // KEEPA BLINDSPOT DETECTION: If Keepa shows 0 FBA offers but there's a Buybox that's not clearly FBM
  const possibleKeepaBlindspot = noCurrentFbaOffers && 
                                  keepaData.buyBoxPrice > 0 && 
                                  keepaData.bbOwnerType !== 'FBM_PRICE_DRIVEN' &&
                                  keepaData.bbOwnerType !== 'AMZ';
  
  if (possibleKeepaBlindspot) {
    fbaViability = 'KEEPA_BLINDSPOT';
    fbaViabilityNote = 'WARNING: Keepa shows 0 FBA offers but Buybox exists. Possible Keepa FBA blindspot - check Amazon directly!';
  } else if (noCurrentFbaOffers && !hadFbaOffersPostNov3) {
    // No FBA offers currently AND no FBA offers post-Nov 3
    fbaViability = 'NO_FBA_OFFERS';
    fbaViabilityNote = 'No FBA offers exist - you would be the only/first FBA seller. 0% win rate is meaningless without FBA competition.';
  } else if (noCurrentFbaOffers && hadFbaOffersPostNov3) {
    // No FBA offers NOW, but there were some post-Nov 3
    fbaViability = 'FBA_DISAPPEARED';
    fbaViabilityNote = 'FBA sellers existed post-Nov 3 but have all left. Opportunity or warning?';
  } else if (!fbaEverWonBb) {
    fbaViability = 'NEVER_WON';
    fbaViabilityNote = 'FBA has never won Buybox on this listing (all-time history)';
  } else if (fbaWinPct === 0 && totalSamples > 0) {
    fbaViability = 'LOST_POST_NOV3';
    fbaViabilityNote = `FBA won Buybox historically at $${fbaHistoricalBbPriceMin.toFixed(2)}-$${fbaHistoricalBbPriceMax.toFixed(2)}, but has not won since Nov 3`;
  } else if (fbaWinPct > 0) {
    fbaViability = 'ACTIVE';
    fbaViabilityNote = `FBA wins ${fbaWinPct}% of time since Nov 3`;
  }
  
  return {
    daysAnalyzed: analysisWindow,
    fbaWinPct: fbaWinPct,
    winStars: winStars,
    lowestFba: lowestFba < Infinity ? lowestFba : 0,
    lowestFbm: lowestFbm < Infinity ? lowestFbm : 0,
    fbmTotalPrice: fbmTotalPrice,
    currentBb: currentBb,
    salesDuringFbaBb: salesDuringFbaBb,
    salesDuringFbmBb: salesDuringFbmBb,
    totalSamples: totalSamples,
    // Historical FBA analysis
    fbaEverWonBb: fbaEverWonBb,
    fbaHistoricalBbWins: fbaHistoricalBbWins.length,
    fbaHistoricalBbPriceMin: fbaHistoricalBbPriceMin < Infinity ? fbaHistoricalBbPriceMin : 0,
    fbaHistoricalBbPriceMax: fbaHistoricalBbPriceMax > 0 ? fbaHistoricalBbPriceMax : 0,
    fbaHistoricalBbPriceAvg: fbaHistoricalBbPriceAvg > 0 ? fbaHistoricalBbPriceAvg : 0,
    fbaViability: fbaViability,
    fbaViabilityNote: fbaViabilityNote
  };
}

// Analyze recent FBA activity from Keepa CSV history (more reliable than scraping)
async function analyzeRecentFbaActivity(keepaData) {
  LOG('üìä Analyzing recent FBA activity from Keepa history...');
  
  const csv = keepaData.csv || {};
  const fbaHistory = csv[10] || []; // FBA offers history
  
  if (fbaHistory.length === 0) {
    LOG('No FBA history data available');
    return {
      hadRecentFba: false,
      recentFbaCount: 0,
      recentFbaPrices: [],
      lastSeenDaysAgo: null
    };
  }
  
  const keepaEpoch = new Date('2011-01-01T00:00:00Z').getTime();
  const now = new Date().getTime();
  const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
  const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
  
  const recentPrices = [];
  let lastSeenTimestamp = 0;
  
  // Scan FBA history for recent activity
  for (let i = 0; i < fbaHistory.length; i += 2) {
    const time = fbaHistory[i];
    const price = fbaHistory[i + 1];
    
    if (time === undefined || price === undefined || price === -1) continue;
    
    const timestamp = keepaEpoch + (time * 60 * 1000);
    
    // Check if within last 30 days
    if (timestamp >= thirtyDaysAgo) {
      const priceVal = price / 100;
      if (priceVal > 0 && priceVal >= 3 && priceVal <= 200) {
        recentPrices.push(priceVal);
        if (timestamp > lastSeenTimestamp) {
          lastSeenTimestamp = timestamp;
        }
      }
    }
  }
  
  const uniquePrices = [...new Set(recentPrices)].sort((a, b) => a - b);
  const hadRecentFba = uniquePrices.length > 0;
  const lastSeenDaysAgo = lastSeenTimestamp > 0 ? Math.floor((now - lastSeenTimestamp) / (24 * 60 * 60 * 1000)) : null;
  
  LOG('Recent FBA activity:', {
    hadRecentFba,
    recentFbaCount: uniquePrices.length,
    priceRange: uniquePrices.length > 0 ? `$${uniquePrices[0].toFixed(2)} - $${uniquePrices[uniquePrices.length-1].toFixed(2)}` : 'N/A',
    lastSeenDaysAgo
  });
  
  return {
    hadRecentFba: hadRecentFba,
    recentFbaCount: uniquePrices.length,
    recentFbaPrices: uniquePrices,
    recentLowestFba: uniquePrices.length > 0 ? uniquePrices[0] : 0,
    recentHighestFba: uniquePrices.length > 0 ? uniquePrices[uniquePrices.length - 1] : 0,
    lastSeenDaysAgo: lastSeenDaysAgo
  };
}

// Classify category
function classifyKeepaCategory(p) {
  const binding = String(p?.binding || '').toLowerCase();
  const pt = String(p?.productType || '').toLowerCase();
  const treeNames = (p?.categoryTree || []).map(n => String(n?.name || '').toLowerCase()).join(' > ');
  const title = String(p?.title || '').toLowerCase();
  
  const hay = `${binding} ${pt} ${treeNames} ${title}`;
  
  if (hay.includes('audio cd') || hay.includes('music cd') || (hay.includes('music') && hay.includes('cd'))) return 'MUSIC CD';
  if (hay.includes('dvd') || hay.includes('blu-ray') || hay.includes('movies') || hay.includes('tv')) return 'DVD';
  if (hay.includes('video game') || (hay.includes('playstation') || hay.includes('xbox') || hay.includes('nintendo')) && hay.includes('game')) return 'VIDEO GAME';
  if (hay.includes('book')) return 'BOOK';
  
  return p?.categoryTree?.[0]?.name || 'Unknown';
}

// Calculate fees (category-aware from v1)
function calculateFees(price, weight, category) {
  const closingFee = 1.80;
  let referralFee = 0;
  let fulfillmentFee = 0;
  
  // Round weight DOWN to nearest 0.1 lb to avoid tier creep from tiny decimals
  // (2.006 becomes 2.0, not 2.01, so it stays in the 2lb tier)
  const roundedWeight = Math.floor(weight * 10) / 10;
  
  const cat = (category || '').toLowerCase();
  
  // Use CONFIG.mediaType first (user selected), then fall back to category string
  const isBooks = CONFIG.mediaType === 'book';
  const isMedia = CONFIG.mediaType === 'cd' || CONFIG.mediaType === 'dvd' || CONFIG.mediaType === 'game' ||
                  cat.includes('music') || cat.includes('video') || cat.includes('dvd') || cat.includes('cd') || cat.includes('game');
  
  // Referral fees
  referralFee = price * 0.15; // 15% standard
  
  // Fulfillment fees
  if (isBooks) {
    if (roundedWeight <= 0.5) fulfillmentFee = 3.07;
    else if (roundedWeight <= 1) fulfillmentFee = 3.37;
    else if (roundedWeight <= 2) fulfillmentFee = 4.16;
    else if (roundedWeight <= 3) fulfillmentFee = 5.32;
    else fulfillmentFee = 5.32 + ((roundedWeight - 3) * 0.38);
  } else if (isMedia) {
    if (roundedWeight <= 0.5) fulfillmentFee = 2.92;
    else if (roundedWeight <= 1) fulfillmentFee = 3.16;
    else if (roundedWeight <= 2) fulfillmentFee = 3.74;
    else fulfillmentFee = 3.74 + ((roundedWeight - 2) * 0.38);
  } else {
    if (roundedWeight <= 1) fulfillmentFee = 3.22;
    else if (roundedWeight <= 2) fulfillmentFee = 4.40;
    else fulfillmentFee = 4.40 + ((roundedWeight - 2) * 0.38);
  }
  
  LOG('=== FEE BREAKDOWN ===');
  LOG('Price:', price);
  LOG('Weight (raw):', weight);
  LOG('Weight (rounded):', roundedWeight);
  LOG('Category:', category, '| isBooks:', isBooks, '| isMedia:', isMedia);
  LOG('Referral fee (15%):', referralFee);
  LOG('Fulfillment fee:', fulfillmentFee);
  LOG('Closing fee:', closingFee);
  LOG('Total:', closingFee + referralFee + fulfillmentFee);
  
  return closingFee + referralFee + fulfillmentFee;
}

// Analyze with Gemini using Matt's detailed sourcing prompt
async function analyzeWithGemini(keepaData) {
  LOG('Analyzing with Gemini...', keepaData);
  
  // ============================================================================
  // SELL PRICE DETERMINATION - Buy Box Aware Logic
  // ============================================================================
  
  LOG('=== BUY BOX ANALYSIS ===');
  LOG('BB Owner Type:', keepaData.bbOwnerType);
  LOG('FBA Count:', keepaData.fbaCount);
  LOG('Total Offers:', keepaData.totalOffers);
  LOG('Buy Box Price:', keepaData.buyBoxPrice);
  LOG('FBA Price:', keepaData.fbaPrice);
  LOG('Used Price:', keepaData.usedPrice);
  LOG('New Price:', keepaData.newPrice);
  LOG('Amazon Price:', keepaData.amzPrice);
  LOG('Avg Used (90d):', keepaData.avgUsed);
  LOG('Avg New (90d):', keepaData.avgNew);
  LOG('Avg Used (180d):', keepaData.avgUsed180);
  LOG('Avg Used (365d):', keepaData.avgUsed365);
  LOG('---');
  LOG('TITLE:', keepaData.title);
  LOG('CONDITION:', CONFIG.condition);
  
  let sellPrice;
  let pricingNotes = '';
  let autoReject = false;
  let autoRejectReason = '';
  
  // Helper: Get historical FBA price from actual sales periods
  // Parse CSV data to find FBA prices when sales rank dropped (indicating a sale)
  function getHistoricalFbaPrice() {
    // Try to parse FBA price history from CSV data
    // csv[10] = FBA price history (Amazon column index)
    const fbaHistory = keepaData.csv?.[10] || [];
    
    if (fbaHistory && fbaHistory.length > 0) {
      // Get non-zero FBA prices from the history
      const validPrices = [];
      for (let i = 0; i < fbaHistory.length; i += 2) {
        const timestamp = fbaHistory[i];
        const price = fbaHistory[i + 1];
        
        // Skip if no price or -1 (Keepa's "no data" marker)
        if (price && price > 0 && price !== -1) {
          validPrices.push(price / 100); // Convert from Keepa cents to dollars
        }
      }
      
      if (validPrices.length > 0) {
        // Use median of historical FBA prices (more robust than average)
        validPrices.sort((a, b) => a - b);
        const median = validPrices[Math.floor(validPrices.length / 2)];
        LOG(`‚úì Found ${validPrices.length} historical FBA prices, median: $${median.toFixed(2)}`);
        return median;
      }
    }
    
    // Fallback to current FBA price
    return keepaData.fbaPrice || 0;
  }
  
  // Helper: Estimate if FBA has made sales by checking if BB price matched FBA price during sales
  // More sophisticated than just checking fbaCount > 0
  function estimateFbaSales(days) {
    const drops = days <= 180 ? keepaData.drops180 : keepaData.drops360;
    
    // If no sales at all, FBA definitely didn't sell
    if (drops === 0) return false;
    
    // Check if FBA currently exists or existed historically
    const hasFba = keepaData.fbaCount > 0 || keepaData.fbaPrice > 0;
    
    // Try to detect FBA sales by comparing Buy Box price to FBA price in history
    const bbHistory = keepaData.csv?.[18] || []; // Buy Box price history
    const fbaHistory = keepaData.csv?.[10] || []; // FBA price history
    
    if (bbHistory.length > 0 && fbaHistory.length > 0 && hasFba) {
      // Sample check: Look for times when BB price matched FBA price
      let matchCount = 0;
      let totalSamples = 0;
      
      for (let i = 0; i < Math.min(bbHistory.length, fbaHistory.length); i += 2) {
        const bbPrice = bbHistory[i + 1];
        const fbaPrice = fbaHistory[i + 1];
        
        if (bbPrice > 0 && fbaPrice > 0 && bbPrice !== -1 && fbaPrice !== -1) {
          totalSamples++;
          // If prices are within $0.50, consider it a match (FBA likely had BB)
          if (Math.abs(bbPrice - fbaPrice) < 50) { // Keepa uses cents
            matchCount++;
          }
        }
      }
      
      if (totalSamples > 0) {
        const matchRate = matchCount / totalSamples;
        LOG(`FBA/BB match rate: ${(matchRate * 100).toFixed(0)}% (${matchCount}/${totalSamples} samples)`);
        // If BB matched FBA at least 20% of the time, assume FBA made some sales
        return matchRate > 0.20;
      }
    }
    
    // Fallback: Conservative assumption - if FBA exists and there were sales, assume some FBA sales
    if (hasFba && drops > 0) {
      return true;
    }
    
    return false;
  }
  
  // DECISION TREE
  switch (keepaData.bbOwnerType) {
    
    // ========================================================================
    // CASE 1: AMAZON OWNS BUY BOX
    // ========================================================================
    case 'AMZ':
      LOG('‚Üí Amazon owns Buy Box');
      
      // Check for non-Amazon FBA sales in last 180 days
      const hasNonAmzFbaSales = estimateFbaSales(180) && keepaData.fbaCount > 0;
      
      if (!hasNonAmzFbaSales) {
        autoReject = true;
        autoRejectReason = 'Amazon owns Buy Box and no non-Amazon FBA sales detected in last 180 days. FBA cannot compete.';
        sellPrice = 0;
      } else {
        // Use lower of median historical FBA or current lowest FBA
        const historicalFba = getHistoricalFbaPrice();
        const currentFba = keepaData.fbaPrice || 0;
        
        // For median, approximate with historical
        // TODO: Calculate actual median from csv data
        const medianFba = historicalFba;
        
        sellPrice = currentFba > 0 && currentFba < medianFba ? currentFba : medianFba;
        pricingNotes = `Amazon owns BB but non-Amazon FBA making sales. Using ${currentFba > 0 && currentFba < medianFba ? 'current' : 'historical'} FBA price: $${sellPriceDisplay}`;
        LOG(pricingNotes);
      }
      break;
    
    // ========================================================================
    // CASE 2: ROTATING FBA (Multiple FBA sellers rotating BB)
    // ========================================================================
    case 'ROTATING_FBA':
      LOG('‚Üí Rotating FBA Buy Box');
      
      const historicalFba2 = getHistoricalFbaPrice();
      const currentFba2 = keepaData.fbaPrice || 0;
      
      sellPrice = Math.min(historicalFba2 || Infinity, currentFba2 || Infinity);
      if (sellPrice === Infinity) sellPrice = 0;
      
      // Estimate FBA win rate (simplified)
      // Better implementation: Parse BB history to see FBA vs FBM ownership
      const estimatedFbaWinRate = keepaData.fbaCount / Math.max(keepaData.totalOffers, 1) * 100;
      
      if (estimatedFbaWinRate < 50) {
        pricingNotes = `FBA rotation exists but estimated win rate is low (${estimatedFbaWinRate.toFixed(0)}%). Price: $${sellPriceDisplay}. Gemini will assess risk.`;
      } else {
        pricingNotes = `FBA rotation active. Using FBA price: $${sellPriceDisplay}`;
      }
      LOG(pricingNotes);
      break;
    
    // ========================================================================
    // CASE 3: EXPLICIT BB (Single seller controls)
    // ========================================================================
    case 'EXPLICIT_BB':
      LOG('‚Üí Explicit Buy Box (single seller)');
      
      if (keepaData.fbaCount > 0) {
        // FBA sellers exist
        const hasFbaSales180 = estimateFbaSales(180);
        
        if (hasFbaSales180) {
          const historicalFba3 = getHistoricalFbaPrice();
          const currentFba3 = keepaData.fbaPrice || 0;
          sellPrice = Math.min(historicalFba3 || Infinity, currentFba3 || Infinity);
          if (sellPrice === Infinity) sellPrice = 0;
          pricingNotes = `FBA sales detected in 180 days. Using FBA price: $${sellPriceDisplay}`;
        } else {
          // No FBA sales but FBA exists
          sellPrice = keepaData.fbaPrice || 0;
          pricingNotes = `No FBA sales in 180 days but FBA offers exist. Using current FBA price: $${sellPriceDisplay}. Gemini will assess.`;
        }
      } else {
        // No current FBA, check historical
        const hasFbaSales180_2 = estimateFbaSales(180);
        if (hasFbaSales180_2) {
          sellPrice = getHistoricalFbaPrice();
          pricingNotes = `No current FBA but historical FBA sales found. Using historical price: $${sellPriceDisplay}`;
        } else {
          // Fall back to condition-based pricing
          sellPrice = CONFIG.condition === 'USED' ? keepaData.usedPrice : keepaData.newPrice;
          pricingNotes = `No FBA detected. Using ${CONFIG.condition} price: $${sellPriceDisplay}. Gemini will assess.`;
        }
      }
      LOG(pricingNotes);
      break;
    
    // ========================================================================
    // CASE 4: FBM CONTROLS BB
    // ========================================================================
    // CASE 4: FBM CONTROLS BB
    // ========================================================================
    // CASE 4: FBM CONTROLS BB
    // ========================================================================
    case 'FBM_PRICE_DRIVEN':
      LOG('‚Üí FBM controls Buy Box');
      
      const hasFbaSales180_fbm = estimateFbaSales(180);
      const historicalFba4 = getHistoricalFbaPrice();
      
      // Option C with fallback to A: Use BB price if available (includes shipping)
      let fbmCompetitivePrice;
      if (keepaData.buyBoxPrice && keepaData.buyBoxPrice > 0) {
        // BB price includes shipping if any
        fbmCompetitivePrice = keepaData.buyBoxPrice;
        pricingNotes = `FBM BB price used (includes shipping if any): $${fbmCompetitivePrice.toFixed(2)}`;
      } else {
        // Fallback: Use raw FBM price (assume free shipping exists)
        // Check if condition-specific price exists
        const conditionPrice = CONFIG.condition === 'USED' ? keepaData.usedPrice : keepaData.newPrice;
        
        if (!conditionPrice || conditionPrice === 0) {
          // No current offers for this condition
          if (CONFIG.condition === 'USED') {
            // No current USED offers - try to estimate competitive USED price
            // Check historical data cascading from recent to older
            const historicalUsed90 = keepaData.avgUsed; // 90-day average
            const historicalUsed180 = keepaData.avgUsed180; // 180-day average
            const historicalUsed365 = keepaData.avgUsed365; // 365-day average
            const currentNew = keepaData.newPrice;
            const avgNew = keepaData.avgNew;
            
            // Priority 1: Recent historical (90 days)
            if (historicalUsed90 && historicalUsed90 > 0) {
              fbmCompetitivePrice = historicalUsed90;
              pricingNotes = `No current USED offers. Using 90-day historical USED average: $${fbmCompetitivePrice.toFixed(2)}. You could be first/only USED FBA seller.`;
            }
            // Priority 2: Medium-term historical (180 days)
            else if (historicalUsed180 && historicalUsed180 > 0) {
              fbmCompetitivePrice = historicalUsed180;
              pricingNotes = `No current USED offers. Using 180-day historical USED average: $${fbmCompetitivePrice.toFixed(2)}. Older data but viable.`;
            }
            // Priority 3: Long-term historical (365 days)
            else if (historicalUsed365 && historicalUsed365 > 0) {
              fbmCompetitivePrice = historicalUsed365;
              pricingNotes = `No current USED offers. Using 365-day historical USED average: $${fbmCompetitivePrice.toFixed(2)}. Old data, market may have changed.`;
              LOG(`‚úì Found 365-day historical USED average: $${historicalUsed365}`);
            }
            // Priority 4: Estimate from NEW
            else if (currentNew > 0 || avgNew > 0) {
              const newBasePrice = currentNew || avgNew;
              fbmCompetitivePrice = newBasePrice * 0.70; // 70% of NEW for Good condition
              pricingNotes = `No historical USED data (checked 365 days). Estimated USED price at 70% of NEW ($${newBasePrice.toFixed(2)}): $${fbmCompetitivePrice.toFixed(2)}. Unproven market.`;
            }
            // Priority 5: No data at all
            else {
              autoReject = true;
              autoRejectReason = `No USED or NEW pricing available. Cannot determine competitive price.`;
              sellPrice = 0;
              break;
            }
          } else {
            // NEW condition but no NEW offers
            autoReject = true;
            autoRejectReason = `No NEW offers exist for this item. Only USED copies available. Cannot analyze NEW condition.`;
            sellPrice = 0;
            break;
          }
        } else {
          fbmCompetitivePrice = conditionPrice;
          pricingNotes = `FBM price used (free shipping status unknown): $${fbmCompetitivePrice.toFixed(2)}`;
        }
      }
      
      if (hasFbaSales180_fbm && historicalFba4 > 0) {
        sellPrice = Math.min(historicalFba4, fbmCompetitivePrice);
        pricingNotes += ` | FBA sales exist, using lower of FBA ($${historicalFba4.toFixed(2)}) or FBM ($${fbmCompetitivePrice.toFixed(2)})`;
      } else {
        sellPrice = fbmCompetitivePrice;
        pricingNotes += ` | No recent FBA sales. Gemini will assess FBA viability.`;
      }
      LOG(pricingNotes);
      break;
    
    // ========================================================================
    // CASE 5: SUPPRESSED BB
    // ========================================================================
    case 'SUPPRESSED':
    default:
      LOG('‚Üí Suppressed or unknown Buy Box');
      
      const hasFbaSales180_supp = estimateFbaSales(180);
      
      if (hasFbaSales180_supp) {
        // FBA sales in last 180 days
        const historicalFba5 = getHistoricalFbaPrice();
        const currentFba5 = keepaData.fbaPrice || 0;
        sellPrice = Math.min(historicalFba5 || Infinity, currentFba5 || Infinity);
        if (sellPrice === Infinity) sellPrice = 0;
        pricingNotes = `Suppressed BB but FBA sales in 180 days. Using lower of historical or current FBA: $${sellPriceDisplay}`;
      } else {
        // No FBA sales in 180 days, check 360
        const hasFbaSales360 = estimateFbaSales(360);
        
        if (!hasFbaSales360) {
          autoReject = true;
          autoRejectReason = 'Suppressed Buy Box with no FBA sales in last 360 days. Market is dead for FBA.';
          sellPrice = 0;
        } else {
          // FBA sales 181-360 days ago (seasonal or declining)
          // Priority: historical averages > current prices > fallback
          const historicalFba = getHistoricalFbaPrice();
          const historicalCondition = CONFIG.condition === 'USED' ? 
            (keepaData.avgUsed365 || keepaData.avgUsed180 || keepaData.avgUsed) :
            (keepaData.avgNew365 || keepaData.avgNew180 || keepaData.avgNew);
          
          if (historicalFba > 0) {
            sellPrice = historicalFba;
            pricingNotes = `Suppressed BB. Old FBA sales (181-360 days). Using historical FBA price: $${sellPriceDisplay}.`;
          } else if (historicalCondition && historicalCondition > 0) {
            sellPrice = historicalCondition;
            pricingNotes = `Suppressed BB. Old sales (181-360 days). Using historical ${CONFIG.condition} average: $${sellPriceDisplay}.`;
          } else {
            sellPrice = CONFIG.condition === 'USED' ? keepaData.usedPrice : keepaData.newPrice;
            pricingNotes = `Suppressed BB. Old sales (181-360 days). Using current ${CONFIG.condition} price: $${sellPriceDisplay}.`;
          }
          
          pricingNotes += ` Gemini will assess if seasonal or dead.`;
        }
      }
      LOG(pricingNotes);
      break;
  }
  
  // ============================================================================
  // AUTO-REJECT CHECK
  // ============================================================================
  if (autoReject) {
    console.error('üö´ AUTO-REJECT:', autoRejectReason);
    return {
      verdict: 'REJECT',
      reasoning: [autoRejectReason],
      profit: 0,
      sellPrice: 0,
      autoRejected: true
    };
  }
  
  // ============================================================================
  // FALLBACK: If no price determined, use best available
  // ============================================================================
  if (!sellPrice || sellPrice === 0) {
    console.warn('‚ö†Ô∏è Buy Box logic failed to determine price, using fallback...');
    
    // Try condition-specific prices
    if (CONFIG.condition === 'USED') {
      sellPrice = keepaData.usedPrice || keepaData.avgUsed || keepaData.fbaPrice;
      
      // If still no USED price, this might be a NEW-only item
      if (!sellPrice || sellPrice === 0) {
        console.error('‚ùå No USED pricing available. This may be a NEW-only item.');
        return {
          verdict: 'REJECT',
          reasoning: ['No USED offers exist for this item. Only NEW copies are available. Cannot analyze USED condition.'],
          profit: 0,
          sellPrice: 0,
          autoRejected: true
        };
      }
    } else {
      sellPrice = keepaData.newPrice || keepaData.avgNew || keepaData.fbaPrice;
      
      // If still no NEW price, this might be a USED-only item
      if (!sellPrice || sellPrice === 0) {
        console.error('‚ùå No NEW pricing available. This may be a USED-only item.');
        return {
          verdict: 'REJECT',
          reasoning: ['No NEW offers exist for this item. Only USED copies are available. Cannot analyze NEW condition.'],
          profit: 0,
          sellPrice: 0,
          autoRejected: true
        };
      }
    }
    
    if (sellPrice && sellPrice > 0) {
      pricingNotes = `Fallback pricing used: $${sellPriceDisplay}. Buy Box logic incomplete for this item.`;
      console.warn(pricingNotes);
    } else {
      throw new Error('Unable to determine competitive sell price. No price data available from Keepa.');
    }
  }
  
  LOG('‚úì Final Sell Price:', sellPrice);
  LOG('‚úì Pricing Notes:', pricingNotes);
  LOG('‚úì Buy Cost:', CONFIG.buyCost);
  LOG('---');
  
  // ============================================================================
  // PROFIT CALCULATION
  // ============================================================================
  
  // GAP 6 FIX: Validation - warn if sell price seems suspiciously low
  if (sellPrice < CONFIG.buyCost) {
    console.warn(`‚ö†Ô∏è WARNING: Sell price ($${sellPrice}) is LOWER than your cost ($${CONFIG.buyCost})!`);
  }
  
  // Calculate profit
  const totalFees = calculateFees(sellPrice, keepaData.weight, keepaData.category);
  const profit = sellPrice - CONFIG.buyCost - totalFees;
  
  // GAP 6 FIX: Negative profit warning
  if (profit < 0) {
    console.warn(`‚ö†Ô∏è WARNING: NEGATIVE PROFIT! You will LOSE $${Math.abs(profit).toFixed(2)} per sale!`);
  }
  
  // GAP 3 FIX: Calculate FBA win rate FIRST (needed for time-to-sale calculation)
  const bbHistory = keepaData.csv?.[18] || [];
  const fbaHistory = keepaData.csv?.[10] || [];
  let fbaWinRate = 0;
  
  if (bbHistory.length > 0 && fbaHistory.length > 0 && keepaData.fbaCount > 0) {
    let fbaControlCount = 0;
    let totalSamples = 0;
    
    // Sample the price history to see how often FBA controlled the Buy Box
    for (let i = 0; i < Math.min(bbHistory.length, fbaHistory.length); i += 2) {
      const bbPrice = bbHistory[i + 1];
      const fbaPrice = fbaHistory[i + 1];
      
      if (bbPrice > 0 && fbaPrice > 0 && bbPrice !== -1 && fbaPrice !== -1) {
        totalSamples++;
        // If BB price matches FBA price (within $0.50), FBA controlled BB
        if (Math.abs(bbPrice - fbaPrice) < 50) {
          fbaControlCount++;
        }
      }
    }
    
    if (totalSamples > 0) {
      fbaWinRate = (fbaControlCount / totalSamples) * 100;
      LOG(`‚úì FBA Win Rate: ${fbaWinRate.toFixed(1)}% (BB matched FBA ${fbaControlCount}/${totalSamples} times)`);
    }
  } else if (keepaData.fbaCount > 0 && keepaData.totalOffers > 0) {
    // Fallback: Use offer count as rough proxy
    fbaWinRate = (keepaData.fbaCount / keepaData.totalOffers) * 100;
    LOG(`‚ö†Ô∏è FBA Win Rate (estimated from offer count): ${fbaWinRate.toFixed(1)}%`);
  }
  
  // GAP 1 FIX: Calculate sales velocity
  const salesPerMonth = keepaData.drops30 || 0; // Use 30-day as most recent velocity
  const sales180PerMonth = keepaData.drops180 ? (keepaData.drops180 / 6).toFixed(1) : 0;
  
  // GAP 6 FIX: Detect seasonality
  const isSeasonal = keepaData.drops180 === 0 && keepaData.drops360 > 0;
  const isSlowRecent = keepaData.drops180 > 0 && keepaData.drops180 < (keepaData.drops360 / 2);
  
  // GAP 2 & 5 FIX: Estimate time to sale with FBA win rate adjustment
  let timeToSale = 'unknown';
  let timeToSaleExplanation = '';
  
  if (isSeasonal) {
    timeToSale = 'seasonal';
    timeToSaleExplanation = 'Sales only in past 181-360 days, none recent. Likely seasonal item.';
  } else if (salesPerMonth > 0 && keepaData.fbaCount > 0) {
    // Normal case: Active sales with FBA competition
    const salesPerSeller = salesPerMonth / keepaData.fbaCount;
    let baseDaysToSale = Math.round(30 / salesPerSeller);
    
    // GAP 5 FIX: Adjust for FBA win rate
    if (fbaWinRate > 0 && fbaWinRate < 80) {
      // If FBA doesn't control BB most of the time, time will be longer
      const winRateMultiplier = 100 / Math.max(fbaWinRate, 10); // Avoid division by tiny numbers
      baseDaysToSale = Math.round(baseDaysToSale * winRateMultiplier);
      timeToSaleExplanation = `Adjusted for ${fbaWinRate.toFixed(0)}% FBA win rate. `;
    }
    
    if (baseDaysToSale < 7) {
      timeToSale = '1 week';
    } else if (baseDaysToSale < 14) {
      timeToSale = '1-2 weeks';
    } else if (baseDaysToSale < 30) {
      timeToSale = '2-4 weeks';
    } else if (baseDaysToSale < 60) {
      timeToSale = '1-2 months';
    } else if (baseDaysToSale < 90) {
      timeToSale = '2-3 months';
    } else {
      timeToSale = '3+ months';
    }
    
    timeToSaleExplanation += `${salesPerMonth} sales/month √∑ ${keepaData.fbaCount} FBA sellers = ~${baseDaysToSale} days`;
  } else if (salesPerMonth > 0 && keepaData.fbaCount === 0) {
    // No FBA competition - could sell fast or not at all
    timeToSale = 'unknown';
    timeToSaleExplanation = 'No FBA competition history. Sales exist but unclear how fast FBA would sell.';
  } else if (isSlowRecent) {
    timeToSale = '3+ months';
    timeToSaleExplanation = 'Sales declining - less than half of 360-day sales occurred in last 180 days.';
  }
  
  LOG('=== TIME TO SALE ===');
  LOG('Estimate:', timeToSale);
  LOG('Explanation:', timeToSaleExplanation);
  LOG('Is Seasonal:', isSeasonal);
  LOG('FBA Win Rate:', fbaWinRate.toFixed(1) + '%');
  
  LOG('=== PROFIT CALCULATION ===');
  LOG('Sell price:', sellPrice);
  LOG('Your cost:', CONFIG.buyCost);
  LOG('Weight:', keepaData.weight);
  LOG('Category:', keepaData.category);
  LOG('Total fees:', totalFees);
  LOG('Profit (price - cost - fees):', profit);
  LOG('Formula:', `${sellPrice} - ${CONFIG.buyCost} - ${totalFees} = ${profit}`);
  
  // Fix drops360 data if it's broken/missing
  // drops360 should always be >= drops180 (since it's cumulative)
  // If Keepa doesn't return it or returns 0 when drops180 > 0, use drops180 as minimum
  let drops360 = keepaData.drops360;
  if (drops360 === undefined || drops360 === null || drops360 < keepaData.drops180) {
    drops360 = keepaData.drops180; // At minimum, 360-day sales = 180-day sales
    LOG(`‚ö†Ô∏è Fixed drops360: Keepa returned ${keepaData.drops360}, using drops180 (${keepaData.drops180}) as minimum`);
  }
  
  // Build comprehensive Gemini prompt using Matt's detailed sourcing rules
  LOG('=== BUILDING GEMINI PROMPT ===');
  LOG('Keepa data being sent to Gemini:', {
    title: keepaData.title,
    category: keepaData.category,
    condition: CONFIG.condition,
    drops30: keepaData.drops30,
    drops90: keepaData.drops90,
    drops180: keepaData.drops180,
    drops360: drops360,
    drops360_raw: keepaData.drops360,
    rank: keepaData.rank,
    fbaCount: keepaData.fbaCount,
    totalOffers: keepaData.totalOffers,
    fbaPrice: keepaData.fbaPrice,
    sellPrice: sellPrice,
    profit: profit
  });
  
  // Pre-calculate FBM analysis for use in prompt
  const fbmAnalysis = analyzeFbmCompetition(keepaData);
  
  // Build FBM analysis strings - using concatenation to avoid template literal issues
  let fbmWinRateText = '';
  if (fbmAnalysis.fbaWinPct >= 80) {
    fbmWinRateText = fbmAnalysis.fbaWinPct + '% win rate = FBA STILL DOMINATES this listing';
  } else if (fbmAnalysis.fbaWinPct >= 50) {
    fbmWinRateText = fbmAnalysis.fbaWinPct + '% win rate = FBA/FBM SHARE Buybox - you\'ll get exposure';
  } else if (fbmAnalysis.fbaWinPct >= 20) {
    fbmWinRateText = fbmAnalysis.fbaWinPct + '% win rate = FBM DOMINATES but FBA gets some Buybox time';
  } else {
    fbmWinRateText = fbmAnalysis.fbaWinPct + '% win rate = FBM DOMINATES - FBA rarely wins Buybox';
  }
  
  // Build price display strings
  const lowestFbaDisplay = fbmAnalysis.lowestFba > 0 ? fbmAnalysis.lowestFba.toFixed(2) : 'none';
  const lowestFbmDisplay = fbmAnalysis.lowestFbm > 0 ? fbmAnalysis.lowestFbm.toFixed(2) : 'none';
  const currentBbDisplay = fbmAnalysis.currentBb > 0 ? fbmAnalysis.currentBb.toFixed(2) : 'Suppressed';
  const fbmTotalPriceDisplay = fbmAnalysis.fbmTotalPrice.toFixed(2);
  
  // Pre-calculate all financial displays for the prompt
  const buyCostDisplay = CONFIG.buyCost.toFixed(2);
  const sellPriceDisplay = sellPrice.toFixed(2);
  const profitDisplay = profit.toFixed(2);
  const profitFloorDisplay = CONFIG.profitFloor.toFixed(2);
  
  // Pre-calculate competition displays
  const fbaLowestPriceDisplay = keepaData.fbaPrice > 0 ? keepaData.fbaPrice.toFixed(2) : 'none';
  const currentRankDisplay = keepaData.rank ? keepaData.rank.toLocaleString() : 'unknown';
  const avgRankDisplay = keepaData.avgRank ? keepaData.avgRank.toLocaleString() : 'unknown';
  
  // Pre-calculate item quality displays
  const weightDisplay = keepaData.weight.toFixed(2);
  const ratingDisplay = keepaData.rating ? keepaData.rating.toFixed(1) : 'none';
  
  let fbmViabilityText = '';
  if (fbmAnalysis.fbaViability === 'KEEPA_BLINDSPOT') {
    fbmViabilityText = 'üîç KEEPA DATA WARNING: Keepa shows 0 FBA offers, but a Buybox exists that is not clearly FBM/Amazon.\n' +
      'This is likely the "Keepa FBA blindspot" - FBA offers exist on Amazon but Keepa hasn\'t detected them yet.\n' +
      'RECOMMENDATION: Open Amazon listing directly to verify actual FBA competition before making decision.\n' +
      'Do NOT assume you\'d be the only FBA seller. Current data may be incomplete.';
  } else if (fbmAnalysis.fbaViability === 'NO_FBA_OFFERS') {
    fbmViabilityText = 'üí° OPPORTUNITY: NO FBA SELLERS CURRENTLY ON THIS LISTING.\n' +
      'The 0% FBA Buybox win rate is MEANINGLESS - there were no FBA offers to compete!\n' +
      'You would be the ONLY or FIRST FBA seller.\n' +
      'CRITICAL QUESTION: Can you win Buybox against merchant sellers at $' + fbmAnalysis.fbmTotalPrice.toFixed(2) + ' total (item + shipping)?\n' +
      'Prime customers may prefer FBA even at a slight premium. Assess profit at competitive pricing.';
  } else if (fbmAnalysis.fbaViability === 'FBA_DISAPPEARED') {
    fbmViabilityText = '‚ö†Ô∏è WARNING: FBA sellers existed post-Nov 3 but have all LEFT this listing.\n' +
      'Why did they leave? Unprofitable? Couldn\'t win Buybox?\n' +
      'Merchant sellers control at $' + fbmAnalysis.fbmTotalPrice.toFixed(2) + ' total.\n' +
      'ASSESS: Why is there no FBA competition? Can you succeed where others failed?';
  } else if (fbmAnalysis.fbaViability === 'NEVER_WON') {
    fbmViabilityText = '‚ö†Ô∏è WARNING: FBA has NEVER won the Buybox on this listing (all-time history analysis).\n' +
      'This means FBA sellers have never been able to compete here - likely an FBM-only market.\n' +
      'STRONG REJECT unless you see a clear path to winning Buybox.';
  } else if (fbmAnalysis.fbaViability === 'LOST_POST_NOV3') {
    fbmViabilityText = '‚ö†Ô∏è WARNING: FBA historically won Buybox at $' + fbmAnalysis.fbaHistoricalBbPriceMin.toFixed(2) + '-$' + fbmAnalysis.fbaHistoricalBbPriceMax.toFixed(2) + ' (average $' + fbmAnalysis.fbaHistoricalBbPriceAvg.toFixed(2) + '),\n' +
      'BUT has not won Buybox at all since the Nov 3 algorithm change.\n' +
      'This means the Nov 3 change hurt FBA on this specific listing.\n' +
      'ASSESS: Could pricing at $' + fbmAnalysis.fbaHistoricalBbPriceMin.toFixed(2) + ' or lower recapture Buybox? Is profit still viable at that price?';
  } else if (fbmAnalysis.fbaViability === 'ACTIVE') {
    let histPrices = '';
    if (fbmAnalysis.fbaHistoricalBbWins > 0) {
      histPrices = 'Historical FBA Buybox prices: $' + fbmAnalysis.fbaHistoricalBbPriceMin.toFixed(2) + '-$' + fbmAnalysis.fbaHistoricalBbPriceMax.toFixed(2) + ' (' + fbmAnalysis.fbaHistoricalBbWins + ' times FBA won BB)';
    }
    fbmViabilityText = '‚úì FBA is viable: Currently winning ' + fbmAnalysis.fbaWinPct + '% of Buybox time post-Nov 3.\n' + histPrices;
  } else {
    fbmViabilityText = 'Insufficient data to assess FBA viability.';
  }
  
  const prompt = `GEMINI FBA SOURCING AGENT - You help Matt make split-second sourcing decisions at library sales. Matt scans items and needs a FAST, CONFIDENT verdict in 5-10 seconds.

Your job: Analyze the data and return ONE of these verdicts:

VERDICT CRITERIA (use these EXACT rules):

1. BUY = Profit ‚â• $${profitFloorDisplay} AND no significant red flags
   - Strong opportunity, grab it immediately
   - Use this for: Good profit + decent sales + FBA viable OR no FBA competition
   - Minor concerns (like "slow but steady" or "only FBA seller") are NOT red flags
   
2. TAKE THE RISK = Profit ‚â• $${profitFloorDisplay} BUT has red flags
   - Decent profit but legitimate concerns
   - Use this for: Good profit BUT (very slow sales OR can't win BB OR risky pricing)
   - Red flags: <1 sale/month for 6+ months, FBA never wins BB, untested pricing
   
3. REJECT = Profit < $${profitFloorDisplay} OR fatal flaws
   - Don't waste money or space
   - Use this for: Below profit floor OR (no sales ever OR impossible to win BB)

CRITICAL: Don't be overly conservative! If profit is good and data looks reasonable, say BUY.
"Slow but steady" (2-3 sales/month) with good profit = BUY, not RISK.
"Only FBA seller" with good profit = BUY (opportunity!), not RISK.

================================================================================
ITEM DETAILS
================================================================================
Title: ${keepaData.title}
Category: ${keepaData.category}
Condition: ${CONFIG.condition}

FINANCIALS:
- Your Cost: $${buyCostDisplay}
- Sell Price: $${sellPriceDisplay}
- Net Profit: $${profitDisplay} (after ALL Amazon FBA fees)
- Profit Floor: $${profitFloorDisplay} minimum required

PRICING CONTEXT:
${pricingNotes}
Buy Box Owner: ${keepaData.bbOwnerType}

CRITICAL - UNDERSTAND THE PRICING NOTES:
1. If it says "Using 90/180/365-day historical USED average: $X.XX":
   - This is REAL historical data from Keepa showing what USED copies actually sold for
   - This is NOT an estimate or discount calculation
   - The USED price may be very close to NEW if the book is rare, collectible, or typically Like New
   - Do NOT describe this as "estimated" or "discounted from NEW"
   - Say something like: "Historical data shows USED copies sold for $X.XX (similar to NEW at $Y.YY)"

2. If it says "Estimated USED price at 70% of NEW":
   - This IS an estimate (no historical USED data exists)
   - This means risk - unproven market for USED
   - Say: "No historical USED data. Price estimated at 70% of NEW. Risk: Unknown if USED will sell at this price."

SALES HISTORY (cumulative):
- Last 30 days: ${keepaData.drops30} sales
- Last 90 days: ${keepaData.drops90} sales
- Last 180 days: ${keepaData.drops180} sales
- Last 360 days: ${drops360} sales
- Sales velocity: ~${salesPerMonth} sales/month (based on last 30 days)
- 6-month average: ~${sales180PerMonth} sales/month

IMPORTANT: These are CUMULATIVE numbers (drops180 includes drops30).
- If drops180 = drops360, ALL sales are recent (last 180 days) = GOOD SIGN
- If drops180 < drops360, some sales are older (days 181-360) = declining trend
- If drops180 = 0 but drops360 > 0, sales only in days 181-360 = seasonal/dead

COMPETITION:
- Total sellers: ${keepaData.totalOffers} (${keepaData.fbaCount} FBA, ${keepaData.totalOffers - keepaData.fbaCount} FBM)
- Lowest FBA price: $${fbaLowestPriceDisplay}
- Lowest ${CONFIG.condition} price: $${sellPriceDisplay}
- Current rank: ${currentRankDisplay}
- Average rank (90 days): ${avgRankDisplay}
- Estimated time to sale: ${timeToSale}

${keepaData.historicallyVerified && keepaData.hadRecentFba ? `
üìä RECENT FBA ACTIVITY (Last 30 days from Keepa history):
- FBA offers detected: ${keepaData.recentFbaCount}
- FBA price range: $${keepaData.recentLowestFba?.toFixed(2)} - $${keepaData.recentHighestFba?.toFixed(2)}
- Last seen: ${keepaData.lastSeenDaysAgo} days ago
- Status: FBA sellers WERE here but have left/disappeared

INTERPRETATION:
${keepaData.lastSeenDaysAgo <= 3 ? 
  'FBA offers existed very recently (within 3 days). Possible Keepa lag - check Amazon manually to confirm they\'re truly gone.' :
  keepaData.lastSeenDaysAgo <= 7 ?
  'FBA sellers left within the past week. Why? Unprofitable? Lost Buybox to FBM? Assess if you can succeed where they failed.' :
  'FBA sellers left 7+ days ago. Market may have shifted. Historical prices show what FBA tried but couldn\'t sustain.'}

PRICING GUIDANCE:
The recent FBA price range ($${keepaData.recentLowestFba?.toFixed(2)}-$${keepaData.recentHighestFba?.toFixed(2)}) shows what FBA sellers attempted.
If they left, either: (1) couldn't win Buybox, (2) unprofitable, or (3) sold out.
Consider pricing at or below $${keepaData.recentLowestFba?.toFixed(2)} if you want to try FBA on this listing.
` : keepaData.historicallyVerified && !keepaData.hadRecentFba ? `
‚úì HISTORICAL VERIFICATION (Keepa CSV history):
- No FBA offers in last 30 days (confirmed)
- You would be the FIRST or ONLY FBA seller
- No recent FBA competition to worry about
- Focus on beating FBM total cost while maintaining profit
` : ''}

POST-NOV 3, 2025 BUYBOX ANALYSIS (${fbmAnalysis.daysAnalyzed} DAYS OF REAL DATA):
- FBA Buybox Win Rate: ${fbmAnalysis.fbaWinPct}% (${fbmAnalysis.totalSamples} samples analyzed)
- Lowest FBA Offer: $${lowestFbaDisplay}
- Lowest FBM Offer: $${lowestFbmDisplay} + ~$3.99 shipping ‚âà $${fbmTotalPriceDisplay} total cost to customer
- Current Buybox Price: $${currentBbDisplay}
- Sales Activity: ${keepaData.drops90 || 0} total sales (estimated ${fbmAnalysis.salesDuringFbaBb} when FBA had BB, ${fbmAnalysis.salesDuringFbmBb} when FBM had BB)

CRITICAL: NOVEMBER 3, 2025 BUYBOX ALGORITHM CHANGE
On Nov 3, 2025, Amazon changed how Buybox works for Used books. FBA NO LONGER has automatic advantage. 
FBM (Fulfillment by Merchant) and FBA now compete EQUALLY for Buybox based on:
- Total price to customer (FBM item price + shipping vs FBA price with free Prime shipping)
- Seller rating and account health
- Item condition
- Delivery speed (minor factor)

YOU MUST ANALYZE THIS SPECIFIC ITEM'S POST-NOV 3 PERFORMANCE:
- The "FBA Buybox Win Rate" above shows REAL BEHAVIORAL DATA since Nov 3
- ${fbmWinRateText}
- Look at sales distribution: Are sales happening when FBA has Buybox?
- Consider FBM competition's total cost (item + shipping) vs your FBA price

CRITICAL FBA VIABILITY CHECK (ALL-TIME HISTORY):
${fbmViabilityText}

DO NOT make blanket assumptions about FBA winning Buybox. Use the ACTUAL data from this listing's history.

CRITICAL: LOWER rank number = BETTER (more popular). Example: rank 1,000 is MUCH BETTER than rank 100,000.
- If current rank < average rank ‚Üí IMPROVING (getting more popular)
- If current rank > average rank ‚Üí DECLINING (getting less popular)

ITEM QUALITY:
- Weight: ${weightDisplay} lbs
- Review count: ${keepaData.reviewCount || 0}
- Rating: ${ratingDisplay}/5.0

================================================================================
MATT'S CORE RULES (NON-NEGOTIABLE)
================================================================================

1. PROFIT FLOOR: $${profitFloorDisplay} minimum net profit after ALL fees
   - Below $${profitFloorDisplay} = auto-REJECT (not worth the time/space)

2. FBA-ONLY SELLER (CRITICAL):
   - Matt ONLY sells via FBA (Fulfillment by Amazon)
   - FBM (Merchant Fulfilled) sales are IRRELEVANT for competition analysis
   - What matters: Does FBA win the Buy Box and make sales?

3. CONDITION RULES:
   - ${CONFIG.condition} items compete ONLY with other ${CONFIG.condition} sellers
   - Focus on ${CONFIG.condition} competition, not the opposite condition

4. SALES HISTORY (MOST IMPORTANT):
   CRITICAL DEFINITIONS:
   - "0 sales" means literally ZERO (the number 0)
   - "1 sale" means ONE sale occurred (the number 1) - this is NOT zero!
   
   AUTO-REJECT RULE:
   - ONLY auto-REJECT if drops180 = 0 AND drops360 = 0 (both are literally zero)
   - If drops360 = 1 or more, item is NOT dead - it has sales history
   
   RISK LEVELS:
   - drops180 = 0 AND drops360 > 0: TAKE THE RISK (seasonal/slow, but has sold before)
   - drops180 = 1: Very slow (1 sale in 6 months) but alive - needs good profit
   - drops180 > 10: Moderate velocity - safer pick
   - drops180 > 20: Good velocity - strong pick

5. RANK CONTEXT (Category-specific):
   - Books: <100k = fast mover, 100k-500k = moderate, 500k-1M = slow, >1M = very slow
   - Media (CD/DVD): <50k = fast, 50k-200k = moderate, >200k = slow
   - Games: <20k = fast, 20k-100k = moderate, >100k = slow
   - Compare current rank vs average rank to spot trends (improving/declining)

6. FBA BUYBOX WIN RATE (MOST CRITICAL POST-NOV 3):
   - Use the "FBA Buybox Win Rate" percentage from the data above
   - This is REAL performance data for THIS specific item since Nov 3, 2025
   - 80%+ = FBA still dominates (strong buy if profit good)
   - 50-79% = FBA/FBM share Buybox (enough exposure for sales)
   - 20-49% = FBM dominates but FBA gets some time (risky unless high profit)
   - <20% = FBM dominates (avoid unless exceptional circumstances)
   - ALWAYS mention FBA's actual Buybox win rate in your reasoning
   - If FBM is competitive, explain whether your price beats their TOTAL cost (item + shipping)

7. ONE-OFF PURCHASE:
   - Matt buys single copies at library sales (no replenishment)
   - Every item is a single, permanent decision

================================================================================
YOUR ANALYSIS PROCESS
================================================================================

STEP-BY-STEP DECISION TREE:

1. Check profit ‚â• $${profitFloorDisplay} floor
   - If NO ‚Üí VERDICT: REJECT (profit too low)
   - If YES ‚Üí Continue to step 2

2. Check sales history (drops360 value)
   - If drops360 = 0 (exactly zero) ‚Üí VERDICT: REJECT (truly dead, no sales ever)
   - If drops360 ‚â• 1 ‚Üí Continue to step 3

3. Evaluate velocity and competition
   - drops180 = 0 but drops360 > 0 ‚Üí VERDICT: TAKE THE RISK (slow but has sold)
   - drops180 = 1 ‚Üí VERDICT: TAKE THE RISK (very slow, needs patience)
   - drops180 ‚â• 2 ‚Üí Evaluate rank, FBA competition, time to sale
   
4. Check rank context for category (is this fast/slow moving?)
5. Check if FBA sellers exist and if market supports them
6. Assess competition level (how many FBA sellers at this price?)
7. Consider time to sale estimate
8. Make final risk-adjusted verdict

================================================================================
OUTPUT FORMAT (PLAIN ENGLISH - NO JARGON)
================================================================================

VERDICT: [BUY or TAKE THE RISK or REJECT]

REASONING:
‚Ä¢ [SPECIFIC reason with NUMBERS - profit amount, sales count, competition level]
‚Ä¢ [SPECIFIC data point that drives the decision - "28 sales in 180 days" not "sells well"]
‚Ä¢ [SPECIFIC risk or opportunity - "0 FBA sellers = untested market" not "risky"]
‚Ä¢ [SPECIFIC action - "Price at $X to undercut FBA competition" not "price it right"]

CRITICAL: Every bullet MUST contain a SPECIFIC NUMBER or FACT from the data.
DO NOT use vague phrases like:
‚ùå "just move on to the next book"
‚ùå "too risky"
‚ùå "not worth it"
‚ùå "pass on this one"

INSTEAD use specific reasons like:
‚úÖ "Profit $2.80 is below $5.00 minimum threshold"
‚úÖ "No sales in last 180 days AND no sales in last 360 days = dead inventory"
‚úÖ "Only 2 sales in the last 360 days = very slow mover, might take months"
‚úÖ "28 sales in 180 days = about 5 per month, should sell within 1-2 weeks"
‚úÖ "Rank of 450,000 is slow for books, could take 30+ days to sell"
‚úÖ "Current rank (120,000) is much better than average (350,000) = getting more popular"
‚úÖ "5 FBA sellers competing for 10 sales/month = 2 sales per seller = decent pace"
‚úÖ "1 sale in 180 days = extremely slow (1 every 6 months), but $8.30 profit makes it worth the wait"

PLAIN ENGLISH REQUIRED:
- NEVER use technical terms: "drops180", "drops360", "FBA win rate", "untested market", "BB", "FBM"
- NEVER use abbreviations without explanation
- Say "0 FBA sellers" NOT "0 FBA"
- Say "no sales in last 180 days" NOT "drops180 is 0"
- Say "very slow/seasonal sales" NOT "slow/seasonal"
- Say "Featured Offer" or "you'll win the Featured Offer" NOT "Buybox" or "BB"
- Say "Merchant sellers" or "merchant-fulfilled sellers" NOT "FBM"
- Explain what things MEAN for Matt: "might take 6+ months to sell" not just "slow"

EXPLAINING BUYBOX PERFORMANCE (POST-NOV 3):
‚úÖ "You'll win the Featured Offer most of the time at this price"
‚úÖ "Featured Offer alternates between FBA and merchant sellers - you'll get enough exposure"
‚úÖ "Merchant sellers dominate the Featured Offer on this listing - FBA rarely featured"
‚úÖ "Most sales happen when FBA has the Featured Offer"
‚úÖ "Merchant sellers at $10.98 total (with shipping) vs your $12.50 FBA - customers still choose FBA"

‚ùå "73% FBA BB win rate"
‚ùå "FBM dominates"
‚ùå "Good FBA exposure"

CRITICAL: If profit exceeds minimum AND there is ANY sales history (even 1 sale), this is NOT an auto-REJECT.
Only auto-REJECT if: (1) profit below minimum OR (2) literally 0 sales in 360 days.

Keep it CONVERSATIONAL but SPECIFIC. Matt is standing in a library sale making split-second decisions.

Be DECISIVE. No hedging with "it depends" or "maybe." Give a clear answer with CONCRETE REASONS.`;

  LOG('=== FULL GEMINI PROMPT ===');
  LOG(prompt);
  LOG('=== END PROMPT ===');

  try {
    LOG('Sending request to Gemini...');
    LOG('CONFIG.geminiKey length:', CONFIG.geminiKey ? CONFIG.geminiKey.length : 0);
    LOG('CONFIG.useProxy:', CONFIG.useProxy);
    
    let url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${CONFIG.geminiKey}`;
    
    LOG('Constructed URL (before proxy):', url.substring(0, 100) + '...');
    
    // Use proxy if enabled
    if (CONFIG.useProxy) {
      url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
      LOG('Using proxy for Gemini API call');
      LOG('Final URL (with proxy):', url.substring(0, 150) + '...');
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }]
      })
    });
    
    LOG('Gemini response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API Error: HTTP ${response.status} - Check your API key in Settings`);
    }
    
    const data = await response.json();
    LOG('Gemini full response:', data);
    
    // Check for API errors
    if (data.error) {
      throw new Error(data.error.message || 'Gemini API error');
    }
    
    // Check if response has expected structure
    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts) {
      console.error('Unexpected Gemini response structure:', data);
      throw new Error('Unexpected response format from Gemini');
    }
    
    const text = data.candidates[0].content.parts[0].text;
    LOG('Gemini raw text:', text);
    
    // Parse response with more flexible regex
    const verdictMatch = text.match(/VERDICT:\s*(BUY|TAKE THE RISK|REJECT)/i);
    const verdict = verdictMatch ? verdictMatch[1].toUpperCase() : 'REJECT';
    
    // Extract reasoning bullets - try multiple formats
    let reasoning = [];
    const reasoningMatch = text.match(/REASONING:\s*([\s\S]+)/i);
    
    if (reasoningMatch) {
      const reasoningText = reasoningMatch[1].trim();
      
      // Try bullet points with ‚Ä¢, -, *, or numbers
      reasoning = reasoningText
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.match(/^[‚Ä¢\-\*\d]/) || line.length > 20)
        .map(line => line.replace(/^[‚Ä¢\-\*]\s*/, '').replace(/^\d+\.\s*/, '').trim())
        .filter(line => line.length > 10)
        .slice(0, 5); // Max 5 bullets
    }
    
    // If no reasoning found, generate basic reasoning
    if (reasoning.length === 0) {
      if (profit < CONFIG.profitFloor) {
        reasoning = [`Profit $${profit.toFixed(2)} is below $${profitFloorDisplay} minimum threshold`];
      } else if (keepaData.drops360 === 0) {
        reasoning = ['0 sales in 360 days = dead inventory (hard gate)'];
      } else if (keepaData.drops180 === 0) {
        reasoning = ['0 sales in 180 days = high risk'];
      } else {
        reasoning = ['Analysis based on sales data and competition'];
      }
    }
    
    LOG('Parsed verdict:', verdict);
    LOG('Parsed reasoning:', reasoning);
    
    return {
      verdict,
      reasoning,
      profit,
      sellPrice,
      timeToSale,
      salesPerMonth,
      sales180PerMonth
    };
    
  } catch (error) {
    console.error('Gemini API error details:', error);
    throw new Error('Failed to analyze with Gemini: ' + error.message);
  }
}

// Display results
function displayResults(keepaData, geminiResult) {
  loadingState.classList.add('hidden');
  resultsContainer.classList.remove('hidden');
  
  // Analyze FBM competition
  const fbmAnalysis = analyzeFbmCompetition(keepaData);
  
  // Update verdict banner
  const verdictBanner = document.getElementById('verdictBanner');
  const verdictBannerText = document.getElementById('verdictBannerText');
  const verdictBannerIcon = document.getElementById('verdictBannerIcon');
  
  verdictBanner.className = 'verdict-banner';
  if (geminiResult.verdict === 'BUY') {
    verdictBannerText.textContent = `BUY @ $${geminiResult.sellPrice.toFixed(2)}`;
    verdictBannerIcon.textContent = '‚úì';
  } else if (geminiResult.verdict === 'TAKE THE RISK') {
    verdictBanner.classList.add('risk');
    verdictBannerText.textContent = `RISKY @ $${geminiResult.sellPrice.toFixed(2)}`;
    verdictBannerIcon.textContent = '‚ö†';
  } else if (geminiResult.verdict === 'REJECT') {
    verdictBanner.classList.add('reject');
    verdictBannerText.textContent = `REJECT`;
    verdictBannerIcon.textContent = '‚úó';
  } else {
    verdictBanner.classList.add('consider');
    verdictBannerText.textContent = `CONSIDER @ $${geminiResult.sellPrice.toFixed(2)}`;
    verdictBannerIcon.textContent = '?';
  }
  
  // Update FBM price box
  document.getElementById('fbmPriceTitle').textContent = 
    `üìä POST-NOV 3 ANALYSIS (${fbmAnalysis.daysAnalyzed} DAYS)`;
  
  document.getElementById('fbmLowestFba').textContent = 
    fbmAnalysis.lowestFba > 0 ? 
      `$${fbmAnalysis.lowestFba.toFixed(2)}` : 
      (keepaData.historicallyVerified ? 
        (keepaData.hadRecentFba ? 
          `Was $${keepaData.recentLowestFba.toFixed(2)} (${keepaData.lastSeenDaysAgo}d ago)` : 
          `N/A ‚úì Confirmed`) :
        `N/A`);
  
  document.getElementById('fbmLowestFbm').textContent = 
    fbmAnalysis.lowestFbm > 0 ? 
      `$${fbmAnalysis.lowestFbm.toFixed(2)} + ship ‚âà $${fbmAnalysis.fbmTotalPrice.toFixed(2)}` : 
      'N/A';
  
  document.getElementById('fbmCurrentBb').textContent = 
    fbmAnalysis.currentBb > 0 ? `$${fbmAnalysis.currentBb.toFixed(2)}` : 'Suppressed';
  
  document.getElementById('fbmBbWinRate').textContent = 
    `${fbmAnalysis.fbaWinPct}% ${fbmAnalysis.winStars}`;
  
  const totalDrops = keepaData.drops90 || 0;
  document.getElementById('fbmSalesActivity').textContent = 
    `${totalDrops} drops (${fbmAnalysis.salesDuringFbaBb} FBA BB, ${fbmAnalysis.salesDuringFbmBb} FBM BB)`;
  
  // Set verdict
  verdictText.textContent = geminiResult.verdict;
  verdictCard.className = 'verdict-card';
  
  if (geminiResult.verdict === 'TAKE THE RISK') {
    verdictCard.classList.add('risk');
    whyTitle.textContent = 'Why Risky?';
  } else if (geminiResult.verdict === 'REJECT') {
    verdictCard.classList.add('reject');
    whyTitle.textContent = 'Why Reject?';
  } else {
    whyTitle.textContent = 'Why Buy?';
  }
  
  // Set product info
  productTitle.textContent = keepaData.title;
  productMeta.textContent = `${keepaData.category} ‚Ä¢ ${CONFIG.condition}`;
  
  // Show/hide metrics based on verdict
  if (geminiResult.verdict === 'REJECT') {
    metricsSection.classList.add('hidden');
  } else {
    metricsSection.classList.remove('hidden');
    profitValue.textContent = '$' + geminiResult.profit.toFixed(2);
    profitValue.className = 'metric-value';
    if (geminiResult.profit < CONFIG.profitFloor) {
      profitValue.classList.add('orange');
    }
    
    sellForValue.textContent = '$' + geminiResult.sellPrice.toFixed(2);
    
    // Calculate time to sale estimate
    const salesPerMonth = (keepaData.drops30 || 0);
    if (salesPerMonth > 10) {
      timeValue.textContent = '1-7d';
      timeValue.className = 'metric-value';
      timeNote.textContent = 'fast';
    } else if (salesPerMonth > 5) {
      timeValue.textContent = '1-2w';
      timeValue.className = 'metric-value';
      timeNote.textContent = 'good';
    } else if (salesPerMonth > 2) {
      timeValue.textContent = '2-4w';
      timeValue.className = 'metric-value orange';
      timeNote.textContent = 'avg';
    } else if (salesPerMonth > 0) {
      timeValue.textContent = '1-3m';
      timeValue.className = 'metric-value orange';
      timeNote.textContent = 'slow';
    } else {
      timeValue.textContent = '??';
      timeValue.className = 'metric-value gray';
      timeNote.textContent = 'unknown';
    }
  }
  
  // Set reasoning bullets
  whyInner.innerHTML = '';
  
  if (geminiResult.reasoning.length === 0) {
    const placeholder = document.createElement('div');
    placeholder.textContent = 'No reasoning provided';
    placeholder.style.color = 'var(--muted)';
    placeholder.style.textAlign = 'center';
    placeholder.style.padding = '20px';
    whyInner.appendChild(placeholder);
  } else {
    geminiResult.reasoning.forEach(reason => {
      const bullet = document.createElement('div');
      bullet.className = 'why-bullet';
      
      const icon = document.createElement('span');
      icon.className = 'bullet-icon';
      
      // Determine icon type based on verdict
      if (geminiResult.verdict === 'BUY') {
        icon.classList.add('good');
        icon.textContent = '‚úì';
      } else if (geminiResult.verdict === 'REJECT') {
        icon.classList.add('bad');
        icon.textContent = '‚úó';
      } else {
        // Check if this specific bullet is positive or negative
        if (reason.toLowerCase().includes('profit') || reason.toLowerCase().includes('fba') || reason.toLowerCase().includes('sales')) {
          icon.classList.add('good');
          icon.textContent = '‚úì';
        } else {
          icon.classList.add('warn');
          icon.textContent = '‚ö†';
        }
      }
      
      const text = document.createElement('span');
      text.className = 'bullet-text';
      text.textContent = reason;
      
      bullet.appendChild(icon);
      bullet.appendChild(text);
      whyInner.appendChild(bullet);
    });
  }
}

// Title picker functions
function renderTitlePicker(results) {
  const card = document.getElementById('titlePickerCard');
  const list = document.getElementById('titlePickerList');
  
  if (!card || !list) return;
  
  list.innerHTML = results.map((product, index) => {
    const title = product.title || 'Unknown';
    const asin = product.asin;
    const binding = product.binding || product.productType || 'Product';
    const year = product.publicationDate ? String(product.publicationDate).substring(0, 4) : '';
    
    return `
      <div class="title-picker-item" onclick="selectTitleResult('${asin}')">
        <div class="title-picker-item-title">${title}</div>
        <div class="title-picker-item-meta">
          ${binding}${year ? ' ‚Ä¢ ' + year : ''} ‚Ä¢ ASIN: ${asin}
        </div>
      </div>
    `;
  }).join('');
  
  card.classList.remove('hidden');
  loadingState.classList.add('hidden');
}

function closeTitlePicker() {
  const card = document.getElementById('titlePickerCard');
  if (card) card.classList.add('hidden');
}

async function selectTitleResult(asin) {
  closeTitlePicker();
  loadingState.classList.remove('hidden');
  
  try {
    // Fetch full product data for selected ASIN
    const days = 365;
    const productUrl = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=1&asin=${asin}&stats=${days}&history=1`;
    const res = await fetch(productUrl);
    if (!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
    const json = await res.json();
    const keepaData = parseKeepaJson(json);
    
    currentKeepaData = keepaData;
    currentASIN = keepaData.asin;
    
    // Analyze with Gemini
    const geminiResult = await analyzeWithGemini(keepaData);
    
    // Display results
    displayResults(keepaData, geminiResult);
    
  } catch (error) {
    console.error('Error:', error);
    alert('Error: ' + error.message);
    loadingState.classList.add('hidden');
  }
}

// Initialize on load
window.addEventListener('DOMContentLoaded', init);
</script>

</body>
</html>