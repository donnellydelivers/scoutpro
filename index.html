<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Pretty Good Scouting App (Pro)</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<style>
/* --- THEME & RESET --- */
:root {
  --bg: #050505; --panel: #121212; --card: #1e1e1e; --border: #2a2a2a;
  --text: #ffffff; --muted: #888; --green: #34d399; --red: #f87171;
  --yellow: #fbbf24; --blue: #60a5fa; --purple: #a78bfa; --diamond: #22d3ee;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); padding-bottom: 120px; -webkit-font-smoothing: antialiased; overflow-x: hidden; }
.app { max-width: 480px; margin: 0 auto; min-height: 100vh; position: relative; border-left: 1px solid var(--border); border-right: 1px solid var(--border); }

/* --- SPLASH SCREEN --- */
#splash-screen {
    position: fixed; inset: 0; z-index: 9999; background-color: #000;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    transition: opacity 0.8s ease-out, visibility 0.8s;
}
.splash-hidden { opacity: 0; visibility: hidden; pointer-events: none; }
.splash-bg { position: absolute; inset: 0; z-index: 0; }
.splash-bg img { width: 100%; height: 100%; object-fit: cover; }
.splash-bg::after {
    content: ''; position: absolute; inset: 0;
    background: linear-gradient(135deg, rgba(0,0,0,0.85) 0%, rgba(10,10,30,0.9) 100%);
}
.splash-content { position: relative; z-index: 10; text-align: center; width: 100%; padding: 0 20px; }
.big-title {
    font-family: 'Inter', sans-serif; font-weight: 900; text-transform: uppercase;
    line-height: 0.9; letter-spacing: -0.05em; display: flex; flex-direction: column; gap: 0;
    text-shadow: 0 4px 30px rgba(0,0,0,0.8);
}
.big-title span { font-size: 3.5rem; }
@media(min-width: 400px) { .big-title span { font-size: 4.5rem; } }

/* --- HEADER --- */
header { padding: 12px 16px; background: var(--bg); position: sticky; top: 0; z-index: 50; border-bottom: 1px solid var(--border); }
.status-row { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
.status-badge {
    font-size: 10px; font-weight: 700; color: var(--muted);
    background: rgba(255,255,255,0.05); padding: 4px 10px; border-radius: 99px;
    display: flex; align-items: center; gap: 6px; border: 1px solid transparent; transition: all 0.2s;
}
.status-badge.live { color: var(--green); border-color: rgba(52, 211, 153, 0.2); background: rgba(52, 211, 153, 0.1); }
.status-badge.dead { color: var(--red); border-color: rgba(248, 113, 113, 0.2); background: rgba(248, 113, 113, 0.1); }
.status-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

/* --- RESTRICTED BADGE --- */
.restricted-badge {
  display: inline-flex; align-items: center; gap: 4px;
  background: rgba(248, 113, 113, 0.15); color: var(--red);
  border: 1px solid rgba(248, 113, 113, 0.3);
  padding: 3px 8px; border-radius: 4px;
  font-size: 10px; font-weight: 700; text-transform: uppercase;
}
.restricted-count {
  display: inline-flex; align-items: center; gap: 6px;
  color: var(--red); font-size: 12px; font-weight: 600;
}
.btn-remove-restricted {
  background: rgba(248, 113, 113, 0.2); color: var(--red);
  border: 1px solid rgba(248, 113, 113, 0.3);
  padding: 6px 12px; border-radius: 8px;
  font-size: 11px; font-weight: 700; cursor: pointer;
  transition: all 0.2s;
}
.btn-remove-restricted:hover {
  background: rgba(248, 113, 113, 0.3);
}

.search-container { position: relative; display: flex; gap: 8px; }
.input-wrapper { position: relative; flex: 1; }
.search-icon { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 16px; }
input[type="text"] {
  width: 100%; padding: 14px 14px 14px 42px; border-radius: 12px; background: #111; border: 1px solid #333;
  color: white; font-family: 'Inter', sans-serif; font-size: 16px; outline: none; transition: all 0.2s;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
input[type="text"]:focus { border-color: var(--blue); background: #161616; }
.icon-btn {
    width: 48px; border-radius: 12px; border: 1px solid #333; background: #111;
    color: var(--muted); font-size: 18px; cursor: pointer; display: grid; place-items: center; transition: all 0.2s;
}
.icon-btn.active { color: var(--green); border-color: rgba(52, 211, 153, 0.4); background: rgba(52, 211, 153, 0.1); }

/* --- ENHANCED CAMERA OVERLAY --- */
#camera-overlay { 
  position: fixed; inset: 0; z-index: 9999; background: #000; 
  display: flex; flex-direction: column;
}

#camera-header {
  position: absolute; top: 0; left: 0; right: 0; z-index: 10001;
  padding: 20px; background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  text-align: center;
}

.camera-title {
  font-size: 18px; font-weight: 800; color: #fff; margin-bottom: 8px;
}

.camera-mode-toggle {
  display: flex; gap: 8px; justify-content: center; margin-top: 12px;
}

.mode-btn {
  background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.6);
  border: 2px solid rgba(255,255,255,0.2); padding: 8px 20px;
  border-radius: 99px; font-weight: 700; font-size: 13px;
  cursor: pointer; transition: all 0.2s;
}

.mode-btn.active {
  background: rgba(96,165,250,0.2); color: var(--blue);
  border-color: var(--blue);
}

.mode-btn:hover:not(.active) {
  background: rgba(255,255,255,0.15);
}

.camera-status {
  font-size: 13px; font-weight: 600; color: var(--blue); 
  padding: 6px 16px; background: rgba(96,165,250,0.15); 
  border-radius: 99px; display: inline-block;
  border: 1px solid rgba(96,165,250,0.3);
}

.camera-status.detecting {
  color: var(--yellow); background: rgba(251,191,36,0.15);
  border-color: rgba(251,191,36,0.3);
  animation: pulse 1s ease-in-out infinite;
}

.camera-status.success {
  color: var(--green); background: rgba(16,185,129,0.15);
  border-color: rgba(16,185,129,0.3);
}

.camera-status.error {
  color: var(--red); background: rgba(239,68,68,0.15);
  border-color: rgba(239,68,68,0.3);
}

#reader { 
  width: 100%; height: 100%; flex: 1; position: relative;
}

/* Animated Scan Frame */
.scan-frame {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: 300px; height: 180px; z-index: 10000; pointer-events: none;
}

/* ISBN Frame - Wider for text */
.isbn-frame {
  width: 280px; height: 80px;
}

.isbn-hint {
  position: absolute; bottom: -35px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.7); font-size: 12px; font-weight: 600;
  white-space: nowrap; text-align: center;
}

.scan-corner {
  position: absolute; width: 40px; height: 40px;
  border: 3px solid var(--blue); opacity: 0.8;
}

.scan-corner.top-left { top: 0; left: 0; border-right: none; border-bottom: none; }
.scan-corner.top-right { top: 0; right: 0; border-left: none; border-bottom: none; }
.scan-corner.bottom-left { bottom: 0; left: 0; border-right: none; border-top: none; }
.scan-corner.bottom-right { bottom: 0; right: 0; border-left: none; border-top: none; }

.scan-line {
  position: absolute; top: 0; left: 0; right: 0; height: 2px;
  background: linear-gradient(90deg, transparent, var(--green), transparent);
  animation: scanLine 2s ease-in-out infinite;
  box-shadow: 0 0 10px var(--green);
}

@keyframes scanLine {
  0% { top: 0; opacity: 0; }
  50% { opacity: 1; }
  100% { top: 100%; opacity: 0; }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.camera-footer {
  position: absolute; bottom: 0; left: 0; right: 0; z-index: 10001;
  padding: 30px; background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  display: flex; justify-content: center;
}

#close-camera {
  background: rgba(239,68,68,0.2); color: var(--red); 
  border: 2px solid var(--red); padding: 14px 32px;
  border-radius: 99px; font-weight: 800; font-size: 16px; 
  cursor: pointer; transition: all 0.2s;
  display: flex; align-items: center; gap: 8px;
}

#close-camera:hover {
  background: var(--red); color: #fff;
}

#close-camera:active {
  transform: scale(0.95);
}


/* --- CARD --- */
.card {
  margin: 16px; background: var(--panel); border-radius: 20px; border: 1px solid var(--border);
  overflow: hidden; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.5); animation: slideUp 0.3s ease-out;
}
@keyframes slideUp { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }

.banner { padding: 16px 16px; text-align: center; position: relative; }
.banner.buy { background: radial-gradient(circle at top, rgba(16,185,129,0.12), transparent 70%); }
.banner.gem { background: radial-gradient(circle at top, rgba(34, 211, 238, 0.2), transparent 70%); } 
.banner.reject { background: radial-gradient(circle at top, rgba(239,68,68,0.12), transparent 70%); }
.banner.consider { background: radial-gradient(circle at top, rgba(245,158,11,0.12), transparent 70%); }

.score-container { position: relative; width: 80px; height: 80px; margin: 0 auto 10px auto; display: flex; align-items: center; justify-content: center; }
.score-svg { position: absolute; top:0; left:0; width:100%; height:100%; transform: rotate(-90deg); }
.score-circle-bg { fill: none; stroke: rgba(255,255,255,0.05); stroke-width: 8; }
.score-circle-fg { fill: none; stroke: currentColor; stroke-width: 8; stroke-linecap: round; transition: stroke-dashoffset 1s; stroke-dasharray: 283; stroke-dashoffset: 283; }
.score-num { font-size: 32px; font-weight: 800; color: #fff; letter-spacing: -0.04em; z-index: 2; }

/* REPOSITIONED GEM ICON (FIXED) */
.gem-icon {
    position: absolute; 
    top: 10px; 
    left: 50%;
    margin-left: 45px; /* Positions it 45px to the right of the center (next to the 80px score ring) */
    font-size: 28px; 
    filter: drop-shadow(0 0 15px rgba(34, 211, 238, 0.8)); 
    animation: float 3s ease-in-out infinite; 
    display: none; 
}
.gem-icon.visible { display: block; }
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }

.decision-label {
  font-size: 13px; font-weight: 800; text-transform: uppercase; 
  padding: 6px 14px; border-radius: 99px; display: inline-block; margin-top: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.decision-label.buy { background: var(--green); color: #000; }
.decision-label.consider { background: var(--yellow); color: #000; }
.decision-label.reject { background: var(--red); color: #fff; }

#geminiQuickBadge {
    display: inline-flex; align-items: center; gap: 6px; margin-top: 10px; padding: 6px 14px; border-radius: 99px;
    background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
    color: var(--purple); font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em;
}
#geminiQuickBadge:active { transform: scale(0.96); }
.gemini-style-good { background: rgba(52, 211, 153, 0.15); border-color: var(--green); color: var(--green); }
.gemini-style-neutral { background: rgba(167, 139, 250, 0.1); border-color: var(--purple); color: var(--purple); } /* NEUTRAL (PASS) */
.gemini-style-bad { background: rgba(248, 113, 113, 0.15); border-color: var(--red); color: var(--red); }

.condition-toggle {
  display: flex; background: rgba(0,0,0,0.3); border-radius: 99px; padding: 4px; margin: 20px auto 16px auto;
  width: fit-content; border: 1px solid var(--border);
}

.category-badge {
  display: inline-block; background: rgba(167,139,250,0.15); 
  color: var(--purple); padding: 3px 8px; border-radius: 99px;
  font-size: 9px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.05em; border: 1px solid rgba(167,139,250,0.3);
}
.cond-btn { padding: 6px 16px; border-radius: 99px; font-size: 12px; font-weight: 700; color: var(--muted); cursor: pointer; }
.cond-btn.active { background: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }

.slider-container { background: rgba(0,0,0,0.2); border-radius: 12px; padding: 16px 12px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.05); }
.slider-container.collapsed { padding: 0; }
.slider-container.collapsed .slider-content { display: none; }
.adjuster-summary { padding: 12px 16px; cursor: pointer; font-size: 12px; color: var(--muted); text-align: center; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.2s; }
.adjuster-summary:hover { color: var(--blue); }
.slider-content { padding-top: 8px; }
.slider-row { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
.slider-row:last-child { margin-bottom: 0; }
.slider-header { display: flex; justify-content: space-between; font-size: 11px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; font-family: 'Inter', sans-serif; }
.slider-val { color: var(--blue); font-family: 'Inter', sans-serif; font-weight: 700; }
input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--blue); cursor: pointer; margin-top: -6px; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}
input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #333; border-radius: 2px; }

.profit-display { margin-bottom: 12px; }
.profit-val { font-size: 36px; font-weight: 600; font-family: 'JetBrains Mono', monospace; letter-spacing: -0.02em; color: #ffffff; }

.item-title { margin: 6px 0 10px 0; font-size: 14px; color: rgba(255,255,255,0.8); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; height: 40px; font-weight: 800; }

.link-row { display: flex; justify-content: center; gap: 8px; margin-bottom: 12px; }
.ext-link {
  font-size: 10px; font-weight: 700; color: var(--muted); text-decoration: none;
  background: rgba(255,255,255,0.05); padding: 6px 12px; border-radius: 6px; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1); cursor: pointer;
}
.ext-link:hover { color: #fff; border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); }

.ai-box {
  margin-bottom: 16px; padding: 12px; border-radius: 8px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
  font-size: 13px; line-height: 1.5; color: #fff; text-align: left; cursor: pointer; transition: background 0.2s; position: relative;
}
.details-panel { background: rgba(255,255,255,0.03); border-top: 1px solid var(--border); }
.details-summary { padding: 16px; cursor: pointer; font-size: 13px; color: var(--muted); text-align: center; font-weight: 600; }
.details-body { padding: 0 20px 20px; text-align: left; }

.insight-grid { display: grid; gap: 12px; margin-bottom: 16px; }
.insight-box { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); text-align: left; }
.insight-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.insight-tags { display: flex; flex-wrap: wrap; gap: 6px; }
.tag { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #fff; }
.tag.good { background: rgba(16,185,129,0.2); color: var(--green); }
.tag.bad { background: rgba(239,68,68,0.2); color: var(--red); }
.tag.warn { background: rgba(251,191,36,0.2); color: var(--yellow); }
.tag.gem { background: rgba(34, 211, 238, 0.15); color: var(--diamond); border: 1px solid rgba(34,211,238,0.3); box-shadow: 0 0 5px rgba(34,211,238,0.2); }

.metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px; margin-top: 12px; }
.metric { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 10px; text-align: center; }
.metric-lbl { font-size: 9px; color: var(--muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
.metric-val { font-size: 13px; font-weight: 700; color: #fff; }

.keepa-embed img { max-width: 100%; height: auto; display: block; margin: 0 auto; border-radius: 8px; }

/* TOGGLES (Restored) */
.toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.toggle-switch {
  width: 44px; height: 24px; background: #333; border-radius: 99px; position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle-switch::after {
  content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: transform 0.2s;
}
.toggle-switch.active { background: var(--green); }
.toggle-switch.active::after { transform: translateX(20px); }

/* --- PAGES --- */
#settingsPage, #historyPage {
  position: fixed; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px;
  background: var(--bg); z-index: 3000; padding: 24px;
  display: flex; flex-direction: column; border-left: 1px solid var(--border); border-right: 1px solid var(--border);
}
.settings-header { font-size: 20px; font-weight: 800; margin-bottom: 24px; text-align: center; }
.settings-content { flex: 1; overflow-y: auto; }
.settings-group { margin-bottom: 24px; }
.label { display: block; font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--muted); text-transform: uppercase; }
.settings-input { width: 100%; padding: 14px; background: var(--panel); border: 1px solid var(--border); color: white; border-radius: 12px; font-family: 'JetBrains Mono', monospace; }
.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: auto; }
.btn-main { width: 100%; padding: 16px; border-radius: 12px; border: none; font-weight: 700; font-size: 14px; cursor: pointer; }
.btn-save { background: var(--green); color: #000; }
.btn-back { background: var(--panel); color: #fff; border: 1px solid var(--border); }

.actions {
  position: fixed; bottom: 0; left: 0; right: 0; background: rgba(5,5,5,0.95); backdrop-filter: blur(10px);
  padding: 16px; border-top: 1px solid var(--border); display: flex; gap: 12px; z-index: 100; max-width: 480px; margin: 0 auto;
}
.act-btn { flex: 1; padding: 14px; border: none; border-radius: 12px; font-weight: 700; font-size: 14px; cursor: pointer; transition: transform 0.1s; }
.act-btn:active { transform: scale(0.96); }
.btn-set { flex: 0 0 50px; background: var(--panel); color: #fff; border: 1px solid var(--border); display: grid; place-items: center; font-size: 20px; }
.btn-hist { background: var(--blue); color: #fff; }
.btn-dl { background: var(--green); color: #fff; }
.btn-cam { background: rgba(34,211,238,0.2); color: var(--diamond); border: 1px solid rgba(34,211,238,0.4); font-size: 18px; }

/* === UPGRADED DESIGN CSS === */
.item-title { 
  font-size: 18px !important; font-weight: 800 !important; color: #fff !important; line-height: 1.3 !important; 
  margin-bottom: 16px !important; text-align: center !important; padding: 0 20px !important; 
  min-height: 48px !important; display: flex !important; align-items: center !important; justify-content: center !important;
  height: auto !important; -webkit-line-clamp: unset !important;
}

/* Keepa Restricted Badge */
.keepa-restricted {
  position: absolute; top: 10px; right: 10px; background: rgba(239,68,68,0.2); border: 2px solid var(--red);
  color: var(--red); font-size: 10px; font-weight: 800; padding: 4px 10px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
  animation: pulse-badge 2s ease-in-out infinite;
}
@keyframes pulse-badge { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

/* Visual Meter Pricing */
.pricing-meter {
  background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px 12px 10px; margin-bottom: 12px;
}
.meter-row { margin-bottom: 12px; text-align: center; }
.meter-row:last-child { margin-bottom: 0; }
.meter-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; letter-spacing: 0.05em;
}
.meter-value {
  font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-bottom: 6px;
}
.meter-bar {
  height: 6px; background: rgba(255,255,255,0.05); border-radius: 99px; overflow: hidden; position: relative;
}
.meter-fill {
  height: 100%; border-radius: 99px; transition: width 0.3s ease;
}
.meter-fill.green { background: linear-gradient(90deg, var(--green), rgba(16,185,129,0.6)); }
.meter-fill.blue { background: linear-gradient(90deg, var(--blue), rgba(96,165,250,0.6)); }

/* Compact Sliders */
.adjusters-compact {
  background: rgba(0,0,0,0.2); border-radius: 10px; padding: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);
}
.adjuster-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.adjuster-row:last-child { margin-bottom: 0; }
.adjuster-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); min-width: 40px; letter-spacing: 0.05em;
}
.adjuster-slider { flex: 1; }
.adjuster-value {
  font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 700; color: var(--blue); min-width: 45px; text-align: right;
}

/* Why This Score Section */
.reasoning-section {
  background: rgba(255,255,255,0.03); border-radius: 10px; padding: 10px; margin-bottom: 10px;
}
.reasoning-header {
  font-size: 10px; font-weight: 800; text-transform: uppercase; color: var(--muted); margin-bottom: 8px;
  letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
}
.signal-item {
  display: flex; align-items: flex-start; gap: 6px; margin-bottom: 6px; padding: 6px;
  background: rgba(0,0,0,0.2); border-radius: 6px;
}
.signal-item:last-child { margin-bottom: 0; }
.signal-icon { font-size: 14px; flex-shrink: 0; margin-top: 0; }
.signal-text { flex: 1; }
.signal-text strong {
  display: block; font-size: 11px; font-weight: 700; margin-bottom: 2px; line-height: 1.3;
}
.signal-text p {
  font-size: 10px; color: var(--muted); line-height: 1.3; margin: 0;
}

/* Gemini Second Opinion */
.gemini-opinion {
  background: rgba(167,139,250,0.08); border: 2px solid rgba(167,139,250,0.3); border-radius: 12px;
  padding: 12px; margin-bottom: 12px;
}
.gemini-opinion.loading {
  background: rgba(96,165,250,0.08); border-color: rgba(96,165,250,0.3);
}
.gemini-opinion.upgrade {
  background: rgba(16,185,129,0.08); border-color: rgba(16,185,129,0.4);
}
.gemini-opinion.downgrade {
  background: rgba(239,68,68,0.08); border-color: rgba(239,68,68,0.4);
}
.gemini-header {
  display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px;
  padding-bottom: 12px; border-bottom: 1px solid var(--border);
}
.collapse-icon {
  color: rgba(255,255,255,0.5); cursor: pointer; font-size: 18px; font-weight: 800;
  padding: 4px 8px; transition: all 0.2s;
}
.collapse-icon:hover {
  color: rgba(255,255,255,0.9); background: rgba(255,255,255,0.1); border-radius: 4px;
}
.gemini-content.hidden {
  display: none;
}
.gemini-title {
  font-size: 12px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.05em;
  color: var(--purple); display: flex; align-items: center; gap: 6px;
}
.gemini-title.upgrade { color: var(--green); }
.gemini-title.downgrade { color: var(--red); }
.score-comparison {
  display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;
}
.score-box { text-align: center; }
.score-box-label {
  font-size: 9px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 4px; letter-spacing: 0.05em;
}
.score-box-value {
  font-size: 28px; font-weight: 800; font-family: 'JetBrains Mono', monospace; line-height: 1;
}
.score-box-value.amber { color: var(--yellow); }
.score-box-value.green { color: var(--green); }
.score-box-value.red { color: var(--red); }
.score-arrow { font-size: 24px; font-weight: 800; }
.score-arrow.up { color: var(--green); }
.score-arrow.down { color: var(--red); }
.gemini-verdict {
  text-align: center; font-size: 11px; font-weight: 800; padding: 6px 14px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
}
.gemini-verdict.upgrade {
  background: rgba(16,185,129,0.2); color: var(--green); border: 2px solid rgba(16,185,129,0.4);
}
.gemini-verdict.downgrade {
  background: rgba(239,68,68,0.2); color: var(--red); border: 2px solid rgba(239,68,68,0.4);
}
.gemini-text {
  font-size: 11px; line-height: 1.5; color: rgba(255,255,255,0.85); text-align: left;
}

/* Pricing Strategy Section (Concept 3 Style) */
.pricing-strategy {
  margin-bottom: 12px;
  background: rgba(96,165,250,0.06); border-radius: 12px;
  border: 2px solid rgba(96,165,250,0.3);
}

.pricing-strategy.wide-range {
  background: rgba(34,211,238,0.06); border-color: rgba(34,211,238,0.3);
}

.pricing-strategy.tight-range {
  background: rgba(251,191,36,0.06); border-color: rgba(251,191,36,0.3);
}

.pricing-strategy.fbm-driven {
  background: rgba(239,68,68,0.06); border-color: rgba(239,68,68,0.3);
}

.strategy-header {
  padding: 12px 14px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}

.strategy-title {
  display: flex; align-items: center; gap: 8px;
  font-size: 11px; font-weight: 800; text-transform: uppercase;
  letter-spacing: 0.05em; color: var(--blue);
}

.strategy-title.wide-range { color: var(--diamond); }
.strategy-title.tight-range { color: var(--yellow); }
.strategy-title.fbm-driven { color: var(--red); }

.strategy-icon {
  width: 28px; height: 28px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; border: 2px solid;
  background: rgba(96,165,250,0.15); border-color: var(--blue);
  color: var(--blue);
}

.strategy-icon.wide-range {
  background: rgba(34,211,238,0.15); border-color: var(--diamond);
  color: var(--diamond);
}

.strategy-icon.tight-range {
  background: rgba(251,191,36,0.15); border-color: var(--yellow);
  color: var(--yellow);
}

.strategy-icon.fbm-driven {
  background: rgba(239,68,68,0.15); border-color: var(--red);
  color: var(--red);
}

.strategy-body {
  padding: 12px 14px;
}

.strategy-type {
  font-size: 12px; font-weight: 700; margin-bottom: 8px;
}

.strategy-type.wide-range { color: var(--diamond); }
.strategy-type.tight-range { color: var(--yellow); }
.strategy-type.fbm-driven { color: var(--red); }

.strategy-details {
  font-size: 11px; color: rgba(255,255,255,0.8); line-height: 1.5;
  margin-bottom: 10px;
}

.price-range-display {
  background: rgba(0,0,0,0.3); border-radius: 8px;
  padding: 8px 10px; font-size: 11px; display: flex;
  justify-content: space-between; align-items: center;
}

.price-range-label {
  color: var(--muted); font-weight: 600;
}

.price-range-values {
  font-family: 'JetBrains Mono', monospace; font-weight: 700;
}

.price-range-min { color: var(--red); }
.price-range-max { color: var(--green); }
.price-range-separator { color: var(--muted); margin: 0 6px; }

.recommended-list-price {
  background: rgba(96,165,250,0.15); border-radius: 8px;
  padding: 10px; text-align: center; margin-top: 8px;
}

.list-price-label {
  font-size: 9px; font-weight: 700; text-transform: uppercase;
  color: var(--muted); margin-bottom: 4px; letter-spacing: 0.05em;
}

.list-price-value {
  font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace;
  color: var(--blue);
}

/* === DECISION TRACKING === */
.decision-section {
  background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.1);
  border-radius: 12px; padding: 12px; margin-top: 12px;
}

.decision-prompt {
  text-align: center; font-size: 11px; font-weight: 700;
  color: rgba(255,255,255,0.9); margin-bottom: 10px;
  text-transform: uppercase; letter-spacing: 0.05em;
}

.decision-buttons {
  display: flex; gap: 8px;
}

.decision-btn {
  flex: 1; padding: 10px 16px; border-radius: 10px;
  font-size: 13px; font-weight: 800; text-transform: uppercase;
  letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s;
  border: 2px solid; display: flex; align-items: center;
  justify-content: center; gap: 6px; background: transparent;
}

.decision-btn.buy {
  background: rgba(16,185,129,0.2); color: var(--green);
  border-color: rgba(16,185,129,0.5);
}

.decision-btn.buy:hover {
  background: rgba(16,185,129,0.3); border-color: var(--green);
  transform: translateY(-2px); box-shadow: 0 4px 12px rgba(16,185,129,0.3);
}

.decision-btn.buy:active {
  transform: scale(0.98);
}

.decision-btn.pass {
  background: rgba(239,68,68,0.2); color: var(--red);
  border-color: rgba(239,68,68,0.5);
}

.decision-btn.pass:hover {
  background: rgba(239,68,68,0.3); border-color: var(--red);
  transform: translateY(-2px); box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}

.decision-btn.pass:active {
  transform: scale(0.98);
}

.decision-btn.selected {
  animation: decisionPulse 0.5s ease;
}

@keyframes decisionPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.decision-note {
  text-align: center; font-size: 11px; color: #666;
  margin-top: 10px; font-style: italic;
}

.decision-note.success {
  color: var(--green); font-weight: 700;
}

.hidden { display: none !important; }

/* --- HISTORY & COLLAPSIBLE UI --- */
.history-item-wrapper {
    position: relative;
    margin-bottom: 10px; 
    border-radius: 10px;
    overflow: hidden;
    background: var(--panel);
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all 0.2s;
}

.history-item-content {
    padding: 12px;
    transition: transform 0.3s;
}

.delete-confirm-overlay {
    position: absolute;
    inset: 0;
    display: none; 
    background: rgba(248, 113, 113, 0.15);
    padding: 12px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
}

.delete-confirm-overlay.active {
    display: flex;
}

.delete-message {
    font-size: 13px;
    font-weight: 800;
    color: var(--red);
    margin-bottom: 10px;
}

.confirm-buttons {
    display: flex;
    gap: 10px;
    width: 100%;
}

.btn-delete-confirm {
    flex: 1;
    padding: 8px 12px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 12px;
    cursor: pointer;
    transition: transform 0.1s;
}

.btn-delete-confirm.cancel {
    background: var(--card);
    color: #fff;
    border: 1px solid var(--border);
}

.btn-delete-confirm.delete {
    background: var(--red);
    color: #fff;
    border: none;
}

/* --- PRICE DETAILS STYLES --- */
.price-metric-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 12px;
}

.price-metric-label {
    color: var(--muted);
    font-weight: 600;
}

.price-metric-value {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
}

.price-metric-value.fba { color: var(--green); }
.price-metric-value.fbm { color: var(--yellow); }
.price-metric-value.amz { color: var(--blue); }
.price-metric-value.none { color: var(--red); }


/* === SCORE EXPLANATION PANEL === */
#scoreExplanationPanel {
  background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px 15px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);
}
.score-details-header {
  font-size: 11px; font-weight: 800; text-transform: uppercase; color: var(--purple); margin-bottom: 10px;
  letter-spacing: 0.05em; display: flex; align-items: center; justify-content: space-between; cursor: pointer;
}
.score-details-content {
  font-size: 11px; line-height: 1.6; color: rgba(255,255,255,0.7);
  border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px;
}
.score-details-section {
    margin-bottom: 12px;
}
.score-details-section:last-child {
    margin-bottom: 0;
}
.score-details-title {
    font-size: 12px; font-weight: 700; color: var(--text); margin-bottom: 5px;
    display: flex; align-items: center; gap: 6px;
}
.score-details-metric-row {
    display: flex; justify-content: space-between; padding: 2px 0;
}
.metric-name {
    color: var(--muted);
    font-weight: 600;
}
.metric-value-num {
    font-weight: 700;
    color: var(--blue);
}
</style>
</head>
<body>

<div id="splash-screen">
    <div class="splash-bg">
        <img src="https://images.unsplash.com/photo-1521587760476-6c12a4b040da?w=1200&q=80" alt="">
    </div>
    <div class="splash-content">
        <h1 class="big-title">
            <span>PRETTY</span>
            <span>GOOD</span>
            <span>SOURCING</span>
            <span>APP</span>
        </h1>
        <div style="margin-top: 2rem; color: #60a5fa; letter-spacing: 0.2em; font-size: 0.9rem; font-weight: 700; text-shadow: 0 2px 10px rgba(96,165,250,0.5);">INITIALIZING...</div>
    </div>
</div>

<div class="app">
  <div id="mainView">
    <header>
      <div class="status-row">
        <div id="badgeKeepa" class="status-badge dead"><div class="status-dot"></div> Keepa</div>
        <div id="badgeGemini" class="status-badge dead"><div class="status-dot"></div> Gemini</div>
      </div>

      <div class="search-container">
        <div class="input-wrapper">
            <i class="fas fa-search search-icon"></i> 
            <input id="scanInput" type="text" placeholder="Type ISBN or Title, then search..." autocomplete="off" onkeyup="if(event.key === 'Enter') submitSearch()" />
        </div>
        <button id="btnSearch" class="icon-btn" onclick="submitSearch()" title="Search"><i class="fas fa-search"></i></button>
        <button id="btnLock" class="icon-btn" onclick="toggleFocusLock()" title="Focus Lock"><i class="fas fa-lock"></i></button>
      </div>
    </header>

    <div id="camera-overlay" class="hidden">
      <div id="camera-header">
        <div class="camera-title">üì∑ Scan Book</div>
        <div id="camera-status" class="camera-status">Ready to scan...</div>
        
        <div class="camera-mode-toggle">
          <button id="mode-barcode" class="mode-btn active" onclick="switchScanMode('barcode')">
            üìä Barcode
          </button>
          <button id="mode-isbn" class="mode-btn" onclick="switchScanMode('isbn')">
            üî¢ ISBN Text
          </button>
        </div>
      </div>
      
      <div id="reader"></div>
      
      <div class="scan-frame" id="scan-frame-barcode">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="scan-line"></div>
      </div>
      
      <div class="scan-frame isbn-frame hidden" id="scan-frame-isbn">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="isbn-hint">Position ISBN number here</div>
      </div>
      
      <div class="camera-footer">
        <button id="close-camera" onclick="stopCamera()">
          <i class="fas fa-times"></i> Close
        </button>
      </div>
    </div>

    <div id="processing" class="hidden" style="text-align:center; padding:60px;">
      <i class="fas fa-circle-notch fa-spin" style="font-size:32px; color:var(--blue);"></i>
    </div>

    <div id="scanToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:8px 16px; border-radius:99px; font-weight:bold; z-index:200;">
        Scan Detected!
    </div>

    <div id="exportToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:12px 20px; border-radius:99px; font-weight:bold; z-index:200; font-size:14px;">
        Export Complete!
    </div>

    <div class="card hidden" id="titlePickerCard">
      <div class="banner maybe">
        <div style="font-size:12px; font-weight:800; letter-spacing:0.12em; color:var(--muted); text-transform:uppercase; margin-bottom:10px;">
          Title results
        </div>
        <div style="font-size:14px; font-weight:800; margin-bottom:6px;">Pick an edition</div>
        <div id="titlePickerHint" style="font-size:12px; color:rgba(255,255,255,0.75); line-height:1.45; margin-bottom:14px;">
          Click the ID button to copy the ASIN/ISBN, then hit the Search button to fetch product data.
        </div>
        <div id="titlePickerList" style="text-align:left; margin-top:6px;"></div>
        <div style="display:flex; gap:10px; margin-top:14px; justify-content:center;">
          <button class="ext-link" onclick="closeTitlePicker()">Close ‚úñ</button>
        </div>
      </div>
    </div>


    <div class="card hidden" id="resultCard">
      <div id="banner" class="banner buy">
        <div id="keepaRestricted" class="keepa-restricted hidden">‚ö†Ô∏è RESTRICTED</div>
        
        <div id="gemIcon" class="gem-icon">üíé</div>
        
        <div style="text-align: center; margin-bottom: 6px;">
          <div id="categoryBadge" class="category-badge">üìö Category Loading...</div>
        </div>
        
        <div id="itemTitle" class="item-title">--</div>
        
        <div class="score-container">
          <svg class="score-svg" viewBox="0 0 100 100">
            <circle class="score-circle-bg" cx="50" cy="50" r="45" fill="none"></circle>
            <circle class="score-circle-fg" id="scoreRing" cx="50" cy="50" r="45" fill="none"></circle>
          </svg>
          <span id="confidence" class="score-num">--</span>
        </div>
        
        <div id="decision" class="decision-label">--</div>
      </div>
      
      <div style="padding: 16px;">
        <div id="geminiOpinion" class="hidden"></div>
        
        <div id="pricingStrategy" class="hidden"></div>
        
        <div id="scoreExplanationPanel">
            <div class="score-details-header" onclick="toggleScoreExplanation()">
                <span>üìä SCORE BREAKDOWN & MARKET INSIGHTS</span>
                <i id="scoreExplanationToggleIcon" class="fas fa-chevron-down"></i>
            </div>
            <div id="scoreExplanationContent" class="hidden">
                </div>
        </div>
        <div class="pricing-meter">
          <div class="meter-row">
            <div class="meter-label">Recommended Sell Price</div>
            <div class="meter-value" id="recommendedPrice" style="color: var(--blue);">$0.00</div>
            <div class="meter-bar">
              <div class="meter-fill blue" id="priceFill" style="width: 0%;"></div>
            </div>
          </div>
          
          <div class="meter-row">
            <div class="meter-label">Your Profit</div>
            <div class="meter-value" id="profitValue">$0.00</div>
            <div class="meter-bar">
              <div class="meter-fill green" id="profitFill" style="width: 0%;"></div>
            </div>
          </div>
        </div>

        <div class="condition-toggle">
          <div id="btnCondUsed" class="cond-btn active" onclick="setCondition('USED')">Used</div>
          <div id="btnCondNew" class="cond-btn" onclick="setCondition('NEW')">New</div>
        </div>

        <div class="adjusters-compact">
          <div class="adjuster-row">
            <span class="adjuster-label">Cost</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="50" step="0.25" value="1" id="sliderCost" />
            </div>
            <span class="adjuster-value" id="costValue">$1.00</span>
          </div>
          <div class="adjuster-row">
            <span class="adjuster-label">Floor</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="20" step="0.5" value="5" id="sliderFloor" />
            </div>
            <span class="adjuster-value" id="floorValue">$5.00</span>
          </div>
        </div>

        <div class="reasoning-section">
          <div class="reasoning-header">
            <span>üí°</span>
            <span>Why This Score?</span>
          </div>
          <div id="bbSummaryBox" style="background:rgba(96,165,250,0.1); border:1px solid var(--blue); padding:10px; border-radius:6px; margin-bottom:10px;">
              <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px; font-weight:700; color:var(--blue); margin-bottom:4px;">
                <span>CURRENT BUY BOX PRICE (<span id="bbCond">--</span>)</span>
                <span style="font-weight:800;" id="bbPriceVal">--</span>
              </div>
              <div id="bbStatusText" style="font-size:12px; line-height:1.4;">--</div>
          </div>
          <div id="reasoningContent"></div>
        </div>
        
        <div id="keepaGraphContainer" class="keepa-embed hidden">
          <div style="text-align:center; padding:10px; color:#333; font-size:12px;">Loading Graph...</div>
        </div>

        <div class="decision-section hidden" id="decisionSection">
          <div class="decision-prompt">üìã What's Your Decision?</div>
          <div class="decision-buttons">
            <button class="decision-btn buy" onclick="recordDecision('BOUGHT')">
              <span>‚úì</span>
              <span>BUY</span>
            </button>
            <button class="decision-btn pass" onclick="recordDecision('PASSED')">
              <span>‚úó</span>
              <span>REJECT</span>
            </button>
          </div>
          <div class="decision-note" id="decisionNote">Your decision will be saved with this scan</div>
        </div>

      </div>
    </div>
  </div>

  <div id="settingsPage" class="hidden">
    <div class="settings-header">Settings</div>
    <div class="settings-content">
      <div class="settings-group">
        <span class="label">Keepa API Key</span>
        <input type="password" id="keepaKey" class="settings-input" placeholder="Paste Keepa key..." />
      </div>

      <div class="settings-group">
        <span class="label">Gemini API Key</span>
        <input type="password" id="geminiKey" class="settings-input" placeholder="Paste Gemini API key..." />
      </div>
      
      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Use Proxy Server</span>
          <div id="toggleProxy" class="toggle-switch active" onclick="toggleSetting('useProxy')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Turn OFF if you have a CORS extension installed. Direct is faster.</div>
      </div>

      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Fast Scan (90 Days)</span>
          <div id="toggleFastScan" class="toggle-switch" onclick="toggleSetting('fastScan')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Fetches less data for speed. Good for live scanning.</div>
      </div>

      <div class="settings-group">
        <span class="label">Default Buy Cost ($)</span>
        <input type="number" id="defCost" class="settings-input" value="1.00" step="0.25" />
      </div>
      <div class="settings-group">
        <span class="label">Default Profit Floor ($)</span>
        <input type="number" id="defFloor" class="settings-input" value="5.00" step="0.50" />
      </div>
    </div>
    <div class="btn-grid">
      <button onclick="closeSettings()" class="btn-main btn-back">Cancel</button>
      <button onclick="saveSettings()" class="btn-main btn-save">Save</button>
    </div>
  </div>

  <div id="historyPage" class="hidden">
    <div class="settings-header">Scan History</div>
    <div id="historyStats" style="padding: 12px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; gap: 12px;">
      <div class="restricted-count" id="restrictedCount" style="display: none;">
        <span>üîí</span>
        <span id="restrictedCountText">0 restricted</span>
      </div>
      <button onclick="removeRestrictedItems()" id="btnRemoveRestricted" class="btn-remove-restricted" style="display: none;">
        Remove Restricted
      </button>
    </div>
    <div id="historyList" style="flex:1; overflow-y:auto;"></div>
    <div class="btn-grid" style="margin-top:16px;">
      <button onclick="closeHistory()" class="btn-main btn-back">Back</button>
      <button onclick="exportCSV()" class="btn-main btn-save">Download All CSV</button>
    </div>
    <button onclick="clearHistory()" class="btn-main" 
        style="background: transparent; color: var(--red); border: 1px solid var(--red); margin-top: 10px;">
        <i class="fas fa-trash"></i> Clear All History
    </button>
  </div>

  <div class="actions">
    <button onclick="showSettings()" class="act-btn btn-set"><i class="fas fa-cog"></i></button>
    <button onclick="showHistory()" class="act-btn btn-hist" style="flex: 2;">History</button>
    <button onclick="openCamera()" class="act-btn btn-cam"><i class="fas fa-camera"></i></button>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
let CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || '',
  geminiKey: localStorage.getItem('geminiKey') || '',
  buyCost: parseFloat(localStorage.getItem('buyCost')) || 1.00,
  profitFloor: parseFloat(localStorage.getItem('profitFloor')) || 5.00,
  condition: 'USED',
  useProxy: localStorage.getItem('useProxy') !== 'false', 
  fastScan: localStorage.getItem('fastScan') === 'true' 
};

let lastData = null;
let focusLock = false;
let scanQueue = [];
let scanHistory = JSON.parse(localStorage.getItem('scanHistory') || '[]');
let currentScan = null; // Tracks current scan for decision recording
let isProcessing = false;
let tokens = 20; 
let tokenRefill = setInterval(() => { if(tokens < 20) tokens++; updateTokenUI(); }, 3000); 

/* ================= INIT ================= */
const input = document.getElementById('scanInput');
const costSlider = document.getElementById('sliderCost');
const floorSlider = document.getElementById('sliderFloor');
const geminiReasoningHeader = document.getElementById('geminiReasoningHeader');

window.addEventListener('load', () => {
    updateTokenUI();
    resetSliders();
    updateConditionUI();
    updateToggleUI('toggleProxy', CONFIG.useProxy);
    updateToggleUI('toggleFastScan', CONFIG.fastScan);
    input.focus();
    
    document.addEventListener('click', (e) => {
        if(focusLock && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
            input.focus();
        }
    });
});

function resetSliders() {
    costSlider.value = CONFIG.buyCost;
    floorSlider.value = CONFIG.profitFloor;
    updateSliderDisplays();
}

function updateTokenUI() {
    const el = document.getElementById('badgeKeepa');
    if(CONFIG.keepaKey) {
        el.className = 'status-badge live';
        el.innerHTML = `<div class="status-dot"></div> Keepa: ${tokens}`;
    } else {
        el.className = 'status-badge dead';
        el.innerHTML = `<div class="status-dot"></div> Keepa`;
    }
}

function updateConditionUI() {
    document.getElementById('badgeGemini').className = CONFIG.geminiKey ? 'status-badge live' : 'status-badge dead';
}

function updateToggleUI(id, state) {
    const el = document.getElementById(id);
    if(el) {
        if(state) el.classList.add('active'); else el.classList.remove('active');
    }
}

function toggleSetting(key) {
    CONFIG[key] = !CONFIG[key];
    updateToggleUI(key === 'useProxy' ? 'toggleProxy' : 'toggleFastScan', CONFIG[key]);
}

/* ================= SLIDERS ================= */
function onSliderChange() {
  CONFIG.buyCost = parseFloat(costSlider.value);
  CONFIG.profitFloor = parseFloat(floorSlider.value);
  updateSliderDisplays();
  if(lastData) {
    const result = analyze(lastData);
    render(result, lastData);
  }
}
costSlider.addEventListener('input', onSliderChange);
floorSlider.addEventListener('input', onSliderChange);

/* ================= INPUT HANDLING / TITLE SEARCH (FIXED) ================= */
let titleResults = [];

async function submitSearch() {
    const val = input.value.trim();
    if(!val) return;

    // --- ENHANCED ID CHECK ---
    // Check if original has spaces - if so, likely a title unless it's a formatted ISBN
    const hasSpaces = /\s/.test(val);
    
    // Remove hyphens and spaces for validation
    const cleaned = val.replace(/[-\s]/g, '');
    const upper = cleaned.toUpperCase();
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(cleaned);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    // We prioritize ASIN because that's what Keepa search results return
    const is10DigitNumeric = /^\d{10}$/.test(cleaned);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(cleaned);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    const isISBN = isISBN13 || isISBN10WithX;
    
    // ASIN: 10 alphanumeric chars (including 10-digit all-numeric old ASINs)
    const isASIN = /^[A-Z0-9]{10}$/.test(upper) && !isISBN;
    
    // SAFETY: If it had spaces and isn't a valid ISBN/ASIN, treat as title
    const shouldSearchByTitle = hasSpaces && !isISBN && !isASIN;
    
    console.log('submitSearch:', { val, cleaned, upper, hasSpaces, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, isASIN, shouldSearchByTitle });
    
    if(shouldSearchByTitle) {
        console.log('Has spaces and not valid ID, searching as title:', val);
        input.value = ''; 
        await searchByTitle(val);
    } else if(isASIN || isISBN) {
        console.log('Detected as ID, adding to queue:', upper);
        closeTitlePicker(); 
        addToQueue(upper);
        input.value = '';
    } else {
        console.log('Detected as title, searching:', val);
        input.value = ''; 
        await searchByTitle(val);
    }
}

function normalizeTitleKey(s) {
    return (s || '').toLowerCase().replace(/\s+/g, ' ').trim();
}

function showTitlePickerLoading(query) {
    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Searching editions for: "${query}"`;
    list.innerHTML = `
      <div style="padding:12px; color:var(--muted); font-size:12px; display:flex; gap:10px; align-items:center;">
        <i class="fas fa-circle-notch fa-spin" style="color:var(--blue)"></i>
        <span>Looking up editions via Keepa...</span>
      </div>
    `;
    card.classList.remove('hidden');
    const keepaCard = document.getElementById('resultCard');
    if(keepaCard) keepaCard.classList.add('hidden');
}

// Function to handle the copying of the ISBN/ASIN
function copyIdAndFocus(id, title) {
    console.log('copyIdAndFocus called with:', { id, title });
    const inputField = document.getElementById('scanInput');
    
    // Copy to clipboard
    if (navigator.clipboard) {
        navigator.clipboard.writeText(id).catch(err => {
            console.error('Could not copy text: ', err);
        });
    }
    
    // Close the title picker
    closeTitlePicker();
    
    // Put the ID in the search field
    inputField.value = id;
    console.log('Input field set to:', inputField.value);
    
    // Automatically trigger the search
    console.log('Calling submitSearch...');
    submitSearch();
}


function renderTitlePicker(query, results) {
    isProcessing = false;
    const p = document.getElementById('processing');
    if (p) p.classList.add('hidden');

    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Select the right edition for: "${query}"`;
    card.classList.remove('hidden');

    const key = normalizeTitleKey(query);
    const lastKey = localStorage.getItem('lastTitlePickKey') || '';
    const lastIsbn = localStorage.getItem('lastTitlePickIsbn') || '';
    
    let sorted = [...results];
    if(lastKey && lastIsbn && lastKey === key) {
        const idx = sorted.findIndex(r => r.isbn === lastIsbn);
        if(idx > 0) {
            const [hit] = sorted.splice(idx, 1);
            sorted.unshift(hit);
        }
    }

    list.innerHTML = sorted.map((r) => {
        const thumb = r.thumbnail ? `<img src="${r.thumbnail}" alt="" style="width:44px;height:66px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,0.12);" />`
                                  : `<div style="width:44px;height:66px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.04);display:grid;place-items:center;color:rgba(255,255,255,0.25);font-size:14px;">${r.isbnType === 'BOOK' ? 'üìò' : 'üì¶'}</div>`;

        const pill = (lastKey === key && lastIsbn === r.isbn) ? `<span class="tag good" style="margin-left:8px;">Last Pick</span>` : '';
        const binding = String(r.editionLabel || 'Product').replace(/\b\w/g, c => c.toUpperCase());
        const idLabel = (r.isbnType === 'BOOK' && r.isbn.length >= 10 && r.isbn.length <= 13) ? 'ISBN' : 'ASIN/ID';
        
        const displayYear = r.published ? String(r.published).substring(0,4) : 'N/A';
        const safeTitle = escapeHtml(r.title || 'Unknown');
        const safeISBN = escapeHtml(r.isbn);


        return `
          <div style="display:flex; gap:12px; padding:12px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); border-radius:14px; margin-bottom:10px;">
            ${thumb}
            <div style="flex:1; min-width:0;">
              <div style="font-weight:800; font-size:13px; line-height:1.2; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${safeTitle}${pill}
              </div>
              <div style="font-size:11px; color:rgba(255,255,255,0.7); margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${escapeHtml(r.authors || '')} ${r.published ? ' ‚Ä¢ ' + displayYear : ''}
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                <span class="tag warn">${binding}</span>
                <span class="tag" style="background:rgba(96,165,250,0.15);color:var(--blue);border:1px solid rgba(96,165,250,0.25);">${idLabel}: ${safeISBN}</span>
              </div>
            </div>
            <button class="ext-link" style="align-self:flex-start; margin-top:5px; padding:8px 12px; font-size:11px; font-weight:700;" 
                    onclick="copyIdAndFocus('${safeISBN}', '${safeTitle}')" title="Run Analysis">
              Run Item <i class="fas fa-play"></i>
            </button>
          </div>
        `;
    }).join('');

    titleResults = sorted;
}

function closeTitlePicker() {
    const card = document.getElementById('titlePickerCard');
    if(card) card.classList.add('hidden');
    titleResults = [];
}

function fireKeepaFromTitle(encodedKey, encodedIsbn) {
    // This function is now OBSOLETE/NOT USED in v10.14, replaced by copyIdAndFocus
    // but kept as a placeholder if you wish to restore direct click search later.
    const key = decodeURIComponent(encodedKey || '');
    const isbn = decodeURIComponent(encodedIsbn || '');
    if(!isbn) return;

    localStorage.setItem('lastTitlePickKey', key);
    localStorage.setItem('lastTitlePickIsbn', isbn);

    closeTitlePicker();
    addToQueue(isbn); 
}

function escapeHtml(s) {
    return String(s ?? '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
}

async function searchByTitle(title) {
    console.log('searchByTitle called with:', title);
    
    if(!CONFIG.keepaKey) {
        alert("Keepa Error: API Key is missing. Please enter your key in Settings.");
        return;
    }

    try {
        document.getElementById('processing').classList.remove('hidden');
        showTitlePickerLoading(title);

        const url = `https://api.keepa.com/search?key=${CONFIG.keepaKey}&domain=1&type=product&term=${encodeURIComponent(title)}`;
        console.log('searchByTitle: Fetching from Keepa...', { useProxy: CONFIG.useProxy });
        
        const fetchKeepaSearch = async (u) => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 9000);
            try {
                let finalUrl = u;
                
                // Try with proxy if enabled
                if(CONFIG.useProxy) {
                    try {
                        finalUrl = `https://corsproxy.io/?${encodeURIComponent(u)}`;
                        console.log('Trying primary proxy...');
                        const res = await fetch(finalUrl, { signal: controller.signal });
                        if(res.ok) {
                            const json = await res.json();
                            if(!json.error) {
                                console.log('Primary proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                        // If proxy fails, try backup
                        console.log("Primary proxy failed for search, trying backup...");
                        finalUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`;
                        const res2 = await fetch(finalUrl, { signal: controller.signal });
                        if(res2.ok) {
                            const json = await res2.json();
                            if(!json.error) {
                                console.log('Backup proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                    } catch(proxyErr) {
                        console.log("Proxies failed, trying direct...", proxyErr);
                    }
                    // Fall through to direct if proxies fail
                    finalUrl = u;
                }
                
                // Direct fetch (or fallback from proxy failure)
                console.log('Trying direct fetch...');
                const res = await fetch(finalUrl, { signal: controller.signal });
                if(!res.ok) throw new Error(`HTTP ${res.status}`);
                const json = await res.json();
                
                if (json.error) throw new Error(json.error.message);
                console.log('Direct fetch success, got', json.products?.length, 'results');
                return json;
                
            } finally {
                clearTimeout(timeout);
            }
        };

        const data = await fetchKeepaSearch(url);
        
        if(!data.products || data.products.length === 0) {
            console.log('No products found');
            closeTitlePicker();
            document.getElementById('processing').classList.add('hidden');
            alert(`No products found for: "${title}" on Keepa.`);
            return;
        }

        console.log('Processing', data.products.length, 'products...');
        
        // --- Adapt Keepa results for Title Picker UI ---
        let results = data.products.map(p => {
            const authors = (p.manufacturer || p.brand || '').split(',').map(a => a.trim()).join(', ');
            const id = p.asin; 
            const pubDate = p.publicationDate || '';
            const thumbnail = p.images?.[0]?.url || null;

            if(!id) {
                console.warn('Product missing ASIN:', p);
            }

            return {
                title: p.title || 'Unknown',
                authors: authors,
                published: pubDate, 
                isbn: id, 
                isbnType: p.productType, 
                editionLabel: p.binding || p.productType, 
                pref: p.productType === 'BOOK' ? 5 : 1, 
                thumbnail: thumbnail
            };
        }).filter(r => r.isbn); // Filter out any without IDs
        
        const parseYear = (d) => {
            const m = String(d || '').match(/^(\d{4})/);
            return m ? parseInt(m[1], 10) : 0;
        };

        results.sort((a,b) => {
            if(b.pref !== a.pref) return b.pref - a.pref;
            return parseYear(b.published) - parseYear(a.published);
        });

        console.log('Rendering title picker with', results.length, 'results');
        renderTitlePicker(title, results);

    } catch(e) {
        console.error('searchByTitle error:', e);
        closeTitlePicker();
        alert(`Keepa Search Error: ${e.message}. \n\nTip: Check your API key and try toggling the Proxy setting.`);
    } finally {
        document.getElementById('processing').classList.add('hidden');
    }
}


function toggleFocusLock() {
    focusLock = !focusLock;
    document.getElementById('btnLock').classList.toggle('active', focusLock);
    if(focusLock) input.focus();
}

function addToQueue(query) {
    console.log('addToQueue:', query, 'Queue length:', scanQueue.length, 'isProcessing:', isProcessing);
    scanQueue.push(query);
    processQueue();
}

async function processQueue() {
    console.log('processQueue called. isProcessing:', isProcessing, 'Queue length:', scanQueue.length);
    if(isProcessing || scanQueue.length === 0) {
        console.log('processQueue exiting early:', { isProcessing, queueEmpty: scanQueue.length === 0 });
        return;
    }
    
    if(tokens <= 0) {
        setTimeout(processQueue, 3000);
        return;
    }

    isProcessing = true;
    const query = scanQueue.shift();
    
    document.getElementById('processing').classList.remove('hidden');
    document.getElementById('resultCard').classList.add('hidden');
    
    const safety = setTimeout(() => {
        if(isProcessing) {
            isProcessing = false;
            document.getElementById('processing').classList.add('hidden');
            alert("Scan Timed Out (Network too slow)");
        }
    }, 15000); // Increased timeout to 15s to allow for retries

    let attempts = 0;
    const maxAttempts = 2;
    const is10DigitNumeric = /^\d{10}$/.test(query.replace(/-/g,''));
    
    while(attempts < maxAttempts) {
        try {
            if(tokens > 0 && attempts === 0) tokens--; // Only decrement on first attempt
            updateTokenUI();
            
            // On second attempt for 10-digit numeric, try as ISBN instead of ASIN
            const retryAsISBN = (attempts === 1 && is10DigitNumeric);
            const data = await fetchKeepa(query, retryAsISBN);
            
            clearTimeout(safety);
            lastData = data;
            const result = analyze(data);
            render(result, data);
            addToHistory(result, data);
            
            // FIX #2: Clear input after camera scan so it doesn't block future scans
            setTimeout(() => {
                document.getElementById('scanInput').value = '';
            }, 100);
            
            break; // Success, exit retry loop
            
        } catch(e) {
            attempts++;
            console.log(`Attempt ${attempts} failed:`, e.message);
            
            // For 10-digit numeric codes, if first attempt (as ASIN) fails with "Product Not Found", try as ISBN
            if(attempts === 1 && is10DigitNumeric && e.message.includes("Product Not Found")) {
                console.log('10-digit numeric failed as ASIN, will retry as ISBN...');
                continue; // Retry immediately
            }
            
            if(attempts >= maxAttempts) {
                clearTimeout(safety);
                // More helpful error message based on error type
                let tipMsg = "Tip: Check your Keepa API Key and try toggling the Proxy setting.";
                if(e.message.includes("CORS")) {
                    tipMsg = "Tip: Try enabling 'Use Proxy Server' in Settings.";
                } else if(e.message.includes("Invalid product code") || e.message.includes("Product Not Found")) {
                    tipMsg = "Tip: This ISBN/ASIN may not exist in Amazon's catalog.";
                } else if(e.message.includes("HTTP 429")) {
                    tipMsg = "Tip: You may have exceeded Keepa's rate limit. Wait a moment and try again.";
                }
                alert(`Error: ${e.message}\n\n${tipMsg}`);
            } else {
                // Wait briefly before retry
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }
    
    isProcessing = false;
    document.getElementById('processing').classList.add('hidden');
    
    // --- FINAL AUTOSCROLL FIX (Double-Check Scroll) ---
    // Executes scrolling twice with a tiny delay to overcome browser resistance on mobile.
    setTimeout(() => {
        window.scrollTo({ top: 0, behavior: 'smooth' }); 
        
        // Secondary check right after the first one is registered
        setTimeout(() => {
            window.scrollTo({ top: 0, behavior: 'smooth' }); 
        }, 50); // Wait 50ms for the second check
    }, 10); // Start the process immediately after hiding the spinner
    // ----------------------------------------------------
    
    if(scanQueue.length > 0) setTimeout(processQueue, 2500);
}

function clearHistory() {
    if(!confirm('Clear all scan history? This cannot be undone.')) return;
    
    scanHistory = [];
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    const list = document.getElementById('historyList');
    if(list) list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
}

function clearScan() {
    input.value = '';
    document.getElementById('resultCard').classList.add('hidden');
    isProcessing = false;
    scanQueue = [];
    document.getElementById('processing').classList.add('hidden');
    input.focus();
}

/* ================= KEEPA API ================= */
async function fetchKeepa(query, retryAsISBN = false) {
    if(!CONFIG.keepaKey) throw new Error("No API Key");
    
    const clean = query.replace(/-/g,'');
    const days = 180; 
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(clean);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    const is10DigitNumeric = /^\d{10}$/.test(clean);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(clean);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    // OR if we're retrying a 10-digit numeric as ISBN
    const isISBN = isISBN13 || isISBN10WithX || (retryAsISBN && is10DigitNumeric);
    
    // Everything else is ASIN (including 10-digit all-numeric on first try)
    const paramName = isISBN ? 'code' : 'asin';
    
    let url = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=1&${paramName}=${clean}&stats=${days}&history=0`;
    
    console.log('fetchKeepa:', { query, clean, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, paramName, retryAsISBN, url: url.replace(CONFIG.keepaKey, 'KEY_HIDDEN') });

    // PROXY FAILOVER
    if(CONFIG.useProxy) {
        try {
            const proxy1 = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), 5000);
            
            const res = await fetch(proxy1, { signal: controller.signal });
            clearTimeout(id);
            if(res.ok) {
                const json = await res.json();
                return parseKeepaJson(json, true);
            }
        } catch(e) {
            console.log("Proxy 1 failed, trying backup...");
        }
        
        try {
            const proxy2 = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const res2 = await fetch(proxy2);
            if(!res2.ok) throw new Error("Proxy 2 failed");
            const json = await res2.json();
            return parseKeepaJson(json, true);
        } catch(e2) {
            console.log("Both proxies failed, trying direct fetch...");
        }
        
        // LAST RESORT: Try direct fetch (might fail due to CORS)
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e3) {
            throw new Error("Connection Failed: All proxies down and direct fetch blocked by CORS. Try disabling 'Use Proxy Server' in Settings.");
        }
        
    } else {
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e) {
            throw new Error(`Failed to fetch from Keepa: ${e.message}`);
        }
    }
}

function parseKeepaJson(json, isID) {
    console.log('parseKeepaJson called with:', json);
    if(json.error) throw new Error(json.error.message);
    let product;
    if(!json.products || !json.products.length) {
        console.error('Keepa returned no products. Full response:', json);
        throw new Error("Product Not Found - Keepa returned no products for this ID");
    }
    product = json.products[0];
    
    return parseProduct(product);
}

/* ================= PRICE HISTORY PARSER ================= */
function calculatePriceRange(priceHistory, daysBack = 90) {
    // Keepa price history format: [timestamp1, price1, timestamp2, price2, ...]
    // Timestamps are in "Keepa time" (minutes since epoch 2011-01-01)
    // Prices are in cents, or -1 for no data
    
    if (!priceHistory || priceHistory.length < 2) {
        return { min: 0, max: 0, spread: 0, hasData: false };
    }
    
    const now = Date.now();
    const cutoffTime = now - (daysBack * 24 * 60 * 60 * 1000);
    const keepaEpoch = new Date('2011-01-01').getTime();
    
    let minPrice = Infinity;
    let maxPrice = -Infinity;
    let validPrices = 0;
    
    // Iterate through pairs: [time, price, time, price, ...]
    for (let i = 0; i < priceHistory.length; i += 2) {
        const keepaTime = priceHistory[i];
        const priceValue = priceHistory[i + 1];
        
        // Convert Keepa time to JS timestamp
        const timestamp = keepaEpoch + (keepaTime * 60 * 1000);
        
        // Only consider prices within our time window
        if (timestamp >= cutoffTime && priceValue > 0) {
            const price = priceValue / 100; // Convert cents to dollars
            minPrice = Math.min(minPrice, price);
            maxPrice = Math.max(maxPrice, price);
            validPrices++;
        }
    }
    
    if (validPrices === 0 || minPrice === Infinity) {
        return { min: 0, max: 0, spread: 0, hasData: false };
    }
    
    return {
        min: minPrice,
        max: maxPrice,
        spread: maxPrice - minPrice,
        hasData: true
    };
}

function parseProduct(p) {
    const s = p.stats.current;
    const avg = p.stats.avg90 || [];
    const toPrice = (v) => (v && v > 0) ? v / 100 : 0;
    const toVal = (v) => (v == -1 || v == null) ? 0 : v;
    
    // Check for restriction flag
    // productType: 0 = standard, 1 = restricted, 2 = meltable
    const isRestricted = p.productType === 1 || 
                       p.hazMat === 1 || 
                       (p.title && /international edition|instructor|review copy|not for resale|teacher edition/i.test(p.title));
    
    // --- START: NEW BUY BOX INFERENCE LOGIC (FIXED) ---
    let inferredBbPrice = 0;
    let bbOwnerType = 'SUPPRESSED'; // Default: No offers or BB available

    const keepaBb = toPrice(s[18]); // Explicit Keepa BB price
    const fbaPrice = toPrice(s[10]);
    const usedPrice = toPrice(s[2]); // Lowest MF Used price
    const fbaCount = toVal(s[16]) || 0;
    const amzPrice = toPrice(s[0]);

    if (keepaBb > 0) {
        // CASE 1: Explicit Buy Box (Highest confidence)
        inferredBbPrice = keepaBb;
        bbOwnerType = (amzPrice > 0 && Math.abs(amzPrice - keepaBb) < 0.05) ? 'AMZ' : 'EXPLICIT_BB';
    } else if (fbaCount > 0 && fbaPrice > 0) {
        // CASE 2: FBA Rotation (MOST BOOKS LIVE HERE)
        // If FBA offers exist, the effective BB is the lowest FBA price.
        inferredBbPrice = fbaPrice;
        bbOwnerType = 'ROTATING_FBA';
    } else if (usedPrice > 0) {
        // CASE 3: FBM/MF-driven Buy Box (Lowest offer price if no FBA)
        // We use usedPrice as proxy for lowest FBM price.
        inferredBbPrice = usedPrice;
        bbOwnerType = 'FBM_PRICE_DRIVEN';
    }
    // --- END: NEW BUY BOX INFERENCE LOGIC ---
    
    // --- START: BUY BOX PRICE RANGE ANALYSIS (90 DAYS) ---
    const bbPriceRange = calculatePriceRange(p.csv?.[18] || [], 90); // csv[18] = Buy Box price history
    
    // Determine strategy type based on spread
    let strategyType = 'TIGHT_RANGE';
    let pricingNotes = '';
    
    if (!bbPriceRange.hasData) {
        strategyType = 'NO_HISTORY';
        pricingNotes = 'Insufficient price history';
    } else if (bbPriceRange.spread >= 5 && bbPriceRange.spread / bbPriceRange.min >= 0.20) {
        // Wide range: $5+ spread AND 20%+ variation
        strategyType = 'WIDE_RANGE';
        pricingNotes = `Wide pricing range ($${bbPriceRange.min.toFixed(2)}-$${bbPriceRange.max.toFixed(2)}). Start high, lower gradually.`;
    } else if (bbOwnerType === 'FBM_PRICE_DRIVEN') {
        strategyType = 'FBM_DRIVEN';
        pricingNotes = 'FBM controls Buy Box. Must match lowest price to compete.';
    } else {
        // Tight range
        pricingNotes = `Tight pricing ($${bbPriceRange.min.toFixed(2)}-$${bbPriceRange.max.toFixed(2)}). Match competitive FBA price.`;
    }
    
    // Calculate FBA premium if applicable
    const fbaPremium = (fbaPrice > 0 && usedPrice > 0 && fbaPrice > usedPrice) ? {
        exists: true,
        amount: fbaPrice - usedPrice,
        percentage: Math.round(((fbaPrice - usedPrice) / usedPrice) * 100)
    } : {
        exists: false,
        amount: 0,
        percentage: 0
    };
    // --- END: BUY BOX PRICE RANGE ANALYSIS ---
    
    return {
        title: p.title || "Unknown",
        asin: p.asin,
        isbn: p.eanList?.[0] || '',
        rank: toVal(s[3]),
        avgRank: toVal(avg[3]),
        drops30: p.stats.salesRankDrops30 || 0,
        drops90: p.stats.salesRankDrops90 || 0,
        drops180: p.stats.salesRankDrops180 || 0,
        drops360: p.stats.salesRankDrops360 || 0,
        newPrice: toPrice(s[1]),
        usedPrice: usedPrice, 
        fbaPrice: fbaPrice,   
        amzPrice: amzPrice,
        buyBoxPrice: keepaBb,
        // --- NEW/UPDATED FIELDS ---
        inferredBbPrice: inferredBbPrice,
        bbOwnerType: bbOwnerType,
        bbPriceRange: bbPriceRange,
        strategyType: strategyType,
        pricingNotes: pricingNotes,
        fbaPremium: fbaPremium,
        // -------------------------
        avgNew: toPrice(avg[1]),
        avgUsed: toPrice(avg[2]),
        avgBb: toPrice(avg[18]),
        weight: p.packageWeight ? p.packageWeight / 100 : 1,
        fbaCount: fbaCount,
        totalOffers: toVal(s[11]) || 0,
        category: p.categoryTree?.[0]?.name || 'Unknown',
        reviewCount: p.reviewCount || 0,
        rating: p.rating || 0,
        restricted: isRestricted
    };
}

/* ================= CATEGORY ICON HELPER ================= */
function getCategoryIcon(category) {
    const cat = (category || '').toLowerCase();
    
    if(cat.includes('book')) return 'üìö';
    if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) return 'üíø';
    if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray') || cat.includes('movie')) return 'üé¨';
    if(cat.includes('video game') || cat.includes('game')) return 'üéÆ';
    if(cat.includes('toy')) return 'üß∏';
    if(cat.includes('electronic')) return 'üì±';
    if(cat.includes('home') || cat.includes('kitchen')) return 'üè†';
    if(cat.includes('sport')) return '‚öΩ';
    if(cat.includes('clothing') || cat.includes('apparel')) return 'üëï';
    if(cat.includes('health') || cat.includes('beauty')) return 'üíä';
    
    return 'üì¶'; // Default for unknown categories
}

/* ================= CATEGORY-AWARE RANK THRESHOLDS ================= */
function getRankThresholds(category) {
    const cat = (category || '').toLowerCase();
    
    // Each category has different rank scales
    if(cat.includes('book')) {
        return { good: 500000, decent: 2000000, poor: 5000000 };
    } else if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) {
        return { good: 200000, decent: 800000, poor: 2000000 };
    } else if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray')) {
        return { good: 300000, decent: 1200000, poor: 3000000 };
    } else if(cat.includes('video game')) {
        return { good: 100000, decent: 500000, poor: 1500000 };
    } else if(cat.includes('toy')) {
        return { good: 300000, decent: 1500000, poor: 4000000 };
    } else {
        // Default for unknown categories
        return { good: 500000, decent: 2000000, poor: 5000000 };
    }
}

/* ================= CATEGORY-AWARE FEE CALCULATION ================= */
function calculateFees(price, weight, category) {
    const closingFee = 1.80;
    let referralFee = 0;
    let fulfillmentFee = 0;
    
    // Determine category type
    const cat = (category || '').toLowerCase();
    const isBooks = cat.includes('book');
    const isMedia = cat.includes('music') || cat.includes('video') || cat.includes('dvd') || cat.includes('cd') || cat.includes('vinyl') || cat.includes('blu-ray');
    const isGames = cat.includes('game') || cat.includes('toy');
    
    // REFERRAL FEES (Amazon's cut)
    if(isBooks) {
        referralFee = price * 0.15; // 15% for books
    } else if(isMedia) {
        referralFee = price * 0.15; // 15% for media
    } else if(isGames) {
        referralFee = price * 0.15; // 15% for toys & games
    } else {
        referralFee = price * 0.15; // Default 15%
    }
    
    // FULFILLMENT FEES (FBA shipping/handling)
    if(isBooks) {
        // Books: weight-based
        if(weight <= 0.5) fulfillmentFee = 3.07;
        else if(weight <= 1) fulfillmentFee = 3.37;
        else if(weight <= 2) fulfillmentFee = 4.16;
        else if(weight <= 3) fulfillmentFee = 5.32;
        else fulfillmentFee = 5.32 + ((weight - 3) * 0.38);
    } else if(isMedia) {
        // Media: standard + weight
        if(weight <= 0.5) fulfillmentFee = 2.92;
        else if(weight <= 1) fulfillmentFee = 3.16;
        else if(weight <= 2) fulfillmentFee = 3.74;
        else fulfillmentFee = 3.74 + ((weight - 2) * 0.38);
    } else {
        // Other: standard small/large item
        if(weight <= 1) fulfillmentFee = 3.22;
        else if(weight <= 2) fulfillmentFee = 4.40;
        else fulfillmentFee = 4.40 + ((weight - 2) * 0.38);
    }
    
    return closingFee + referralFee + fulfillmentFee;
}

/* ================= ANALYSIS (UPGRADED TO BUY/CONSIDER/REJECT) ================= */
function analyze(data) {
    // --- 1. MARKET PRICE SELECTION (Condition-Aware) ---
    let market = 0;
    const newBuyBox = data.newPrice || data.amzPrice || 999999;
    
    if(CONFIG.condition === 'NEW') {
        // For NEW condition, use new price or inferred BB (which should be new pricing)
        market = data.newPrice || data.inferredBbPrice || data.avgBb || 0;
    } else {
        // For USED condition, use used price or inferred BB (if it's used-based)
        market = data.usedPrice || data.inferredBbPrice || data.avgBb || 0;
    }
    
    // Ceiling Check (used price shouldn't beat new)
    if(CONFIG.condition === 'USED' && market > newBuyBox) {
        market = newBuyBox * 0.95;
    }
    
    // Final safety check: ensure price is at least a minimum for meaningful calculation
    market = Math.max(10.00, market);

    // --- 2. PROFIT & FEES CALCULATION ---
    const fees = calculateFees(market, data.weight, data.category);
    const profit = market - fees - CONFIG.buyCost;
    
    let verdict = 'CONSIDER';
    let score = 50;
    let isGem = false;
    let allTags = [];
    
    const thresholds = getRankThresholds(data.category);
    
    // --- 3. BASE SCORING & GEM LOGIC (Modified) ---
    
    // GEM TRIGGERS (Keepa flags & Heuristics)
    const isSleeper = (data.drops30 === 0 && market > 35);
    const isFbaVoid = (data.fbaCount === 0 && data.avgRank < thresholds.decent && profit > 10); // Use fbaCount
    const isDip = (data.usedPrice > 0 && data.avgUsed > 0 && data.usedPrice < (data.avgUsed * 0.4) && profit > 5);
    const isTextbook = (data.newPrice > 80 && data.usedPrice < 20 && data.category && data.category.toLowerCase().includes('book'));
    const isRare = (data.avgRank !== -1 && data.avgRank < thresholds.poor && data.totalOffers < 3 && market > 20);
    const isSprinter = (data.drops30 > 3 && data.drops30 > (data.drops90/3 * 1.5)); 
    const isPhantom = (data.totalOffers > 50 && market > 15);
    const isFbaPrem = (data.fbaPrice > 0 && data.usedPrice > 0 && data.fbaPrice > (data.usedPrice * 1.4) && Math.abs(data.fbaPrice - data.inferredBbPrice) < 2); 

    // TAGS
    if(isSleeper) { allTags.push({text: "üíé Patience for Big Payout", type: "gem"}); }
    if(isFbaVoid) { allTags.push({text: "üíé Zero FBA Offers", type: "gem"}); }
    if(isDip)     { allTags.push({text: "üíé Buy The Dip", type: "gem"}); }
    if(isTextbook){ allTags.push({text: "üíé Sell Cheaper Used Textbook", type: "gem"}); }
    if(isRare)    { allTags.push({text: "üíé Low Comp Rewards", type: "gem"}); }
    if(isSprinter){ allTags.push({text: "üíé Picking Up Pace", type: "gem"}); }
    if(isPhantom) { allTags.push({text: "üíé Crowded But Fine", type: "gem"}); }
    if(isFbaPrem) { allTags.push({text: "üíé FBA Premium", type: "gem"}); }

    // --- 4. CORE SCORE CALCULATION (USING REWEIGHTING) ---
    
    // Initialize score breakdown variables (always defined)
    let velocityScore = 0;
    let bbScore = 0;
    let compScore = 0;
    let bbConfidence = 0.0;
    
    // A. PROFIT FLOOR CHECK (CRITICAL)
    if(profit < CONFIG.profitFloor) {
        verdict = 'REJECT';
        score = Math.round(Math.max(0, 40 - (CONFIG.profitFloor - profit)));
        isGem = false; // Cannot be a gem with low profit
    } else {
        // B. BASE VELOCITY SCORE
        if(data.drops30 >= 10) velocityScore = 20;
        else if(data.drops30 >= 5) velocityScore = 14;
        else if(data.drops30 >= 1) velocityScore = 6;
        else if(data.drops180 > 0) velocityScore = 2; // Historical sales
        else velocityScore = 0; // Truly dead
        
        // C. BUY BOX SCORE (NEW: +15 for FBA rotation)
        if (data.bbOwnerType === 'EXPLICIT_BB') { bbScore = 18; bbConfidence = 1.0; }
        else if (data.bbOwnerType === 'ROTATING_FBA') { bbScore = 15; bbConfidence = 0.85; }
        else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') { bbScore = 5; bbConfidence = 0.6; }
        else { bbScore = -15; bbConfidence = 0.0; } // Truly suppressed / No offers

        // D. COMPETITION SCORE (NEW: +10 for 0 FBA)
        if(data.fbaCount === 0) compScore = 10;
        else if(data.fbaCount <= 2) compScore = 6;
        else if(data.fbaCount <= 5) compScore = 2;
        else compScore = -4;

        // E. CALCULATE BASE SCORE
        score = 50 + velocityScore + bbScore + compScore;
        
        // F. APPLY RESTRICTION PENALTY (BEFORE VERDICT)
        if(data.restricted) { 
            score = score - 8; // Soft penalty applied before verdict
        }
        
        // G. CLAMP SCORE TO 0-100 RANGE
        score = Math.round(Math.max(0, Math.min(100, score)));

        // H. FINAL VERDICT ASSIGNMENT (Based on adjusted score)
        if (score >= 75) {
            verdict = 'BUY';
            // Gems are BUY-tier items (75+) with hidden opportunity characteristics
            if (allTags.filter(t => t.type === 'gem').length > 0) {
                isGem = true;
            }
        } else if (score >= 50) {
            verdict = 'CONSIDER';
        } else {
            verdict = 'REJECT';
        }
    }
    
    // --- 5. TAG GENERATION (Cleaned up) ---
    
    // BB AWARE TAGS
    if (data.bbOwnerType === 'SUPPRESSED') {
        allTags.push({text: "BB Suppressed/Unavailable", type: "bad"});
    } else if (data.bbOwnerType === 'ROTATING_FBA') {
        allTags.push({text: "BB Rotating - FBA is key", type: "good"});
    } else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') {
        allTags.push({text: "FBM Buy Box - Highly Price Sensitive", type: "warn"});
    }
    
    if (data.amzPrice > 0 && Math.abs(data.amzPrice - data.inferredBbPrice) < 0.05) {
        allTags.push({text: "BB Held by Amazon", type: "bad"});
    }

    // RESTRICTION TAG (penalty already applied to score above)
    if(data.restricted) { 
        allTags.push({text: "‚ö†Ô∏è Restricted Item - Check Seller Central", type: "warn"});
    }

    // Sales/Rank/Profit Tags
    if(data.drops30 > 5) allTags.push({text: "Good Velocity", type: "good"});
    if(data.avgRank !== -1 && data.avgRank < 500000) allTags.push({text: "Solid Rank", type: "good"});
    if(data.avgRank > 2000000) allTags.push({text: "High Rank", type: "bad"});

    if(profit >= CONFIG.profitFloor) allTags.push({text: "Profitable", type: "good"});
    if(profit < 0) allTags.push({text: "Negative Profit", type: "bad"});
    else if(profit < CONFIG.profitFloor) allTags.push({text: "Thin Margins", type: "warn"});
    
    if(data.drops30 === 0 && data.drops180 === 0) allTags.push({text: "0 Sales (180d)", type: "bad"});
    if(market < 10) allTags.push({text: "Low Value Item", type: "warn"});
    
    const posTags = allTags.filter(t => t.type === 'good' || t.type === 'gem');
    const negTags = allTags.filter(t => t.type === 'bad' || t.type === 'warn');
    
    if(posTags.length === 0) posTags.push({text: "None", type: "warn"});
    if(negTags.length === 0) negTags.push({text: "None", type: "good"});

    return { 
        verdict, 
        profit, 
        score: Math.round(score), 
        market, 
        posTags, 
        negTags, 
        isGem,
        // FIXED: Expose all breakdown metrics for the explanation panel
        breakdown: { 
            velocityScore, 
            bbScore, 
            compScore, 
            // Calculate penalty amount for the breakdown UI
            profitPenalty: profit < CONFIG.profitFloor ? (CONFIG.profitFloor - profit) : 0 
        }
    };
}

/* ================= RENDER (SAFE MODE) ================= */
function render(res, data) {
    // FAIL-SAFE HELPER
    const setText = (id, val) => {
        const el = document.getElementById(id);
        if(el) el.innerText = val;
    };

    const card = document.getElementById('resultCard');
    const banner = document.getElementById('banner');
    const decisionEl = document.getElementById('decision');
    
    // Update banner and verdict
    banner.className = `banner ${res.isGem ? 'gem' : res.verdict.toLowerCase()}`;
    setText('confidence', res.score);
    setText('decision', res.verdict);
    if(decisionEl) {
        decisionEl.className = `decision-label ${res.verdict.toLowerCase()}`;
    }
    
    // Show/hide gem icon
    document.getElementById('gemIcon').classList.toggle('visible', res.isGem);
    
    // Show/hide Keepa restricted badge
    const restrictedBadge = document.getElementById('keepaRestricted');
    if(restrictedBadge) {
        restrictedBadge.classList.toggle('hidden', !data.restricted);
    }
    
    // Update score ring
    const offset = 283 - (283 * res.score / 100);
    const ring = document.getElementById('scoreRing');
    if(ring) {
        ring.style.strokeDashoffset = offset;
        if(res.isGem) ring.style.color = 'var(--diamond)';
        else if(res.verdict === 'BUY') ring.style.color = 'var(--green)';
        else if(res.verdict === 'CONSIDER') ring.style.color = 'var(--yellow)';
        else ring.style.color = 'var(--red)';
    }

    // Update book title
    setText('itemTitle', data.title);
    
    // Update category badge
    const categoryBadge = document.getElementById('categoryBadge');
    if(categoryBadge) {
        const cat = data.category || 'Unknown';
        const icon = getCategoryIcon(cat);
        categoryBadge.textContent = `${icon} ${cat}`;
    }
    
    // Update visual meter pricing (NO + SIGNS!)
    const maxPrice = Math.max(res.market, 100);
    const pricePercent = Math.min(100, (res.market / maxPrice) * 100);
    const profitPercent = Math.min(100, Math.max(0, (res.profit / (res.market || 1)) * 100));

    setText('recommendedPrice', '$' + res.market.toFixed(2));
    const priceFill = document.getElementById('priceFill');
    if(priceFill) priceFill.style.width = pricePercent + '%';

    const profitValue = document.getElementById('profitValue');
    if(profitValue) {
        profitValue.textContent = '$' + res.profit.toFixed(2);
        profitValue.style.color = res.profit >= 0 ? 'var(--green)' : 'var(--red)';
    }
    const profitFill = document.getElementById('profitFill');
    if(profitFill) profitFill.style.width = profitPercent + '%';

    // Update slider displays
    updateSliderDisplays();

    // --- Buy Box Status and Price Update (FIXED) ---
    const isUsedCondition = CONFIG.condition === 'USED';
    const bbPrice = data.inferredBbPrice;
    const bbOwner = data.bbOwnerType;
    const bbPriceValEl = document.getElementById('bbPriceVal');
    const bbCondEl = document.getElementById('bbCond');
    const bbStatusText = document.getElementById('bbStatusText');
    let bbOwnerText = "";
    let bbColor = "var(--red)";

    // Inject historical context warning if live BB is very low
    let historicalContext = '';
    const recommended = res.market;
    
    // NEW CLARIFICATION LOGIC
    // Check if the recommended price is significantly higher than the live BB/inferred price.
    // Use a $5 margin and a 50% ratio as threshold for a strong warning.
    if (bbPrice > 0 && recommended > (bbPrice + 5.00) && recommended > (bbPrice * 1.5)) {
        historicalContext = `
            <span style="color:var(--yellow); font-weight:800; display:block; margin-top: 5px;">
                ‚ö†Ô∏è Market Anomaly Detected:
            </span>
            <span style="font-size:11px; line-height:1.4; color:rgba(255,255,255,0.8);">
                The current \$${bbPrice.toFixed(2)} price is being ignored for profitability because it's severely underpriced. The Recommended Sell Price (\$${recommended.toFixed(2)}) is based on higher historical Buy Box averages for the ${CONFIG.condition.toLowerCase()} condition.
            </span>
        `;
    } else if (bbPrice > 0 && recommended > (bbPrice + 1.00)) {
        // Keep the mild warning if the price is just slightly higher
        historicalContext = `<span style="color:var(--yellow); font-weight:800; display:block; margin-top: 5px;">‚ö†Ô∏è Recommended price (\$${recommended.toFixed(2)}) is based on higher historical sales data.</span>`;
    }

    if (bbPrice > 0) {
        bbCondEl.innerText = CONFIG.condition === 'USED' ? 'USED' : 'NEW';
        
        if (bbOwner === 'ROTATING_FBA' || bbOwner === 'EXPLICIT_BB') {
            bbColor = 'var(--green)';
            if (bbOwner === 'ROTATING_FBA') {
                // FIXED TEXT: Informative, not mandatory
                bbOwnerText = `<span style="color:var(--green); font-weight:800;">FBA Rotation Buy Box.</span> This price reflects the current lowest FBA offer.`;
            } else if (data.amzPrice > 0 && Math.abs(data.amzPrice - bbPrice) < 0.05) {
                bbColor = 'var(--blue)';
                bbOwnerText = `<span style="color:var(--blue); font-weight:800;">Amazon</span> holds the Buy Box.`;
            } else {
                bbOwnerText = `<span style="color:var(--green); font-weight:800;">Explicit Buy Box.</span> A single FBA/MF seller currently wins.`;
            }
        } else if (bbOwner === 'FBM_PRICE_DRIVEN') {
            bbColor = 'var(--yellow)';
            // FIXED TEXT: Informative, not mandatory
            bbOwnerText = `<span style="color:var(--yellow); font-weight:800;">FBM/MF Buy Box.</span> Competition is price-sensitive and driven by the lowest merchant-fulfilled offer.`;
        }

        // Update BB status text
        bbStatusText.innerHTML = `${bbOwnerText} The current price is $${bbPrice.toFixed(2)}.${historicalContext}`;
    } else {
        // CASE: Truly Suppressed / No Offers
        bbCondEl.innerText = CONFIG.condition === 'USED' ? 'USED' : 'NEW';
        bbStatusText.innerHTML = `<span style="color:var(--red); font-weight:800;">Buy Box is truly suppressed or no offers exist.</span> Pricing is based on historical averages.${historicalContext}`;
    }

    if (bbPriceValEl) {
      bbPriceValEl.innerText = bbPrice > 0 ? `$${bbPrice.toFixed(2)}` : 'N/A';
      bbPriceValEl.style.color = bbColor;
    }
    // --- End Buy Box Status Update ---


    // Render the new score explanation panel
    renderScoreExplanation(res, data);


    // Build "Why This Score?" reasoning section
    const reasoningContent = document.getElementById('reasoningContent');
    if(reasoningContent) {
        const signals = [];
        
        // Signal descriptions mapping
        const getSignalInfo = (tagText, isPositive) => {
            const tag = tagText.toLowerCase();
            
            // Positive signals
            if(tag.includes('velocity')) return {
                icon: 'üöÄ',
                desc: `${data.drops30} sales in 30 days shows strong demand. Items moving this fast typically sell within weeks.`
            };
            if(tag.includes('patience for big payout')) return {
                icon: 'üíé',
                desc: `No recent sales but worth $${res.market.toFixed(2)}. Patient sellers can capitalize when demand returns.`
            };
            if(tag.includes('zero fba')) return {
                icon: 'üíé',
                desc: `No FBA competition despite ${data.avgRank < 1000000 ? 'good' : 'decent'} rank. You could dominate Buy Box.`
            };
            if(tag.includes('buy the dip')) return {
                icon: 'üíé',
                desc: `Current price ($${data.usedPrice.toFixed(2)}) is ${Math.round((1 - data.usedPrice/data.avgUsed) * 100)}% below 90-day average. Undervalued opportunity.`
            };
            if(tag.includes('sell cheaper used textbook')) return {
                icon: 'üíé',
                desc: `Expensive new ($${data.newPrice.toFixed(2)}) vs cheap used ($${data.usedPrice.toFixed(2)}). Classic textbook arbitrage play.`
            };
            if(tag.includes('low comp')) return {
                icon: 'üíé',
                desc: `Only ${data.totalOffers} total sellers with decent rank. Less competition = easier sales.`
            };
            if(tag.includes('picking up pace')) return {
                icon: 'üíé',
                desc: `Recent velocity accelerating. ${data.drops30} sales in 30d vs ${Math.round(data.drops90/3)} expected shows momentum.`
            };
            if(tag.includes('crowded but fine')) return {
                icon: 'üíé',
                desc: `${data.totalOffers} sellers seems high, but worth $${res.market.toFixed(2)} with profit above floor. Volume market.`
            };
            if(tag.includes('fba premium')) return {
                icon: 'üíé',
                desc: `FBA price ($${data.fbaPrice.toFixed(2)}) is ${Math.round((data.fbaPrice/data.usedPrice - 1) * 100)}% above MF. Prime customers pay more.`
            };
            if(tag.includes('solid rank')) return {
                icon: 'üìä',
                desc: `Avg rank ${data.avgRank < 100000 ? 'under 100k' : 'under 500k'} indicates consistent demand in this category.`
            };
            if(tag.includes('180d sales')) return {
                icon: 'üìÖ',
                desc: `${data.drops180} sales over 180 days. Slower mover but still active. Expect 2-6 month sell-through.`
            };
            if(tag.includes('recent lull')) return {
                icon: '‚ö†Ô∏è',
                desc: `Historical sales (${data.drops180} in 180d) but none recently. Market cooling or seasonal dip.`
            };
            if(tag.includes('profitable')) return {
                icon: 'üí∞',
                desc: `Net profit of $${res.profit.toFixed(2)} after fees ($${(res.market * 0.15 + (data.weight > 1 ? 5.30 : 4.30)).toFixed(2)}) and your cost ($${CONFIG.buyCost.toFixed(2)}).`
            };
            
            // Negative signals
            if(tag.includes('negative profit')) return {
                icon: '‚ùå',
                desc: `You'd lose $${Math.abs(res.profit).toFixed(2)} per unit after Amazon fees and your cost. Not viable.`
            };
            if(tag.includes('thin margins')) return {
                icon: '‚ö†Ô∏è',
                desc: `Profit ($${res.profit.toFixed(2)}) below your floor ($${CONFIG.profitFloor.toFixed(2)}). Risk not worth reward.`
            };
            if(tag.includes('0 sales')) return {
                icon: 'üìâ',
                desc: `Zero sales in 180 days. Dead inventory risk is very high. Could sit for months or years.`
            };
            if(tag.includes('high rank')) return {
                icon: 'üìà',
                desc: `Rank over 2M indicates very slow sales. Expect 6+ months to sell, or it may never sell.`
            };
            if(tag.includes('low value')) return {
                icon: 'üíµ',
                desc: `Selling for under $10 means tiny profits after fees. Not worth storage space or shipping hassle.`
            };
            if(tag.includes('slow & cheap')) return {
                icon: '‚ö†Ô∏è',
                desc: `Under $20 AND slow sales (180d only). Low profit potential with high risk of long storage.`
            };
            if(tag.includes('bb suppressed')) return {
                icon: 'üõë',
                desc: `The Buy Box is suppressed. Listing price is critical. Use the Recommended Price, which accounts for past BB averages.`
            };
            if(tag.includes('bb held by amazon')) return {
                icon: 'üëë',
                desc: `Amazon currently holds the Buy Box. They often price match the lowest FBA price, limiting your short-term profit unless they run out of stock.`
            };
            if(tag.includes('restricted item')) return {
                icon: 'üö®',
                desc: `This product is potentially gated or Hazmat. **DO NOT BUY** without confirming selling eligibility in your Seller Central account first.`
            };
            
            // Default
            return {
                icon: isPositive ? '‚ú®' : '‚ö†Ô∏è',
                desc: ''
            };
        };
        
        // Map positive tags
        res.posTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, true);
            signals.push({
                icon: info.icon,
                title: tag.text.replace('üíé ', ''),
                text: info.desc,
                type: 'positive'
            });
        });
        
        // Map negative tags
        res.negTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, false);
            signals.push({
                icon: info.icon,
                title: tag.text,
                text: info.desc,
                type: 'negative'
            });
        });
        
        // Render signals
        if(signals.length === 0) {
            reasoningContent.innerHTML = '<div style="text-align: center; color: var(--muted); font-size: 11px; padding: 8px;">No specific signals</div>';
        } else {
            reasoningContent.innerHTML = signals.map(sig => `
                <div class="signal-item">
                    <span class="signal-icon">${sig.icon}</span>
                    <div class="signal-text">
                        <strong>${sig.title}</strong>
                        ${sig.text ? `<p>${sig.text}</p>` : ''}
                    </div>
                </div>
            `).join('');
        }
    }
    
    // --- Render Pricing Strategy Section ---
    renderPricingStrategy(data, res.market);
    
    // --- Auto-load Gemini Opinion (No Badge Needed) ---
    const geminiOpinion = document.getElementById('geminiOpinion');
    
    // Check if Gemini API key exists AND the verdict is 'CONSIDER'
    if(CONFIG.geminiKey && res.verdict === 'CONSIDER') {
        // Auto-load Gemini opinion for CONSIDER items
        loadGeminiOpinion(); 
    } else {
        geminiOpinion.classList.add('hidden');
    }
    // --- End Gemini Auto-load Logic ---

    card.classList.remove('hidden');
}

/* ================= PRICING STRATEGY RENDERER ================= */
function renderPricingStrategy(data, recommendedPrice) {
    const strategyDiv = document.getElementById('pricingStrategy');
    if (!strategyDiv) return;
    
    // Don't show if no price history data
    if (!data.bbPriceRange || !data.bbPriceRange.hasData) {
        strategyDiv.classList.add('hidden');
        return;
    }
    
    const range = data.bbPriceRange;
    const strategy = data.strategyType;
    const notes = data.pricingNotes;
    
    // Determine icon and styling based on strategy type
    let iconSymbol = 'üìä';
    let strategyLabel = 'Standard Pricing';
    let styleClass = '';
    
    if (strategy === 'WIDE_RANGE') {
        iconSymbol = 'üíé';
        strategyLabel = 'Wide Price Range';
        styleClass = 'wide-range';
    } else if (strategy === 'TIGHT_RANGE') {
        iconSymbol = '‚ö†Ô∏è';
        strategyLabel = 'Tight Price Range';
        styleClass = 'tight-range';
    } else if (strategy === 'FBM_DRIVEN') {
        iconSymbol = 'üéØ';
        strategyLabel = 'FBM Price Match Required';
        styleClass = 'fbm-driven';
    }
    
    // Calculate recommended list price (start high for wide range, mid-range for others)
    let listPrice = recommendedPrice;
    if (strategy === 'WIDE_RANGE') {
        listPrice = Math.min(range.max, recommendedPrice * 1.1); // Start near the top
    }
    
    strategyDiv.className = `pricing-strategy ${styleClass}`;
    strategyDiv.innerHTML = `
        <div class="strategy-header">
            <div class="strategy-title ${styleClass}">
                <span>${iconSymbol}</span>
                <span>PRICING STRATEGY</span>
            </div>
            <div class="strategy-icon ${styleClass}">
                <i class="fas fa-chart-line"></i>
            </div>
        </div>
        <div class="strategy-body">
            <div class="strategy-type ${styleClass}">${strategyLabel}</div>
            <div class="strategy-details">${notes}</div>
            
            <div class="price-range-display">
                <span class="price-range-label">90-Day BB Range:</span>
                <div class="price-range-values">
                    <span class="price-range-min">$${range.min.toFixed(2)}</span>
                    <span class="price-range-separator">‚Üí</span>
                    <span class="price-range-max">$${range.max.toFixed(2)}</span>
                </div>
            </div>
            
            ${strategy === 'WIDE_RANGE' ? `
                <div class="recommended-list-price">
                    <div class="list-price-label">Recommended List Price</div>
                    <div class="list-price-value">$${listPrice.toFixed(2)}</div>
                    <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">
                        Start high, lower gradually if no BB wins
                    </div>
                </div>
            ` : ''}
            
            ${data.fbaPremium && data.fbaPremium.exists ? `
                <div style="margin-top: 10px; padding: 8px; background: rgba(34,211,238,0.1); border-radius: 6px; font-size: 10px;">
                    <strong style="color: var(--diamond);">FBA Premium:</strong> 
                    <span style="color: rgba(255,255,255,0.8);">
                        FBA sellers command +$${data.fbaPremium.amount.toFixed(2)} (${data.fbaPremium.percentage}%) over MF
                    </span>
                </div>
            ` : ''}
        </div>
    `;
    
    strategyDiv.classList.remove('hidden');
}

/* ================= SCORE EXPLANATION LOGIC (NEW) ================= */

function toggleScoreExplanation() {
    const content = document.getElementById('scoreExplanationContent');
    const icon = document.getElementById('scoreExplanationToggleIcon');
    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        icon.classList.replace('fa-chevron-down', 'fa-chevron-up');
    } else {
        content.classList.add('hidden');
        icon.classList.replace('fa-chevron-up', 'fa-chevron-down');
    }
}

function renderScoreExplanation(res, data) {
    const content = document.getElementById('scoreExplanationContent');
    if (!content) return;

    const b = res.breakdown;
    const bbPrice = data.inferredBbPrice;
    
    let bbTypeInfo = '';
    if (data.bbOwnerType === 'ROTATING_FBA') {
        bbTypeInfo = `The Buy Box is typically **FBA-rotated** at the price of the lowest FBA offer ($${data.fbaPrice.toFixed(2)}). This is a stable, high-confidence BB type.`;
    } else if (data.bbOwnerType === 'FBM_PRICE_DRIVEN') {
        bbTypeInfo = `The Buy Box is currently driven by **FBM/MF sellers** at the lowest price ($${data.usedPrice.toFixed(2)}). FBA offers must be priced aggressively to win against this competition.`;
    } else {
        bbTypeInfo = `The Buy Box is **suppressed**. Pricing is based on historical averages and is volatile.`;
    }

    let bbRotation = 'N/A';
    // Logic for BB rotation frequency based on velocity and competition
    if (data.drops30 > 0 && data.fbaCount > 0) {
        const estSellsPerDay = data.drops30 / 30;
        const estDaysToSellout = data.fbaCount / estSellsPerDay;
        
        if (estDaysToSellout < 7) {
            bbRotation = 'HIGH (Daily)';
        } else if (estDaysToSellout < 30) {
            bbRotation = 'MEDIUM (Weekly)';
        } else {
            bbRotation = 'LOW (Monthly+)';
        }
    } else if (data.drops30 > 0) {
         bbRotation = 'HIGH (No FBA competition)';
    }


    const historicalPriceRange = `
        <span style="color:var(--green);">$${data.avgUsed.toFixed(2)} (Avg Used)</span> to 
        <span style="color:var(--blue);">$${data.avgNew.toFixed(2)} (Avg New)</span>
    `;

    content.innerHTML = `
        <div class="score-details-content">
            
            <div class="score-details-section">
                <div class="score-details-title"><i class="fas fa-calculator"></i> Score Calculation (Base 50)</div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Base Score</span>
                    <span class="metric-value-num">50</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Velocity (30d Sales: ${data.drops30})</span>
                    <span class="metric-value-num" style="color:${b.velocityScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.velocityScore > 0 ? '+' : ''}${b.velocityScore}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Buy Box Quality (${data.bbOwnerType.replace('_', ' ')})</span>
                    <span class="metric-value-num" style="color:${b.bbScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.bbScore > 0 ? '+' : ''}${b.bbScore}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">Competition (FBA Offers: ${data.fbaCount})</span>
                    <span class="metric-value-num" style="color:${b.compScore > 0 ? 'var(--green)' : 'var(--red)'};">${b.compScore > 0 ? '+' : ''}${b.compScore}</span>
                </div>
                ${b.profitPenalty > 0 ? `
                <div class="score-details-metric-row" style="border-top: 1px dashed rgba(255,255,255,0.1); margin-top: 5px; padding-top: 5px;">
                    <span class="metric-name">PROFIT PENALTY (Below $${CONFIG.profitFloor.toFixed(2)} Floor)</span>
                    <span class="metric-value-num" style="color:var(--red);">- ${b.profitPenalty.toFixed(2)}</span>
                </div>
                ` : ''}
                <div class="score-details-metric-row" style="border-top: 2px solid var(--border); margin-top: 10px; padding-top: 5px;">
                    <span class="metric-name">FINAL SCORE</span>
                    <span class="metric-value-num" style="color:var(--diamond); font-size:14px;">${res.score}</span>
                </div>
            </div>
            
            <div class="score-details-section">
                <div class="score-details-title"><i class="fas fa-chart-line"></i> Market & Buy Box Dynamics</div>
                <p>
                    ${bbTypeInfo}
                </p>
                <div class="score-details-metric-row" style="margin-top: 10px;">
                    <span class="metric-name">BB Rotation Frequency (Est.)</span>
                    <span class="metric-value-num">${bbRotation}</span>
                </div>
                <div class="score-details-metric-row">
                    <span class="metric-name">90-Day Historical Range (Avg)</span>
                    <span class="metric-value-num">${historicalPriceRange}</span>
                </div>
            </div>
        </div>
    `;
}

/* ================= TOGGLE FUNCTIONS (CLEANED) ================= */

function updateSliderDisplays() {
    const cost = parseFloat(document.getElementById('sliderCost').value);
    const floor = parseFloat(document.getElementById('sliderFloor').value);
    
    const costValueEl = document.getElementById('costValue');
    const floorValueEl = document.getElementById('floorValue');
    
    if(costValueEl) costValueEl.textContent = '$' + cost.toFixed(2);
    if(floorValueEl) floorValueEl.textContent = '$' + floor.toFixed(2);
}

function renderTags(id, tags) {
    const el = document.getElementById(id);
    if(!el) return;
    el.innerHTML = '';
    tags.forEach(t => {
        el.innerHTML += `<span class="tag ${t.type}">${t.text}</span>`;
    });
}

/* ================= CAMERA (ROBUST) ================= */
let html5QrCode;
let scanMode = 'barcode'; // 'barcode' or 'isbn'
let ocrInterval = null;

function openCamera() {
    startCamera();
}

function switchScanMode(mode) {
    scanMode = mode;
    
    // Update button states
    document.getElementById('mode-barcode').classList.toggle('active', mode === 'barcode');
    document.getElementById('mode-isbn').classList.toggle('active', mode === 'isbn');
    
    // Update frame visibility
    document.getElementById('scan-frame-barcode').classList.toggle('hidden', mode === 'barcode');
    document.getElementById('scan-frame-isbn').classList.toggle('hidden', mode === 'barcode');
    
    // Restart camera with new mode
    if(html5QrCode) {
        stopCamera();
        setTimeout(() => startCamera(), 500);
    }
}

function updateCameraStatus(state, text) {
    const status = document.getElementById('camera-status');
    if(!status) return;
    
    status.className = 'camera-status ' + state;
    status.textContent = text;
}

function startCamera() {
    const overlay = document.getElementById('camera-overlay');
    overlay.classList.remove('hidden');
    
    if(scanMode === 'barcode') {
        startBarcodeScanner();
    } else {
        startISBNScanner();
    }
}

function startBarcodeScanner() {
    updateCameraStatus('', 'Ready to scan barcode...');
    
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" }, 
        { fps: 10, qrbox: { width: 250, height: 150 } },
        (decodedText) => {
            // Success!
            updateCameraStatus('success', '‚úì Barcode Detected!');
            
            if(navigator.vibrate) navigator.vibrate(200);
            
            setTimeout(() => {
                stopCamera();
                document.getElementById('scanInput').value = decodedText;
                addToQueue(decodedText);
            }, 500);
        },
        (errorMessage) => {
            // Scanning...
            if(!errorMessage.includes('No MultiFormat Readers')) {
                updateCameraStatus('detecting', 'üîç Scanning...');
            }
        }
    ).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startISBNScanner() {
    updateCameraStatus('', 'Position ISBN in frame...');
    
    // Start video stream
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: { width: 280, height: 80 } },
        () => {}, // Not using barcode callback
        () => {}  // Not using error callback
    ).then(() => {
        // Start OCR processing
        startOCRProcessing();
    }).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startOCRProcessing() {
    let isProcessing = false;
    let attemptCount = 0;
    
    // Update status with helpful instruction
    updateCameraStatus('detecting', 'üìñ HOLD STEADY - Reading ISBN...');
    
    ocrInterval = setInterval(async () => {
        if(isProcessing) return;
        
        isProcessing = true;
        attemptCount++;
        
        // Show progress
        updateCameraStatus('detecting', `üìñ HOLD STEADY - Attempt ${attemptCount}...`);
        
        try {
            // Capture frame from video
            const video = document.querySelector('#reader video');
            if(!video) {
                isProcessing = false;
                return;
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw video frame
            ctx.drawImage(video, 0, 0);
            
            // FIX #1: IMAGE PREPROCESSING for better OCR
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert to grayscale and increase contrast
            for(let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                // Increase contrast: make darks darker, lights lighter
                const contrast = avg < 128 ? avg * 0.7 : avg * 1.3;
                data[i] = data[i + 1] = data[i + 2] = Math.min(255, Math.max(0, contrast));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Run OCR on preprocessed frame
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                logger: () => {}, // Suppress logs
                tessedit_char_whitelist: '0123456789X' // Only numbers and X for ISBN
            });
            
            // Extract ISBN from text
            const isbn = extractISBN(text);
            
            if(isbn) {
                // Success!
                updateCameraStatus('success', '‚úì ISBN Detected!');
                
                if(navigator.vibrate) navigator.vibrate(200);
                
                clearInterval(ocrInterval);
                
                setTimeout(() => {
                    stopCamera();
                    document.getElementById('scanInput').value = isbn;
                    addToQueue(isbn);
                }, 500);
            } else {
                isProcessing = false;
            }
            
        } catch(err) {
            console.error('OCR error:', err);
            isProcessing = false;
        }
    }, 1000); // FIX #1: Check every 1 second (was 2 seconds)
}

function extractISBN(text) {
    // Remove all spaces and hyphens
    const cleaned = text.replace(/[\s\-]/g, '');
    
    // Look for ISBN-13 (starts with 978 or 979)
    const isbn13Match = cleaned.match(/97[89]\d{10}/);
    if(isbn13Match) return isbn13Match[0];
    
    // Look for ISBN-10 (10 digits or 9 digits + X)
    const isbn10Match = cleaned.match(/\d{9}[0-9X]/i);
    if(isbn10Match) return isbn10Match[0];
    
    return null;
}

function stopCamera() {
    document.getElementById('camera-overlay').classList.add('hidden');
    
    if(ocrInterval) {
        clearInterval(ocrInterval);
        ocrInterval = null;
    }
    
    if(html5QrCode) {
        html5QrCode.stop().then(() => html5QrCode.clear()).catch(() => {});
    }
}

/* ================= GEMINI (AUTO-LOAD FOR CONSIDER) ================= */
async function loadGeminiOpinion() {
    if(!lastData || !currentScan) return;
    if(!CONFIG.geminiKey) return; // Skip if no API key
    
    const geminiOpinion = document.getElementById('geminiOpinion');
    if(!geminiOpinion) return;
    
    // If we already have a Gemini score saved for this scan, render it and exit
    if (currentScan.geminiScore) {
        renderGeminiOpinion(currentScan.geminiVerdict, currentScan.geminiScore, currentScan.geminiReasoning);
        return;
    }
    
    const result = analyze(lastData);
    const baseScore = result.score;
    
    // Show loading state
    geminiOpinion.className = 'gemini-opinion loading';
    geminiOpinion.innerHTML = `
        <div class="gemini-header">
            <div class="gemini-title">
                <span>ü§ñ</span>
                <span>GEMINI SECOND OPINION</span>
            </div>
        </div>
        <div style="text-align:center; padding:30px; color:var(--muted);">
            <i class="fas fa-circle-notch fa-spin" style="font-size:24px; margin-bottom:10px;"></i>
            <div>Analyzing item...</div>
        </div>
    `;
    geminiOpinion.classList.remove('hidden');
    
    // Build prompt for Gemini
    const itemType = lastData.category || 'item';
    const prompt = `Analyze this ${itemType} for Amazon FBA resale:

ITEM DETAILS:
Title: ${lastData.title}
Category: ${lastData.category || 'Unknown'}
Sales Rank: ${lastData.rank ? lastData.rank.toLocaleString() : 'Unknown'}

FINANCIAL ANALYSIS:
Your Cost: $${CONFIG.buyCost.toFixed(2)}
Recommended Sell Price: $${result.market.toFixed(2)}
CALCULATED NET PROFIT: $${result.profit.toFixed(2)} 
(This includes ALL Amazon FBA fees, referral fees, closing fees, and your cost. This is the FINAL profit number - do NOT recalculate.)

MARKET DATA:
Sales Velocity (30 days): ${lastData.drops30} drops
Sales Velocity (180 days): ${lastData.drops180} drops
Total Competition: ${lastData.totalOffers} sellers
Current Buy Box: $${lastData.inferredBbPrice > 0 ? lastData.inferredBbPrice.toFixed(2) : 'N/A'}

INITIAL ASSESSMENT:
Your Algorithm Score: ${baseScore}/100 (CONSIDER tier - needs second opinion)

YOUR TASK: Provide a decisive second opinion. Should this be UPGRADED to BUY or DOWNGRADED to REJECT?

BUSINESS CONTEXT:
- Inventory with 3-6 month sell-through is acceptable if profit is solid
- Books don't expire or go out of style quickly
- Storage costs are already factored into the profit calculation
- Higher profit can justify slower velocity

EVALUATION CRITERIA:
1. You must choose either BUY or REJECT - never CONSIDER
2. Use the $${result.profit.toFixed(2)} profit figure provided above. Do NOT recalculate fees or profit.
3. Focus on whether the profit justifies the wait time, not just velocity alone
4. Consider: Would you rather have $${result.profit.toFixed(2)} in 4 months or pass entirely?
5. Slower sales are acceptable if profit margin is solid relative to effort

SCORE RANGES (CRITICAL):
- UPGRADE to BUY: Score 60-100
  * 85-100: Excellent opportunity (strong profit + good velocity)
  * 75-84: Solid buy (good profit, acceptable velocity)
  * 60-74: Worth it (profit justifies longer wait OR decent velocity with okay profit)
- DOWNGRADE to REJECT: Score 0-49
  * Items where profit doesn't justify the storage time
  * Very slow movers (<3 drops in 180d) with thin profit (<$4)
  * High competition with low profit margin

Provide a brief explanation (2-3 sentences) focusing on the profit-to-wait-time value proposition.

Respond EXACTLY in this format:
VERDICT: [BUY or REJECT]
SCORE: [0-49 for REJECT, 60-100 for BUY]
REASONING: [Your explanation]`;

    const model = 'gemini-2.0-flash-exp';
    const cleanKey = CONFIG.geminiKey.trim();

    try {
        let url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${cleanKey}`;
        
        if(CONFIG.useProxy) {
            url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });
        
        const json = await response.json();
        
        if(json.error) throw new Error(json.error.message);

        if(json.candidates && json.candidates[0] && json.candidates[0].content) {
            const text = json.candidates[0].content.parts[0].text;
            
            // Parse response
            const verdictMatch = text.match(/VERDICT:\s*(BUY|REJECT)/i);
            const scoreMatch = text.match(/SCORE:\s*(\d+)/);
            const reasoningMatch = text.match(/REASONING:\s*(.+)/s);

            const geminiVerdict = verdictMatch ? verdictMatch[1].toUpperCase() : null;
            const geminiScore = scoreMatch ? parseInt(scoreMatch[1]) : null;
            const geminiReasoning = reasoningMatch ? reasoningMatch[1].trim() : text;

            if (!geminiVerdict || !geminiScore) {
                throw new Error('Could not parse Gemini response');
            }
            
            // VALIDATE: Gemini must give BUY (75+) or REJECT (<50), never CONSIDER
            // Score ranges: BUY = 75-100, CONSIDER = 50-74, REJECT = 0-49
            let validatedVerdict = geminiVerdict;
            
            if (geminiScore >= 75 && geminiVerdict !== 'BUY') {
                console.warn('Gemini verdict mismatch: score', geminiScore, 'should be BUY');
                validatedVerdict = 'BUY';
            } else if (geminiScore < 50 && geminiVerdict !== 'REJECT') {
                console.warn('Gemini verdict mismatch: score', geminiScore, 'should be REJECT');
                validatedVerdict = 'REJECT';
            } else if (geminiScore >= 50 && geminiScore < 75) {
                // This is INVALID - Gemini should never return a CONSIDER score
                console.error('INVALID: Gemini returned CONSIDER range score', geminiScore, '- forcing to REJECT');
                validatedVerdict = 'REJECT';
            }

            // Save to current scan history
            if(currentScan) {
                currentScan.geminiVerdict = validatedVerdict;
                currentScan.geminiScore = geminiScore;
                currentScan.geminiReasoning = geminiReasoning;
                
                // Update in scanHistory (first item)
                if(scanHistory[0]) {
                    scanHistory[0].geminiVerdict = validatedVerdict;
                    scanHistory[0].geminiScore = geminiScore;
                    scanHistory[0].geminiReasoning = geminiReasoning;
                    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
                }
            }
            
            renderGeminiOpinion(validatedVerdict, geminiScore, geminiReasoning, baseScore);

        }
    } catch(e) { 
        console.error('Gemini error:', e);
        // Show error state but don't interrupt user
        geminiOpinion.innerHTML = `
            <div class="gemini-header">
                <div class="gemini-title">
                    <span>ü§ñ</span>
                    <span>GEMINI UNAVAILABLE</span>
                </div>
            </div>
            <div style="text-align:center; padding:20px; color:var(--muted); font-size:12px;">
                ${e.message.includes('API') ? 'Check your API key in Settings' : 'Connection error'}
            </div>
        `;
    }
}

function renderGeminiOpinion(geminiVerdict, geminiScore, geminiReasoning, baseScoreOverride) {
    const geminiOpinion = document.getElementById('geminiOpinion');
    const result = analyze(lastData);
    const baseScore = baseScoreOverride !== undefined ? baseScoreOverride : result.score;
    
    // Determine if upgrade or downgrade
    const isUpgrade = geminiVerdict === 'BUY';
    const opinionClass = isUpgrade ? 'upgrade' : 'downgrade';
    
    // CRITICAL: If Gemini upgrades to BUY and there are gem tags, show gem icon
    if (isUpgrade && geminiScore >= 75) {
        const hasGemTags = result.posTags.concat(result.negTags).some(tag => tag.type === 'gem');
        if (hasGemTags) {
            const gemIcon = document.getElementById('gemIcon');
            if (gemIcon) {
                gemIcon.classList.add('visible');
            }
        }
    }

    // Build the UI
    geminiOpinion.className = 'gemini-opinion ' + opinionClass;
    geminiOpinion.innerHTML = `
        <div class="gemini-header">
            <div class="gemini-title ${opinionClass}">
                <span>ü§ñ</span>
                <span>GEMINI SECOND OPINION</span>
            </div>
            <div class="collapse-icon" onclick="toggleGeminiCollapse()">‚àí</div>
        </div>

        <div class="gemini-content" id="geminiContent">
            <div class="score-comparison">
                <div class="score-box">
                    <div class="score-box-label">Your Score</div>
                    <div class="score-box-value amber">${baseScore}</div>
                </div>

                <div class="score-arrow ${isUpgrade ? 'up' : 'down'}">‚Üí</div>

                <div class="score-box">
                    <div class="score-box-label">Gemini Score</div>
                    <div class="score-box-value ${isUpgrade ? 'green' : 'red'}">${geminiScore}</div>
                </div>
            </div>

            <div class="gemini-verdict ${opinionClass}">
                ${isUpgrade ? '‚úì UPGRADE ‚Üí BUY' : '‚úó DOWNGRADE ‚Üí REJECT'}
            </div>

            <div class="gemini-text">${geminiReasoning}</div>
        </div>
    `;

    geminiOpinion.classList.remove('hidden');
}

function toggleGeminiCollapse() {
    const content = document.getElementById('geminiContent');
    const icon = document.querySelector('.collapse-icon');
    if(content && icon) {
        content.classList.toggle('hidden');
        icon.textContent = content.classList.contains('hidden') ? '+' : '‚àí';
    }
}

/* ================= SETTINGS ================= */
function showSettings() {
    document.getElementById('settingsPage').classList.remove('hidden');
    document.getElementById('keepaKey').value = CONFIG.keepaKey;
    document.getElementById('geminiKey').value = CONFIG.geminiKey;
    document.getElementById('defCost').value = CONFIG.buyCost;
    document.getElementById('defFloor').value = CONFIG.profitFloor;
}

function closeSettings() {
    document.getElementById('settingsPage').classList.add('hidden');
}

function saveSettings() {
    CONFIG.keepaKey = document.getElementById('keepaKey').value.trim();
    CONFIG.geminiKey = document.getElementById('geminiKey').value.trim();
    CONFIG.buyCost = parseFloat(document.getElementById('defCost').value);
    CONFIG.profitFloor = parseFloat(document.getElementById('defFloor').value);
    CONFIG.useProxy = document.getElementById('toggleProxy').classList.contains('active');
    CONFIG.fastScan = document.getElementById('toggleFastScan').classList.contains('active');
    
    localStorage.setItem('keepaKey', CONFIG.keepaKey);
    localStorage.setItem('geminiKey', CONFIG.geminiKey);
    localStorage.setItem('buyCost', CONFIG.buyCost);
    localStorage.setItem('profitFloor', CONFIG.profitFloor);
    localStorage.setItem('useProxy', CONFIG.useProxy);
    localStorage.setItem('fastScan', CONFIG.fastScan);
    
    updateTokenUI();
    updateConditionUI();
    closeSettings();
}

/* ================= HISTORY MANAGEMENT (VIEW & DELETE) ================= */

let focusedDeleteTimestamp = null;

function toggleDeleteConfirmation(timestamp) {
    const wrapper = document.querySelector(`.history-item-wrapper[data-timestamp="${timestamp}"]`);
    const overlay = wrapper ? wrapper.querySelector('.delete-confirm-overlay') : null;
    
    // If we click the same item again (to cancel), or cancel
    if(focusedDeleteTimestamp === timestamp) {
        if(overlay) overlay.classList.remove('active');
        focusedDeleteTimestamp = null;
        return;
    }
    
    // First, close any currently open confirmation
    if (focusedDeleteTimestamp) {
        toggleDeleteConfirmation(focusedDeleteTimestamp);
    }
    
    // Then, open the new confirmation
    if (overlay) {
        overlay.classList.add('active');
        focusedDeleteTimestamp = timestamp;
    }
}

function deleteScan(timestamp) {
    // We already have a confirmation built into the UI, so we only need the filter/re-render logic
    
    const initialLength = scanHistory.length;
    
    scanHistory = scanHistory.filter(item => item.timestamp !== timestamp);
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    if (scanHistory.length < initialLength) {
        // Successful deletion
        if (navigator.vibrate) navigator.vibrate(50);
        focusedDeleteTimestamp = null;
        showHistory(); // Re-render the history page
    } else {
        alert("Error deleting item.");
    }
}


function showHistory() {
    const page = document.getElementById('historyPage');
    const list = document.getElementById('historyList');
    
    if(!list) return;
    
    focusedDeleteTimestamp = null; // Reset focus when opening history
    
    // Calculate restricted count
    const restrictedCount = scanHistory.filter(item => item.restricted).length;
    const restrictedCountEl = document.getElementById('restrictedCount');
    const restrictedCountText = document.getElementById('restrictedCountText');
    const btnRemoveRestricted = document.getElementById('btnRemoveRestricted');
    
    if(restrictedCount > 0) {
        restrictedCountEl.style.display = 'flex';
        btnRemoveRestricted.style.display = 'block';
        restrictedCountText.textContent = `${restrictedCount} restricted`;
    } else {
        restrictedCountEl.style.display = 'none';
        btnRemoveRestricted.style.display = 'none';
    }
    
    // Render all history items
    if(scanHistory.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
    } else {
        list.innerHTML = scanHistory.map(item => {
            let color = 'var(--red)';
            if(item.verdict === 'BUY') color = 'var(--green)';
            if(item.verdict === 'CONSIDER') color = 'var(--yellow)';
            
            // Decision badge
            let decisionBadge = '';
            if(item.decision === 'BOUGHT') {
                decisionBadge = `<span style="background:rgba(16,185,129,0.2); color:var(--green); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úì BOUGHT</span>`;
            } else if(item.decision === 'PASSED') {
                decisionBadge = `<span style="background:rgba(239,68,68,0.2); color:var(--red); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úó PASSED</span>`;
            }
            
            // Restricted badge
            let restrictedBadge = '';
            if(item.restricted) {
                restrictedBadge = `<span class="restricted-badge">üîí RESTRICTED</span>`;
            }
            
            // The new history item structure with click handler
            return `
                <div class="history-item-wrapper" data-timestamp="${item.timestamp}">
                    <div class="history-item-content" onclick="toggleDeleteConfirmation(${item.timestamp})">
                        <div style="display:flex; justify-content:space-between; align-items:center; font-weight:700;">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="color:${color}">${item.verdict}</span>
                                ${decisionBadge}
                                ${restrictedBadge}
                            </div>
                            <span style="color:${item.profit >= 0 ? 'var(--green)' : 'var(--red)'}">$${item.profit.toFixed(2)}</span>
                        </div>
                        <div style="font-size:12px; color:var(--muted); margin-top:4px;">${item.title.substring(0,60)}...</div>
                    </div>
                    
                    <div class="delete-confirm-overlay">
                        <div class="delete-message">Delete this scan?</div>
                        <div class="confirm-buttons">
                            <button class="btn-delete-confirm cancel" onclick="toggleDeleteConfirmation(${item.timestamp}); event.stopPropagation();">Cancel</button>
                            <button class="btn-delete-confirm delete" onclick="deleteScan(${item.timestamp}); event.stopPropagation();">DELETE</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    page.classList.remove('hidden');
}

function closeHistory() {
    document.getElementById('historyPage').classList.add('hidden');
}

function removeRestrictedItems() {
    const restrictedCount = scanHistory.filter(item => item.restricted).length;
    
    if(restrictedCount === 0) {
        alert('No restricted items to remove');
        return;
    }
    
    if(!confirm(`Remove ${restrictedCount} restricted item${restrictedCount > 1 ? 's' : ''} from history?`)) {
        return;
    }
    
    // Filter out restricted items
    scanHistory = scanHistory.filter(item => !item.restricted);
    
    // Save to localStorage
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    // Refresh display
    showHistory();
    
    // Show feedback
    alert(`‚úì Removed ${restrictedCount} restricted item${restrictedCount > 1 ? 's' : ''}`);
}

function addToHistory(res, data) {
    const item = { 
        verdict: res.verdict, 
        profit: res.profit, 
        score: res.score,
        market: res.market, // Add market price for CSV export
        title: data.title,
        asin: data.asin,
        isbn: data.isbn || '', // Add ISBN for CSV export
        category: data.category || 'Unknown',
        restricted: data.restricted || false, // Add restriction flag
        // Pricing strategy fields
        strategyType: data.strategyType || 'UNKNOWN',
        bbRangeMin: data.bbPriceRange?.min || 0,
        bbRangeMax: data.bbPriceRange?.max || 0,
        bbRangeSpread: data.bbPriceRange?.spread || 0,
        pricingNotes: data.pricingNotes || '',
        fbaPremiumAmount: data.fbaPremium?.amount || 0,
        fbaPremiumPercent: data.fbaPremium?.percentage || 0,
        // Gemini fields
        geminiVerdict: null, // Will be filled when Gemini responds
        geminiScore: null,
        geminiReasoning: null,
        decision: null, // 'BOUGHT', 'PASSED', or null
        timestamp: Date.now()
    };
    
    scanHistory.unshift(item);
    
    // Keep only last 100 scans
    if(scanHistory.length > 100) {
        scanHistory = scanHistory.slice(0, 100);
    }
    
    // Save to localStorage
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    // Set as current scan for decision tracking
    currentScan = item;
}

/* ================= DECISION TRACKING ================= */
function recordDecision(decision) {
    if(!currentScan) {
        alert('No active scan to record decision for');
        return;
    }
    
    // Update current scan
    currentScan.decision = decision;
    
    // Update in scanHistory (it's the first item)
    if(scanHistory[0]) {
        scanHistory[0].decision = decision;
        localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    }
    
    // Visual feedback
    const buttons = document.querySelectorAll('.decision-btn');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.closest('.decision-btn').classList.add('selected');
    
    const note = document.getElementById('decisionNote');
    if(note) {
        const emoji = decision === 'BOUGHT' ? '‚úì' : '‚úó';
        const action = decision === 'BOUGHT' ? 'BUYING' : 'PASSING ON';
        note.textContent = `${emoji} Decision saved: ${action} this item`;
        note.className = 'decision-note success';
    }
    
    // Vibrate if available
    if(navigator.vibrate) navigator.vibrate(100);
}

/* ================= CSV EXPORT (UPDATED) ================= */
function exportCSV() {
    // Export ALL history items
    const exportable = scanHistory; 
    
    if(exportable.length === 0) {
        alert('No scans in history to export!');
        return;
    }
    
    // Calculate stats
    const exportableLength = exportable.length;
    const totalProfit = exportable.reduce((sum, item) => sum + item.profit, 0);
    
    // Build CSV with enhanced columns for pricing strategy
    // Format: TITLE, SCAN DATE, RATING, ISBN, ASIN, RECOMMENDED PRICE, STRATEGY TYPE, BB MIN, BB MAX, BB SPREAD, PRICING NOTES, FBA PREMIUM
    const headers = [
        'TITLE', 'SCAN DATE', 'RATING', 'ISBN', 'ASIN', 'RECOMMENDED PRICE',
        'STRATEGY TYPE', 'BB MIN', 'BB MAX', 'BB SPREAD', 'PRICING NOTES', 'FBA PREMIUM %'
    ];
    
    const rows = exportable.map(item => {
        // Format date as MM/DD/YYYY
        const date = item.timestamp ? new Date(item.timestamp).toLocaleDateString('en-US') : '';
        
        // Title - escape quotes
        const title = (item.title || '').replace(/"/g, '""');
        
        // RATING = score (0-100)
        const rating = item.score || 0;
        
        // ISBN - extract from stored data
        const isbn = item.isbn || '';
        
        // ASIN
        const asin = item.asin || '';
        
        // RECOMMENDED PRICE - market price without $ or formatting
        const price = item.market ? item.market.toFixed(2) : '0.00';
        
        // Pricing strategy fields
        const strategyType = item.strategyType || 'UNKNOWN';
        const bbMin = item.bbRangeMin ? item.bbRangeMin.toFixed(2) : '0.00';
        const bbMax = item.bbRangeMax ? item.bbRangeMax.toFixed(2) : '0.00';
        const bbSpread = item.bbRangeSpread ? item.bbRangeSpread.toFixed(2) : '0.00';
        const pricingNotes = (item.pricingNotes || '').replace(/"/g, '""');
        const fbaPremium = item.fbaPremiumPercent || 0;
        
        // Ensure values are wrapped in quotes if they contain commas or quotes
        const safeTitle = `"${title}"`;
        const safeIsbn = `"${isbn}"`;
        const safeAsin = `"${asin}"`;
        const safePricingNotes = `"${pricingNotes}"`;

        return [
            safeTitle, date, rating, safeIsbn, safeAsin, price,
            strategyType, bbMin, bbMax, bbSpread, safePricingNotes, fbaPremium
        ].join(',');
    });
    
    const csv = [headers.join(','), ...rows].join('\n');
    
    // Download file
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scout-export-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    // Show success toast with decision stats
    const toast = document.getElementById('exportToast');
    if(toast) {
        toast.innerHTML = `üìä ${exportableLength} Items Exported ‚Ä¢ $${totalProfit.toFixed(2)} total profit`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), 4000);
    }
}

/* ================= TOGGLE CONDITION FIX ================= */
function setCondition(c) {
    // 1. Update State
    CONFIG.condition = c;
    
    // 2. Update UI (Force Toggle)
    const btnUsed = document.getElementById('btnCondUsed');
    const btnNew = document.getElementById('btnCondNew');
    
    if(btnUsed && btnNew) {
        if(c === 'USED') {
            btnUsed.classList.add('active');
            btnNew.classList.remove('active');
        } else {
            btnUsed.classList.remove('active');
            btnNew.classList.add('active');
        }
    }
    
    // 3. Re-run Analysis if we have data
    if(lastData) {
        const result = analyze(lastData);
        render(result, lastData);
    }
}
</script>

<script>
// SPLASH SCREEN - Must be at end of body to ensure DOM exists
(function() {
    const splash = document.getElementById('splash-screen');
    if(!splash) return;
    
    // Hide splash after 1.5 seconds
    setTimeout(() => {
        splash.classList.add('splash-hidden');
    }, 1500);
    
    // Emergency failsafe - force hide after 3 seconds
    setTimeout(() => {
        if(!splash.classList.contains('splash-hidden')) {
            splash.style.display = 'none';
        }
    }, 3000);
})();
</script>

</body>
</html>