<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Pretty Good Scouting App (Pro)</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<style>
/* --- THEME & RESET --- */
:root {
  --bg: #050505; --panel: #121212; --card: #1e1e1e; --border: #2a2a2a;
  --text: #ffffff; --muted: #888; --green: #34d399; --red: #f87171;
  --yellow: #fbbf24; --blue: #60a5fa; --purple: #a78bfa; --diamond: #22d3ee;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); padding-bottom: 120px; -webkit-font-smoothing: antialiased; overflow-x: hidden; }
.app { max-width: 480px; margin: 0 auto; min-height: 100vh; position: relative; border-left: 1px solid var(--border); border-right: 1px solid var(--border); }

/* --- SPLASH SCREEN --- */
#splash-screen {
    position: fixed; inset: 0; z-index: 9999; background-color: #000;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    transition: opacity 0.8s ease-out, visibility 0.8s;
}
.splash-hidden { opacity: 0; visibility: hidden; pointer-events: none; }
.splash-bg { position: absolute; inset: 0; z-index: 0; }
.splash-bg img { width: 100%; height: 100%; object-fit: cover; opacity: 0.4; filter: blur(2px); }
.splash-content { position: relative; z-index: 10; text-align: center; width: 100%; padding: 0 20px; }
.big-title {
    font-family: 'Inter', sans-serif; font-weight: 900; text-transform: uppercase;
    line-height: 0.9; letter-spacing: -0.05em; display: flex; flex-direction: column; gap: 0;
    text-shadow: 0 4px 20px rgba(0,0,0,1);
}
.big-title span { font-size: 3.5rem; }
@media(min-width: 400px) { .big-title span { font-size: 4.5rem; } }

/* --- HEADER --- */
header { padding: 12px 16px; background: var(--bg); position: sticky; top: 0; z-index: 50; border-bottom: 1px solid var(--border); }
.status-row { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
.status-badge {
    font-size: 10px; font-weight: 700; color: var(--muted);
    background: rgba(255,255,255,0.05); padding: 4px 10px; border-radius: 99px;
    display: flex; align-items: center; gap: 6px; border: 1px solid transparent; transition: all 0.2s;
}
.status-badge.live { color: var(--green); border-color: rgba(52, 211, 153, 0.2); background: rgba(52, 211, 153, 0.1); }
.status-badge.dead { color: var(--red); border-color: rgba(248, 113, 113, 0.2); background: rgba(248, 113, 113, 0.1); }
.status-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

.search-container { position: relative; display: flex; gap: 8px; }
.input-wrapper { position: relative; flex: 1; }
.search-icon { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 16px; }
input[type="text"] {
  width: 100%; padding: 14px 14px 14px 42px; border-radius: 12px; background: #111; border: 1px solid #333;
  color: white; font-family: 'Inter', sans-serif; font-size: 16px; outline: none; transition: all 0.2s;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
input[type="text"]:focus { border-color: var(--blue); background: #161616; }
.icon-btn {
    width: 48px; border-radius: 12px; border: 1px solid #333; background: #111;
    color: var(--muted); font-size: 18px; cursor: pointer; display: grid; place-items: center; transition: all 0.2s;
}
.icon-btn.active { color: var(--green); border-color: rgba(52, 211, 153, 0.4); background: rgba(52, 211, 153, 0.1); }

/* --- ENHANCED CAMERA OVERLAY --- */
#camera-overlay { 
  position: fixed; inset: 0; z-index: 9999; background: #000; 
  display: flex; flex-direction: column;
}

#camera-header {
  position: absolute; top: 0; left: 0; right: 0; z-index: 10001;
  padding: 20px; background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  text-align: center;
}

.camera-title {
  font-size: 18px; font-weight: 800; color: #fff; margin-bottom: 8px;
}

.camera-mode-toggle {
  display: flex; gap: 8px; justify-content: center; margin-top: 12px;
}

.mode-btn {
  background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.6);
  border: 2px solid rgba(255,255,255,0.2); padding: 8px 20px;
  border-radius: 99px; font-weight: 700; font-size: 13px;
  cursor: pointer; transition: all 0.2s;
}

.mode-btn.active {
  background: rgba(96,165,250,0.2); color: var(--blue);
  border-color: var(--blue);
}

.mode-btn:hover:not(.active) {
  background: rgba(255,255,255,0.15);
}

.camera-status {
  font-size: 13px; font-weight: 600; color: var(--blue); 
  padding: 6px 16px; background: rgba(96,165,250,0.15); 
  border-radius: 99px; display: inline-block;
  border: 1px solid rgba(96,165,250,0.3);
}

.camera-status.detecting {
  color: var(--yellow); background: rgba(251,191,36,0.15);
  border-color: rgba(251,191,36,0.3);
  animation: pulse 1s ease-in-out infinite;
}

.camera-status.success {
  color: var(--green); background: rgba(16,185,129,0.15);
  border-color: rgba(16,185,129,0.3);
}

.camera-status.error {
  color: var(--red); background: rgba(239,68,68,0.15);
  border-color: rgba(239,68,68,0.3);
}

#reader { 
  width: 100%; height: 100%; flex: 1; position: relative;
}

/* Animated Scan Frame */
.scan-frame {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: 300px; height: 180px; z-index: 10000; pointer-events: none;
}

/* ISBN Frame - Wider for text */
.isbn-frame {
  width: 280px; height: 80px;
}

.isbn-hint {
  position: absolute; bottom: -35px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.7); font-size: 12px; font-weight: 600;
  white-space: nowrap; text-align: center;
}

.scan-corner {
  position: absolute; width: 40px; height: 40px;
  border: 3px solid var(--blue); opacity: 0.8;
}

.scan-corner.top-left { top: 0; left: 0; border-right: none; border-bottom: none; }
.scan-corner.top-right { top: 0; right: 0; border-left: none; border-bottom: none; }
.scan-corner.bottom-left { bottom: 0; left: 0; border-right: none; border-top: none; }
.scan-corner.bottom-right { bottom: 0; right: 0; border-left: none; border-top: none; }

.scan-line {
  position: absolute; top: 0; left: 0; right: 0; height: 2px;
  background: linear-gradient(90deg, transparent, var(--green), transparent);
  animation: scanLine 2s ease-in-out infinite;
  box-shadow: 0 0 10px var(--green);
}

@keyframes scanLine {
  0% { top: 0; opacity: 0; }
  50% { opacity: 1; }
  100% { top: 100%; opacity: 0; }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.camera-footer {
  position: absolute; bottom: 0; left: 0; right: 0; z-index: 10001;
  padding: 30px; background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  display: flex; justify-content: center;
}

#close-camera {
  background: rgba(239,68,68,0.2); color: var(--red); 
  border: 2px solid var(--red); padding: 14px 32px;
  border-radius: 99px; font-weight: 800; font-size: 16px; 
  cursor: pointer; transition: all 0.2s;
  display: flex; align-items: center; gap: 8px;
}

#close-camera:hover {
  background: var(--red); color: #fff;
}

#close-camera:active {
  transform: scale(0.95);
}


/* --- CARD --- */
.card {
  margin: 16px; background: var(--panel); border-radius: 20px; border: 1px solid var(--border);
  overflow: hidden; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.5); animation: slideUp 0.3s ease-out;
}
@keyframes slideUp { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }

.banner { padding: 16px 16px; text-align: center; position: relative; }
.banner.buy { background: radial-gradient(circle at top, rgba(16,185,129,0.12), transparent 70%); }
.banner.gem { background: radial-gradient(circle at top, rgba(34, 211, 238, 0.2), transparent 70%); } 
.banner.reject { background: radial-gradient(circle at top, rgba(239,68,68,0.12), transparent 70%); }
.banner.consider { background: radial-gradient(circle at top, rgba(245,158,11,0.12), transparent 70%); }

.score-container { position: relative; width: 80px; height: 80px; margin: 0 auto 10px auto; display: flex; align-items: center; justify-content: center; }
.score-svg { position: absolute; top:0; left:0; width:100%; height:100%; transform: rotate(-90deg); }
.score-circle-bg { fill: none; stroke: rgba(255,255,255,0.05); stroke-width: 8; }
.score-circle-fg { fill: none; stroke: currentColor; stroke-width: 8; stroke-linecap: round; transition: stroke-dashoffset 1s; stroke-dasharray: 283; stroke-dashoffset: 283; }
.score-num { font-size: 32px; font-weight: 800; color: #fff; letter-spacing: -0.04em; z-index: 2; }

.gem-icon {
    position: absolute; top: -15px; right: -15px; font-size: 28px; 
    filter: drop-shadow(0 0 15px rgba(34, 211, 238, 0.8)); animation: float 3s ease-in-out infinite; display: none; 
}
.gem-icon.visible { display: block; }
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }

.decision-label {
  font-size: 13px; font-weight: 800; text-transform: uppercase; 
  padding: 6px 14px; border-radius: 99px; display: inline-block; margin-top: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.decision-label.buy { background: var(--green); color: #000; }
.decision-label.consider { background: var(--yellow); color: #000; }
.decision-label.reject { background: var(--red); color: #fff; }

#geminiQuickBadge {
    display: inline-flex; align-items: center; gap: 6px; margin-top: 10px; padding: 6px 14px; border-radius: 99px;
    background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
    color: var(--purple); font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em;
}
#geminiQuickBadge:active { transform: scale(0.96); }
.gemini-style-good { background: rgba(52, 211, 153, 0.15); border-color: var(--green); color: var(--green); }
.gemini-style-neutral { background: rgba(167, 139, 250, 0.1); border-color: var(--purple); color: var(--purple); } /* NEUTRAL (PASS) */
.gemini-style-bad { background: rgba(248, 113, 113, 0.15); border-color: var(--red); color: var(--red); }

.condition-toggle {
  display: flex; background: rgba(0,0,0,0.3); border-radius: 99px; padding: 4px; margin: 20px auto 16px auto;
  width: fit-content; border: 1px solid var(--border);
}

.category-badge {
  display: inline-block; background: rgba(167,139,250,0.15); 
  color: var(--purple); padding: 3px 8px; border-radius: 99px;
  font-size: 9px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.05em; border: 1px solid rgba(167,139,250,0.3);
}
.cond-btn { padding: 6px 16px; border-radius: 99px; font-size: 12px; font-weight: 700; color: var(--muted); cursor: pointer; }
.cond-btn.active { background: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }

.slider-container { background: rgba(0,0,0,0.2); border-radius: 12px; padding: 16px 12px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.05); }
.slider-container.collapsed { padding: 0; }
.slider-container.collapsed .slider-content { display: none; }
.adjuster-summary { padding: 12px 16px; cursor: pointer; font-size: 12px; color: var(--muted); text-align: center; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.2s; }
.adjuster-summary:hover { color: var(--blue); }
.slider-content { padding-top: 8px; }
.slider-row { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
.slider-row:last-child { margin-bottom: 0; }
.slider-header { display: flex; justify-content: space-between; font-size: 11px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; font-family: 'Inter', sans-serif; }
.slider-val { color: var(--blue); font-family: 'Inter', sans-serif; font-weight: 700; }
input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--blue); cursor: pointer; margin-top: -6px; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}
input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #333; border-radius: 2px; }

.profit-display { margin-bottom: 12px; }
.profit-val { font-size: 36px; font-weight: 600; font-family: 'JetBrains Mono', monospace; letter-spacing: -0.02em; color: #ffffff; }

.item-title { margin: 6px 0 10px 0; font-size: 14px; color: rgba(255,255,255,0.8); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; height: 40px; font-weight: 800; }

.link-row { display: flex; justify-content: center; gap: 8px; margin-bottom: 12px; }
.ext-link {
  font-size: 10px; font-weight: 700; color: var(--muted); text-decoration: none;
  background: rgba(255,255,255,0.05); padding: 6px 12px; border-radius: 6px; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1); cursor: pointer;
}
.ext-link:hover { color: #fff; border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); }

.ai-box {
  margin-bottom: 16px; padding: 12px; border-radius: 8px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3);
  font-size: 13px; line-height: 1.5; color: #fff; text-align: left; cursor: pointer; transition: background 0.2s; position: relative;
}
.details-panel { background: rgba(255,255,255,0.03); border-top: 1px solid var(--border); }
.details-summary { padding: 16px; cursor: pointer; font-size: 13px; color: var(--muted); text-align: center; font-weight: 600; }
.details-body { padding: 0 20px 20px; text-align: left; }

.insight-grid { display: grid; gap: 12px; margin-bottom: 16px; }
.insight-box { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); text-align: left; }
.insight-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.insight-tags { display: flex; flex-wrap: wrap; gap: 6px; }
.tag { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #fff; }
.tag.good { background: rgba(16,185,129,0.2); color: var(--green); }
.tag.bad { background: rgba(239,68,68,0.2); color: var(--red); }
.tag.warn { background: rgba(251,191,36,0.2); color: var(--yellow); }
.tag.gem { background: rgba(34, 211, 238, 0.15); color: var(--diamond); border: 1px solid rgba(34,211,238,0.3); box-shadow: 0 0 5px rgba(34,211,238,0.2); }

.metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px; margin-top: 12px; }
.metric { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 10px; text-align: center; }
.metric-lbl { font-size: 9px; color: var(--muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
.metric-val { font-size: 13px; font-weight: 700; color: #fff; }

.keepa-embed img { max-width: 100%; height: auto; display: block; margin: 0 auto; border-radius: 8px; }

/* TOGGLES (Restored) */
.toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.toggle-switch {
  width: 44px; height: 24px; background: #333; border-radius: 99px; position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle-switch::after {
  content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: transform 0.2s;
}
.toggle-switch.active { background: var(--green); }
.toggle-switch.active::after { transform: translateX(20px); }

/* --- PAGES --- */
#settingsPage, #historyPage {
  position: fixed; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px;
  background: var(--bg); z-index: 3000; padding: 24px;
  display: flex; flex-direction: column; border-left: 1px solid var(--border); border-right: 1px solid var(--border);
}
.settings-header { font-size: 20px; font-weight: 800; margin-bottom: 24px; text-align: center; }
.settings-content { flex: 1; overflow-y: auto; }
.settings-group { margin-bottom: 24px; }
.label { display: block; font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--muted); text-transform: uppercase; }
.settings-input { width: 100%; padding: 14px; background: var(--panel); border: 1px solid var(--border); color: white; border-radius: 12px; font-family: 'JetBrains Mono', monospace; }
.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: auto; }
.btn-main { width: 100%; padding: 16px; border-radius: 12px; border: none; font-weight: 700; font-size: 14px; cursor: pointer; }
.btn-save { background: var(--green); color: #000; }
.btn-back { background: var(--panel); color: #fff; border: 1px solid var(--border); }

.actions {
  position: fixed; bottom: 0; left: 0; right: 0; background: rgba(5,5,5,0.95); backdrop-filter: blur(10px);
  padding: 16px; border-top: 1px solid var(--border); display: flex; gap: 12px; z-index: 100; max-width: 480px; margin: 0 auto;
}
.act-btn { flex: 1; padding: 14px; border: none; border-radius: 12px; font-weight: 700; font-size: 14px; cursor: pointer; transition: transform 0.1s; }
.act-btn:active { transform: scale(0.96); }
.btn-set { flex: 0 0 50px; background: var(--panel); color: #fff; border: 1px solid var(--border); display: grid; place-items: center; font-size: 20px; }
.btn-hist { background: var(--blue); color: #fff; }
.btn-dl { background: var(--green); color: #fff; }
.btn-cam { background: rgba(34,211,238,0.2); color: var(--diamond); border: 1px solid rgba(34,211,238,0.4); font-size: 18px; }

/* === UPGRADED DESIGN CSS === */
.item-title { 
  font-size: 18px !important; font-weight: 800 !important; color: #fff !important; line-height: 1.3 !important; 
  margin-bottom: 16px !important; text-align: center !important; padding: 0 20px !important; 
  min-height: 48px !important; display: flex !important; align-items: center !important; justify-content: center !important;
  height: auto !important; -webkit-line-clamp: unset !important;
}

/* Keepa Restricted Badge */
.keepa-restricted {
  position: absolute; top: 10px; right: 10px; background: rgba(239,68,68,0.2); border: 2px solid var(--red);
  color: var(--red); font-size: 10px; font-weight: 800; padding: 4px 10px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
  animation: pulse-badge 2s ease-in-out infinite;
}
@keyframes pulse-badge { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

/* Visual Meter Pricing */
.pricing-meter {
  background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px 12px 10px; margin-bottom: 12px;
}
.meter-row { margin-bottom: 12px; text-align: center; }
.meter-row:last-child { margin-bottom: 0; }
.meter-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; letter-spacing: 0.05em;
}
.meter-value {
  font-size: 24px; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-bottom: 6px;
}
.meter-bar {
  height: 6px; background: rgba(255,255,255,0.05); border-radius: 99px; overflow: hidden; position: relative;
}
.meter-fill {
  height: 100%; border-radius: 99px; transition: width 0.3s ease;
}
.meter-fill.green { background: linear-gradient(90deg, var(--green), rgba(16,185,129,0.6)); }
.meter-fill.blue { background: linear-gradient(90deg, var(--blue), rgba(96,165,250,0.6)); }

/* Compact Sliders */
.adjusters-compact {
  background: rgba(0,0,0,0.2); border-radius: 10px; padding: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05);
}
.adjuster-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.adjuster-row:last-child { margin-bottom: 0; }
.adjuster-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--muted); min-width: 40px; letter-spacing: 0.05em;
}
.adjuster-slider { flex: 1; }
.adjuster-value {
  font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 700; color: var(--blue); min-width: 45px; text-align: right;
}

/* Why This Score Section */
.reasoning-section {
  background: rgba(255,255,255,0.03); border-radius: 10px; padding: 10px; margin-bottom: 10px;
}
.reasoning-header {
  font-size: 10px; font-weight: 800; text-transform: uppercase; color: var(--muted); margin-bottom: 8px;
  letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;
}
.signal-item {
  display: flex; align-items: flex-start; gap: 6px; margin-bottom: 6px; padding: 6px;
  background: rgba(0,0,0,0.2); border-radius: 6px;
}
.signal-item:last-child { margin-bottom: 0; }
.signal-icon { font-size: 14px; flex-shrink: 0; margin-top: 0; }
.signal-text { flex: 1; }
.signal-text strong {
  display: block; font-size: 11px; font-weight: 700; margin-bottom: 2px; line-height: 1.3;
}
.signal-text p {
  font-size: 10px; color: var(--muted); line-height: 1.3; margin: 0;
}

/* Gemini Second Opinion */
.gemini-opinion {
  background: rgba(167,139,250,0.08); border: 2px solid rgba(167,139,250,0.3); border-radius: 12px;
  padding: 12px; margin-bottom: 12px;
}
.gemini-opinion.loading {
  background: rgba(96,165,250,0.08); border-color: rgba(96,165,250,0.3);
}
.gemini-opinion.upgrade {
  background: rgba(16,185,129,0.08); border-color: rgba(16,185,129,0.4);
}
.gemini-opinion.downgrade {
  background: rgba(239,68,68,0.08); border-color: rgba(239,68,68,0.4);
}
.gemini-header {
  display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px;
  padding-bottom: 12px; border-bottom: 1px solid var(--border);
}
.collapse-icon {
  color: rgba(255,255,255,0.5); cursor: pointer; font-size: 18px; font-weight: 800;
  padding: 4px 8px; transition: all 0.2s;
}
.collapse-icon:hover {
  color: rgba(255,255,255,0.9); background: rgba(255,255,255,0.1); border-radius: 4px;
}
.gemini-content.hidden {
  display: none;
}
.gemini-title {
  font-size: 12px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.05em;
  color: var(--purple); display: flex; align-items: center; gap: 6px;
}
.gemini-title.upgrade { color: var(--green); }
.gemini-title.downgrade { color: var(--red); }
.score-comparison {
  display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;
}
.score-box { text-align: center; }
.score-box-label {
  font-size: 9px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 4px; letter-spacing: 0.05em;
}
.score-box-value {
  font-size: 28px; font-weight: 800; font-family: 'JetBrains Mono', monospace; line-height: 1;
}
.score-box-value.amber { color: var(--yellow); }
.score-box-value.green { color: var(--green); }
.score-box-value.red { color: var(--red); }
.score-arrow { font-size: 24px; font-weight: 800; }
.score-arrow.up { color: var(--green); }
.score-arrow.down { color: var(--red); }
.gemini-verdict {
  text-align: center; font-size: 11px; font-weight: 800; padding: 6px 14px; border-radius: 99px;
  text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
}
.gemini-verdict.upgrade {
  background: rgba(16,185,129,0.2); color: var(--green); border: 2px solid rgba(16,185,129,0.4);
}
.gemini-verdict.downgrade {
  background: rgba(239,68,68,0.2); color: var(--red); border: 2px solid rgba(239,68,68,0.4);
}
.gemini-text {
  font-size: 11px; line-height: 1.5; color: rgba(255,255,255,0.85); text-align: left;
}

/* === DECISION TRACKING === */
.decision-section {
  background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.1);
  border-radius: 12px; padding: 12px; margin-top: 12px;
}

.decision-prompt {
  text-align: center; font-size: 11px; font-weight: 700;
  color: rgba(255,255,255,0.9); margin-bottom: 10px;
  text-transform: uppercase; letter-spacing: 0.05em;
}

.decision-buttons {
  display: flex; gap: 8px;
}

.decision-btn {
  flex: 1; padding: 10px 16px; border-radius: 10px;
  font-size: 13px; font-weight: 800; text-transform: uppercase;
  letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s;
  border: 2px solid; display: flex; align-items: center;
  justify-content: center; gap: 6px; background: transparent;
}

.decision-btn.buy {
  background: rgba(16,185,129,0.2); color: var(--green);
  border-color: rgba(16,185,129,0.5);
}

.decision-btn.buy:hover {
  background: rgba(16,185,129,0.3); border-color: var(--green);
  transform: translateY(-2px); box-shadow: 0 4px 12px rgba(16,185,129,0.3);
}

.decision-btn.buy:active {
  transform: scale(0.98);
}

.decision-btn.pass {
  background: rgba(239,68,68,0.2); color: var(--red);
  border-color: rgba(239,68,68,0.5);
}

.decision-btn.pass:hover {
  background: rgba(239,68,68,0.3); border-color: var(--red);
  transform: translateY(-2px); box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}

.decision-btn.pass:active {
  transform: scale(0.98);
}

.decision-btn.selected {
  animation: decisionPulse 0.5s ease;
}

@keyframes decisionPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.decision-note {
  text-align: center; font-size: 11px; color: #666;
  margin-top: 10px; font-style: italic;
}

.decision-note.success {
  color: var(--green); font-weight: 700;
}

.hidden { display: none !important; }

/* --- HISTORY & COLLAPSIBLE UI --- */
.history-item-wrapper {
    position: relative;
    margin-bottom: 10px; 
    border-radius: 10px;
    overflow: hidden;
    background: var(--panel);
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all 0.2s;
}

.history-item-content {
    padding: 12px;
    transition: transform 0.3s;
}

.delete-confirm-overlay {
    position: absolute;
    inset: 0;
    display: none; 
    background: rgba(248, 113, 113, 0.15);
    padding: 12px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
}

.delete-confirm-overlay.active {
    display: flex;
}

.delete-message {
    font-size: 13px;
    font-weight: 800;
    color: var(--red);
    margin-bottom: 10px;
}

.confirm-buttons {
    display: flex;
    gap: 10px;
    width: 100%;
}

.btn-delete-confirm {
    flex: 1;
    padding: 8px 12px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 12px;
    cursor: pointer;
    transition: transform 0.1s;
}

.btn-delete-confirm.cancel {
    background: var(--card);
    color: #fff;
    border: 1px solid var(--border);
}

.btn-delete-confirm.delete {
    background: var(--red);
    color: #fff;
    border: none;
}

/* --- NEW COLLAPSIBLE PRICE DETAILS --- */
#priceDetailsContainer {
    margin-top: 10px;
    border-radius: 10px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
    cursor: pointer;
}

#priceDetailsSummary {
    padding: 10px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    color: var(--muted);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
}

#priceDetailsSummary:hover {
    background: rgba(255,255,255,0.1);
}

#priceDetailsBody {
    display: none; /* Controlled by JS toggle */
    padding: 12px 10px;
    border-top: 1px solid rgba(255,255,255,0.1);
    background: rgba(0,0,0,0.2);
}

#priceDetailsBody.active {
    display: block;
}

.price-metric-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 12px;
}

.price-metric-label {
    color: var(--muted);
    font-weight: 600;
}

.price-metric-value {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
}

.price-metric-value.fba { color: var(--green); }
.price-metric-value.fbm { color: var(--yellow); }
.price-metric-value.amz { color: var(--blue); }
.price-metric-value.none { color: var(--red); }
</style>
</head>
<body>

<div id="splash-screen">
    <div class="splash-bg">
        <div style="position:absolute; inset:0; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);"></div>
    </div>
    <div class="splash-content">
        <h1 class="big-title">
            <span>PRETTY</span>
            <span>GOOD</span>
            <span>SOURCING</span>
            <span>APP</span>
        </h1>
        <div style="margin-top: 2rem; color: #888; letter-spacing: 0.2em; font-size: 0.8rem; font-weight: 600;">INITIALIZING...</div>
    </div>
</div>

<div class="app">
  <div id="mainView">
    <header>
      <div class="status-row">
        <div id="badgeKeepa" class="status-badge dead"><div class="status-dot"></div> Keepa</div>
        <div id="badgeGemini" class="status-badge dead"><div class="status-dot"></div> Gemini</div>
      </div>

      <div class="search-container">
        <div class="input-wrapper">
            <i class="fas fa-search search-icon"></i> 
            <input id="scanInput" type="text" placeholder="Type ISBN or Title, then search..." autocomplete="off" onkeyup="if(event.key === 'Enter') submitSearch()" />
        </div>
        <button id="btnSearch" class="icon-btn" onclick="submitSearch()" title="Search"><i class="fas fa-search"></i></button>
        <button id="btnLock" class="icon-btn" onclick="toggleFocusLock()" title="Focus Lock"><i class="fas fa-lock"></i></button>
      </div>
    </header>

    <div id="camera-overlay" class="hidden">
      <div id="camera-header">
        <div class="camera-title">üì∑ Scan Book</div>
        <div id="camera-status" class="camera-status">Ready to scan...</div>
        
        <div class="camera-mode-toggle">
          <button id="mode-barcode" class="mode-btn active" onclick="switchScanMode('barcode')">
            üìä Barcode
          </button>
          <button id="mode-isbn" class="mode-btn" onclick="switchScanMode('isbn')">
            üî¢ ISBN Text
          </button>
        </div>
      </div>
      
      <div id="reader"></div>
      
      <div class="scan-frame" id="scan-frame-barcode">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="scan-line"></div>
      </div>
      
      <div class="scan-frame isbn-frame hidden" id="scan-frame-isbn">
        <div class="scan-corner top-left"></div>
        <div class="scan-corner top-right"></div>
        <div class="scan-corner bottom-left"></div>
        <div class="scan-corner bottom-right"></div>
        <div class="isbn-hint">Position ISBN number here</div>
      </div>
      
      <div class="camera-footer">
        <button id="close-camera" onclick="stopCamera()">
          <i class="fas fa-times"></i> Close
        </button>
      </div>
    </div>

    <div id="processing" class="hidden" style="text-align:center; padding:60px;">
      <i class="fas fa-circle-notch fa-spin" style="font-size:32px; color:var(--blue);"></i>
    </div>

    <div id="scanToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:8px 16px; border-radius:99px; font-weight:bold; z-index:200;">
        Scan Detected!
    </div>

    <div id="exportToast" class="hidden" style="position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--green); color:black; padding:12px 20px; border-radius:99px; font-weight:bold; z-index:200; font-size:14px;">
        Export Complete!
    </div>

    <div class="card hidden" id="titlePickerCard">
      <div class="banner maybe">
        <div style="font-size:12px; font-weight:800; letter-spacing:0.12em; color:var(--muted); text-transform:uppercase; margin-bottom:10px;">
          Title results
        </div>
        <div style="font-size:14px; font-weight:800; margin-bottom:6px;">Pick an edition</div>
        <div id="titlePickerHint" style="font-size:12px; color:rgba(255,255,255,0.75); line-height:1.45; margin-bottom:14px;">
          Click the ID button to copy the ASIN/ISBN, then hit the Search button to fetch product data.
        </div>
        <div id="titlePickerList" style="text-align:left; margin-top:6px;"></div>
        <div style="display:flex; gap:10px; margin-top:14px; justify-content:center;">
          <button class="ext-link" onclick="closeTitlePicker()">Close ‚úñ</button>
        </div>
      </div>
    </div>


    <div class="card hidden" id="resultCard">
      <div id="banner" class="banner buy">
        <div id="keepaRestricted" class="keepa-restricted hidden">‚ö†Ô∏è RESTRICTED</div>
        
        <div id="gemIcon" class="gem-icon">üíé</div>
        
        <div style="text-align: center; margin-bottom: 6px;">
          <div id="categoryBadge" class="category-badge">üìö Category Loading...</div>
        </div>
        
        <div id="itemTitle" class="item-title">--</div>
        
        <div class="score-container">
          <svg class="score-svg" viewBox="0 0 100 100">
            <circle class="score-circle-bg" cx="50" cy="50" r="45" fill="none"></circle>
            <circle class="score-circle-fg" id="scoreRing" cx="50" cy="50" r="45" fill="none"></circle>
          </svg>
          <span id="confidence" class="score-num">--</span>
        </div>
        
        <div id="decision" class="decision-label">--</div>
        
        <div style="text-align:center;">
            <div id="geminiQuickBadge" onclick="toggleAI()" class="hidden">
                <i class="fas fa-sparkles"></i> <span>ASK GEMINI</span>
            </div>
        </div>
      </div>
      
      <div style="padding: 16px;">
        <div id="geminiOpinion" class="hidden"></div>

        <div class="pricing-meter">
          <div class="meter-row">
            <div class="meter-label">Recommended Sell Price</div>
            <div class="meter-value" id="recommendedPrice" style="color: var(--blue);">$0.00</div>
            <div class="meter-bar">
              <div class="meter-fill blue" id="priceFill" style="width: 0%;"></div>
            </div>
          </div>
          
          <div id="priceDetailsContainer" onclick="togglePriceDetails()">
            <div id="priceDetailsSummary">
                <span id="priceDetailsChevron" class="fas fa-chevron-down"></span>
                <span>Price Details & Buy Box</span>
            </div>
            <div id="priceDetailsBody">
                <div class="price-metric-row">
                    <span class="price-metric-label">Buy Box Price (<span id="bbCond">--</span>)</span>
                    <span class="price-metric-value" id="bbPriceVal">--</span>
                </div>
                <div class="price-metric-row">
                    <span class="price-metric-label">Buy Box Owner</span>
                    <span class="price-metric-value" id="bbWinnerVal">--</span>
                </div>
            </div>
          </div>
          <div class="meter-row">
            <div class="meter-label">Your Profit</div>
            <div class="meter-value" id="profitValue">$0.00</div>
            <div class="meter-bar">
              <div class="meter-fill green" id="profitFill" style="width: 0%;"></div>
            </div>
          </div>
        </div>

        <div class="condition-toggle">
          <div id="btnCondUsed" class="cond-btn active" onclick="setCondition('USED')">Used</div>
          <div id="btnCondNew" class="cond-btn" onclick="setCondition('NEW')">New</div>
        </div>

        <div class="adjusters-compact">
          <div class="adjuster-row">
            <span class="adjuster-label">Cost</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="50" step="0.25" value="1" id="sliderCost" />
            </div>
            <span class="adjuster-value" id="costValue">$1.00</span>
          </div>
          <div class="adjuster-row">
            <span class="adjuster-label">Floor</span>
            <div class="adjuster-slider">
              <input type="range" min="0" max="20" step="0.5" value="5" id="sliderFloor" />
            </div>
            <span class="adjuster-value" id="floorValue">$5.00</span>
          </div>
        </div>

        <div class="reasoning-section">
          <div class="reasoning-header">
            <span>üí°</span>
            <span>Why This Score?</span>
          </div>
          <div id="bbSummaryBox" style="background:rgba(96,165,250,0.1); border:1px solid var(--blue); padding:10px; border-radius:6px; margin-bottom:10px;">
              <div style="font-size:11px; font-weight:700; color:var(--blue); margin-bottom:4px;">BUY BOX STATUS</div>
              <div id="bbStatusText" style="font-size:12px; line-height:1.4;">--</div>
          </div>
          <div id="reasoningContent"></div>
        </div>
        
        <div class="link-row">
          <button id="linkAmz" class="ext-link" onclick="openAmazonOffers()">Open Offers ‚Üó</button>
          <button id="linkKeepa" class="ext-link" onclick="toggleKeepa()">View Graph üìâ</button>
        </div>

        <div id="keepaGraphContainer" class="keepa-embed hidden">
          <div style="text-align:center; padding:10px; color:#333; font-size:12px;">Loading Graph...</div>
        </div>

        <div class="decision-section hidden" id="decisionSection">
          <div class="decision-prompt">üìã What's Your Decision?</div>
          <div class="decision-buttons">
            <button class="decision-btn buy" onclick="recordDecision('BOUGHT')">
              <span>‚úì</span>
              <span>BUY</span>
            </button>
            <button class="decision-btn pass" onclick="recordDecision('PASSED')">
              <span>‚úó</span>
              <span>REJECT</span>
            </button>
          </div>
          <div class="decision-note" id="decisionNote">Your decision will be saved with this scan</div>
        </div>

      </div>
    </div>
  </div>

  <div id="settingsPage" class="hidden">
    <div class="settings-header">Settings</div>
    <div class="settings-content">
      <div class="settings-group">
        <span class="label">Keepa API Key</span>
        <input type="password" id="keepaKey" class="settings-input" placeholder="Paste Keepa key..." />
      </div>

      <div class="settings-group">
        <span class="label">Gemini API Key</span>
        <input type="password" id="geminiKey" class="settings-input" placeholder="Paste Gemini API key..." />
      </div>
      
      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Use Proxy Server</span>
          <div id="toggleProxy" class="toggle-switch active" onclick="toggleSetting('useProxy')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Turn OFF if you have a CORS extension installed. Direct is faster.</div>
      </div>

      <div class="settings-group">
        <div class="toggle-row">
          <span class="label" style="margin:0;">Fast Scan (90 Days)</span>
          <div id="toggleFastScan" class="toggle-switch" onclick="toggleSetting('fastScan')"></div>
        </div>
        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Fetches less data for speed. Good for live scanning.</div>
      </div>

      <div class="settings-group">
        <span class="label">Default Buy Cost ($)</span>
        <input type="number" id="defCost" class="settings-input" value="1.00" step="0.25" />
      </div>
      <div class="settings-group">
        <span class="label">Default Profit Floor ($)</span>
        <input type="number" id="defFloor" class="settings-input" value="5.00" step="0.50" />
      </div>
    </div>
    <div class="btn-grid">
      <button onclick="closeSettings()" class="btn-main btn-back">Cancel</button>
      <button onclick="saveSettings()" class="btn-main btn-save">Save</button>
    </div>
  </div>

  <div id="historyPage" class="hidden">
    <div class="settings-header">Scan History</div>
    <div id="historyList" style="flex:1; overflow-y:auto;"></div>
    <div class="btn-grid" style="margin-top:16px;">
      <button onclick="closeHistory()" class="btn-main btn-back">Back</button>
      <button onclick="exportCSV()" class="btn-main btn-save">Download All CSV</button>
    </div>
    <button onclick="clearHistory()" class="btn-main" 
        style="background: transparent; color: var(--red); border: 1px solid var(--red); margin-top: 10px;">
        <i class="fas fa-trash"></i> Clear All History
    </button>
  </div>

  <div class="actions">
    <button onclick="showSettings()" class="act-btn btn-set"><i class="fas fa-cog"></i></button>
    <button onclick="showHistory()" class="act-btn btn-hist" style="flex: 2;">History</button>
    <button onclick="openCamera()" class="act-btn btn-cam"><i class="fas fa-camera"></i></button>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
let CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || '',
  geminiKey: localStorage.getItem('geminiKey') || '',
  buyCost: parseFloat(localStorage.getItem('buyCost')) || 1.00,
  profitFloor: parseFloat(localStorage.getItem('profitFloor')) || 5.00,
  condition: 'USED',
  useProxy: localStorage.getItem('useProxy') !== 'false', 
  fastScan: localStorage.getItem('fastScan') === 'true' 
};

let lastData = null;
let focusLock = false;
let scanQueue = [];
let scanHistory = JSON.parse(localStorage.getItem('scanHistory') || '[]');
let currentScan = null; // Tracks current scan for decision recording
let isProcessing = false;
let tokens = 20; 
let tokenRefill = setInterval(() => { if(tokens < 20) tokens++; updateTokenUI(); }, 3000); 

/* ================= INIT ================= */
const input = document.getElementById('scanInput');
const costSlider = document.getElementById('sliderCost');
const floorSlider = document.getElementById('sliderFloor');
const geminiReasoningHeader = document.getElementById('geminiReasoningHeader');

window.addEventListener('load', () => {
    updateTokenUI();
    resetSliders();
    updateConditionUI();
    updateToggleUI('toggleProxy', CONFIG.useProxy);
    updateToggleUI('toggleFastScan', CONFIG.fastScan);
    input.focus();
    
    document.addEventListener('click', (e) => {
        if(focusLock && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
            input.focus();
        }
    });
});

function resetSliders() {
    costSlider.value = CONFIG.buyCost;
    floorSlider.value = CONFIG.profitFloor;
    updateSliderDisplays();
}

function updateTokenUI() {
    const el = document.getElementById('badgeKeepa');
    if(CONFIG.keepaKey) {
        el.className = 'status-badge live';
        el.innerHTML = `<div class="status-dot"></div> Keepa: ${tokens}`;
    } else {
        el.className = 'status-badge dead';
        el.innerHTML = `<div class="status-dot"></div> Keepa`;
    }
}

function updateConditionUI() {
    document.getElementById('badgeGemini').className = CONFIG.geminiKey ? 'status-badge live' : 'status-badge dead';
}

function updateToggleUI(id, state) {
    const el = document.getElementById(id);
    if(el) {
        if(state) el.classList.add('active'); else el.classList.remove('active');
    }
}

function toggleSetting(key) {
    CONFIG[key] = !CONFIG[key];
    updateToggleUI(key === 'useProxy' ? 'toggleProxy' : 'toggleFastScan', CONFIG[key]);
}

/* ================= SLIDERS ================= */
function onSliderChange() {
  CONFIG.buyCost = parseFloat(costSlider.value);
  CONFIG.profitFloor = parseFloat(floorSlider.value);
  updateSliderDisplays();
  if(lastData) {
    const result = analyze(lastData);
    render(result, lastData);
  }
}
costSlider.addEventListener('input', onSliderChange);
floorSlider.addEventListener('input', onSliderChange);

/* ================= INPUT HANDLING / TITLE SEARCH (FIXED) ================= */
let titleResults = [];

async function submitSearch() {
    const val = input.value.trim();
    if(!val) return;

    // --- ENHANCED ID CHECK ---
    // Check if original has spaces - if so, likely a title unless it's a formatted ISBN
    const hasSpaces = /\s/.test(val);
    
    // Remove hyphens and spaces for validation
    const cleaned = val.replace(/[-\s]/g, '');
    const upper = cleaned.toUpperCase();
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(cleaned);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    // We prioritize ASIN because that's what Keepa search results return
    const is10DigitNumeric = /^\d{10}$/.test(cleaned);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(cleaned);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    const isISBN = isISBN13 || isISBN10WithX;
    
    // ASIN: 10 alphanumeric chars (including 10-digit all-numeric old ASINs)
    const isASIN = /^[A-Z0-9]{10}$/.test(upper) && !isISBN;
    
    // SAFETY: If it had spaces and isn't a valid ISBN/ASIN, treat as title
    const shouldSearchByTitle = hasSpaces && !isISBN && !isASIN;
    
    console.log('submitSearch:', { val, cleaned, upper, hasSpaces, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, isASIN, shouldSearchByTitle });
    
    if(shouldSearchByTitle) {
        console.log('Has spaces and not valid ID, searching as title:', val);
        input.value = ''; 
        await searchByTitle(val);
    } else if(isASIN || isISBN) {
        console.log('Detected as ID, adding to queue:', upper);
        closeTitlePicker(); 
        addToQueue(upper);
        input.value = '';
    } else {
        console.log('Detected as title, searching:', val);
        input.value = ''; 
        await searchByTitle(val);
    }
}

function normalizeTitleKey(s) {
    return (s || '').toLowerCase().replace(/\s+/g, ' ').trim();
}

function showTitlePickerLoading(query) {
    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Searching editions for: "${query}"`;
    list.innerHTML = `
      <div style="padding:12px; color:var(--muted); font-size:12px; display:flex; gap:10px; align-items:center;">
        <i class="fas fa-circle-notch fa-spin" style="color:var(--blue)"></i>
        <span>Looking up editions via Keepa...</span>
      </div>
    `;
    card.classList.remove('hidden');
    const keepaCard = document.getElementById('resultCard');
    if(keepaCard) keepaCard.classList.add('hidden');
}

// Function to handle the copying of the ISBN/ASIN
function copyIdAndFocus(id, title) {
    console.log('copyIdAndFocus called with:', { id, title });
    const inputField = document.getElementById('scanInput');
    
    // Copy to clipboard
    if (navigator.clipboard) {
        navigator.clipboard.writeText(id).catch(err => {
            console.error('Could not copy text: ', err);
        });
    }
    
    // Close the title picker
    closeTitlePicker();
    
    // Put the ID in the search field
    inputField.value = id;
    console.log('Input field set to:', inputField.value);
    
    // Automatically trigger the search
    console.log('Calling submitSearch...');
    submitSearch();
}


function renderTitlePicker(query, results) {
    isProcessing = false;
    const p = document.getElementById('processing');
    if (p) p.classList.add('hidden');

    const card = document.getElementById('titlePickerCard');
    const list = document.getElementById('titlePickerList');
    const hint = document.getElementById('titlePickerHint');
    if(!card || !list || !hint) return;

    hint.innerText = `Select the right edition for: "${query}"`;
    card.classList.remove('hidden');

    const key = normalizeTitleKey(query);
    const lastKey = localStorage.getItem('lastTitlePickKey') || '';
    const lastIsbn = localStorage.getItem('lastTitlePickIsbn') || '';
    
    let sorted = [...results];
    if(lastKey && lastIsbn && lastKey === key) {
        const idx = sorted.findIndex(r => r.isbn === lastIsbn);
        if(idx > 0) {
            const [hit] = sorted.splice(idx, 1);
            sorted.unshift(hit);
        }
    }

    list.innerHTML = sorted.map((r) => {
        const thumb = r.thumbnail ? `<img src="${r.thumbnail}" alt="" style="width:44px;height:66px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,0.12);" />`
                                  : `<div style="width:44px;height:66px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.04);display:grid;place-items:center;color:rgba(255,255,255,0.25);font-size:14px;">${r.isbnType === 'BOOK' ? 'üìò' : 'üì¶'}</div>`;

        const pill = (lastKey === key && lastIsbn === r.isbn) ? `<span class="tag good" style="margin-left:8px;">Last Pick</span>` : '';
        const binding = String(r.editionLabel || 'Product').replace(/\b\w/g, c => c.toUpperCase());
        const idLabel = (r.isbnType === 'BOOK' && r.isbn.length >= 10 && r.isbn.length <= 13) ? 'ISBN' : 'ASIN/ID';
        
        const displayYear = r.published ? String(r.published).substring(0,4) : 'N/A';
        const safeTitle = escapeHtml(r.title || 'Unknown');
        const safeISBN = escapeHtml(r.isbn);


        return `
          <div style="display:flex; gap:12px; padding:12px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); border-radius:14px; margin-bottom:10px;">
            ${thumb}
            <div style="flex:1; min-width:0;">
              <div style="font-weight:800; font-size:13px; line-height:1.2; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${safeTitle}${pill}
              </div>
              <div style="font-size:11px; color:rgba(255,255,255,0.7); margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${escapeHtml(r.authors || '')} ${r.published ? ' ‚Ä¢ ' + displayYear : ''}
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                <span class="tag warn">${binding}</span>
                <span class="tag" style="background:rgba(96,165,250,0.15);color:var(--blue);border:1px solid rgba(96,165,250,0.25);">${idLabel}: ${safeISBN}</span>
              </div>
            </div>
            <button class="ext-link" style="align-self:flex-start; margin-top:5px; padding:8px 12px; font-size:11px; font-weight:700;" 
                    onclick="copyIdAndFocus('${safeISBN}', '${safeTitle}')" title="Run Analysis">
              Run Item <i class="fas fa-play"></i>
            </button>
          </div>
        `;
    }).join('');

    titleResults = sorted;
}

function closeTitlePicker() {
    const card = document.getElementById('titlePickerCard');
    if(card) card.classList.add('hidden');
    titleResults = [];
}

function fireKeepaFromTitle(encodedKey, encodedIsbn) {
    // This function is now OBSOLETE/NOT USED in v10.14, replaced by copyIdAndFocus
    // but kept as a placeholder if you wish to restore direct click search later.
    const key = decodeURIComponent(encodedKey || '');
    const isbn = decodeURIComponent(encodedIsbn || '');
    if(!isbn) return;

    localStorage.setItem('lastTitlePickKey', key);
    localStorage.setItem('lastTitlePickIsbn', isbn);

    closeTitlePicker();
    addToQueue(isbn); 
}

function escapeHtml(s) {
    return String(s ?? '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
}

async function searchByTitle(title) {
    console.log('searchByTitle called with:', title);
    
    if(!CONFIG.keepaKey) {
        alert("Keepa Error: API Key is missing. Please enter your key in Settings.");
        return;
    }

    try {
        document.getElementById('processing').classList.remove('hidden');
        showTitlePickerLoading(title);

        const url = `https://api.keepa.com/search?key=${CONFIG.keepaKey}&domain=1&type=product&term=${encodeURIComponent(title)}`;
        console.log('searchByTitle: Fetching from Keepa...', { useProxy: CONFIG.useProxy });
        
        const fetchKeepaSearch = async (u) => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 9000);
            try {
                let finalUrl = u;
                
                // Try with proxy if enabled
                if(CONFIG.useProxy) {
                    try {
                        finalUrl = `https://corsproxy.io/?${encodeURIComponent(u)}`;
                        console.log('Trying primary proxy...');
                        const res = await fetch(finalUrl, { signal: controller.signal });
                        if(res.ok) {
                            const json = await res.json();
                            if(!json.error) {
                                console.log('Primary proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                        // If proxy fails, try backup
                        console.log("Primary proxy failed for search, trying backup...");
                        finalUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`;
                        const res2 = await fetch(finalUrl, { signal: controller.signal });
                        if(res2.ok) {
                            const json = await res2.json();
                            if(!json.error) {
                                console.log('Backup proxy success, got', json.products?.length, 'results');
                                return json;
                            }
                        }
                    } catch(proxyErr) {
                        console.log("Proxies failed, trying direct...", proxyErr);
                    }
                    // Fall through to direct if proxies fail
                    finalUrl = u;
                }
                
                // Direct fetch (or fallback from proxy failure)
                console.log('Trying direct fetch...');
                const res = await fetch(finalUrl, { signal: controller.signal });
                if(!res.ok) throw new Error(`HTTP ${res.status}`);
                const json = await res.json();
                
                if (json.error) throw new Error(json.error.message);
                console.log('Direct fetch success, got', json.products?.length, 'results');
                return json;
                
            } finally {
                clearTimeout(timeout);
            }
        };

        const data = await fetchKeepaSearch(url);
        
        if(!data.products || data.products.length === 0) {
            console.log('No products found');
            closeTitlePicker();
            document.getElementById('processing').classList.add('hidden');
            alert(`No products found for: "${title}" on Keepa.`);
            return;
        }

        console.log('Processing', data.products.length, 'products...');
        
        // --- Adapt Keepa results for Title Picker UI ---
        let results = data.products.map(p => {
            const authors = (p.manufacturer || p.brand || '').split(',').map(a => a.trim()).join(', ');
            const id = p.asin; 
            const pubDate = p.publicationDate || '';
            const thumbnail = p.images?.[0]?.url || null;

            if(!id) {
                console.warn('Product missing ASIN:', p);
            }

            return {
                title: p.title || 'Unknown',
                authors: authors,
                published: pubDate, 
                isbn: id, 
                isbnType: p.productType, 
                editionLabel: p.binding || p.productType, 
                pref: p.productType === 'BOOK' ? 5 : 1, 
                thumbnail: thumbnail
            };
        }).filter(r => r.isbn); // Filter out any without IDs
        
        const parseYear = (d) => {
            const m = String(d || '').match(/^(\d{4})/);
            return m ? parseInt(m[1], 10) : 0;
        };

        results.sort((a,b) => {
            if(b.pref !== a.pref) return b.pref - a.pref;
            return parseYear(b.published) - parseYear(a.published);
        });

        console.log('Rendering title picker with', results.length, 'results');
        renderTitlePicker(title, results);

    } catch(e) {
        console.error('searchByTitle error:', e);
        closeTitlePicker();
        alert(`Keepa Search Error: ${e.message}. \n\nTip: Check your API key and try toggling the Proxy setting.`);
    } finally {
        document.getElementById('processing').classList.add('hidden');
    }
}


function toggleFocusLock() {
    focusLock = !focusLock;
    document.getElementById('btnLock').classList.toggle('active', focusLock);
    if(focusLock) input.focus();
}

function addToQueue(query) {
    console.log('addToQueue:', query, 'Queue length:', scanQueue.length, 'isProcessing:', isProcessing);
    scanQueue.push(query);
    processQueue();
}

async function processQueue() {
    console.log('processQueue called. isProcessing:', isProcessing, 'Queue length:', scanQueue.length);
    if(isProcessing || scanQueue.length === 0) {
        console.log('processQueue exiting early:', { isProcessing, queueEmpty: scanQueue.length === 0 });
        return;
    }
    
    if(tokens <= 0) {
        setTimeout(processQueue, 3000);
        return;
    }

    isProcessing = true;
    const query = scanQueue.shift();
    
    document.getElementById('processing').classList.remove('hidden');
    document.getElementById('resultCard').classList.add('hidden');
    
    const safety = setTimeout(() => {
        if(isProcessing) {
            isProcessing = false;
            document.getElementById('processing').classList.add('hidden');
            alert("Scan Timed Out (Network too slow)");
        }
    }, 15000); // Increased timeout to 15s to allow for retries

    let attempts = 0;
    const maxAttempts = 2;
    const is10DigitNumeric = /^\d{10}$/.test(query.replace(/-/g,''));
    
    while(attempts < maxAttempts) {
        try {
            if(tokens > 0 && attempts === 0) tokens--; // Only decrement on first attempt
            updateTokenUI();
            
            // On second attempt for 10-digit numeric, try as ISBN instead of ASIN
            const retryAsISBN = (attempts === 1 && is10DigitNumeric);
            const data = await fetchKeepa(query, retryAsISBN);
            
            clearTimeout(safety);
            lastData = data;
            const result = analyze(data);
            render(result, data);
            addToHistory(result, data);
            
            // FIX #2: Clear input after camera scan so it doesn't block future scans
            setTimeout(() => {
                document.getElementById('scanInput').value = '';
            }, 100);
            
            break; // Success, exit retry loop
            
        } catch(e) {
            attempts++;
            console.log(`Attempt ${attempts} failed:`, e.message);
            
            // For 10-digit numeric codes, if first attempt (as ASIN) fails with "Product Not Found", try as ISBN
            if(attempts === 1 && is10DigitNumeric && e.message.includes("Product Not Found")) {
                console.log('10-digit numeric failed as ASIN, will retry as ISBN...');
                continue; // Retry immediately
            }
            
            if(attempts >= maxAttempts) {
                clearTimeout(safety);
                // More helpful error message based on error type
                let tipMsg = "Tip: Check your Keepa API Key and try toggling the Proxy setting.";
                if(e.message.includes("CORS")) {
                    tipMsg = "Tip: Try enabling 'Use Proxy Server' in Settings.";
                } else if(e.message.includes("Invalid product code") || e.message.includes("Product Not Found")) {
                    tipMsg = "Tip: This ISBN/ASIN may not exist in Amazon's catalog.";
                } else if(e.message.includes("HTTP 429")) {
                    tipMsg = "Tip: You may have exceeded Keepa's rate limit. Wait a moment and try again.";
                }
                alert(`Error: ${e.message}\n\n${tipMsg}`);
            } else {
                // Wait briefly before retry
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }
    
    isProcessing = false;
    document.getElementById('processing').classList.add('hidden');
    
    // --- FINAL AUTOSCROLL FIX (Double-Check Scroll) ---
    // Executes scrolling twice with a tiny delay to overcome browser resistance on mobile.
    setTimeout(() => {
        window.scrollTo({ top: 0, behavior: 'smooth' }); 
        
        // Secondary check right after the first one is registered
        setTimeout(() => {
            window.scrollTo({ top: 0, behavior: 'smooth' }); 
        }, 50); // Wait 50ms for the second check
    }, 10); // Start the process immediately after hiding the spinner
    // ----------------------------------------------------
    
    if(scanQueue.length > 0) setTimeout(processQueue, 2500);
}

function clearHistory() {
    if(!confirm('Clear all scan history? This cannot be undone.')) return;
    
    scanHistory = [];
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    const list = document.getElementById('historyList');
    if(list) list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
}

function clearScan() {
    input.value = '';
    document.getElementById('resultCard').classList.add('hidden');
    isProcessing = false;
    scanQueue = [];
    document.getElementById('processing').classList.add('hidden');
    input.focus();
}

/* ================= KEEPA API ================= */
async function fetchKeepa(query, retryAsISBN = false) {
    if(!CONFIG.keepaKey) throw new Error("No API Key");
    
    const clean = query.replace(/-/g,'');
    const days = 180; 
    
    // ISBN-13: Must start with 978 or 979
    const isISBN13 = /^97[89]\d{10}$/.test(clean);
    
    // Check if it's 10-digit all-numeric (ambiguous - could be ISBN-10 or ASIN)
    const is10DigitNumeric = /^\d{10}$/.test(clean);
    
    // ISBN-10: 9 digits + X (the only unambiguous ISBN-10 format)
    const isISBN10WithX = /^\d{9}X$/i.test(clean);
    
    // Only treat as ISBN if it's definitely ISBN-13 or ISBN-10 with X
    // OR if we're retrying a 10-digit numeric as ISBN
    const isISBN = isISBN13 || isISBN10WithX || (retryAsISBN && is10DigitNumeric);
    
    // Everything else is ASIN (including 10-digit all-numeric on first try)
    const paramName = isISBN ? 'code' : 'asin';
    
    let url = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=1&${paramName}=${clean}&stats=${days}&history=0`;
    
    console.log('fetchKeepa:', { query, clean, isISBN13, isISBN10WithX, is10DigitNumeric, isISBN, paramName, retryAsISBN, url: url.replace(CONFIG.keepaKey, 'KEY_HIDDEN') });

    // PROXY FAILOVER
    if(CONFIG.useProxy) {
        try {
            const proxy1 = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), 5000);
            
            const res = await fetch(proxy1, { signal: controller.signal });
            clearTimeout(id);
            if(res.ok) {
                const json = await res.json();
                return parseKeepaJson(json, true);
            }
        } catch(e) {
            console.log("Proxy 1 failed, trying backup...");
        }
        
        try {
            const proxy2 = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const res2 = await fetch(proxy2);
            if(!res2.ok) throw new Error("Proxy 2 failed");
            const json = await res2.json();
            return parseKeepaJson(json, true);
        } catch(e2) {
            console.log("Both proxies failed, trying direct fetch...");
        }
        
        // LAST RESORT: Try direct fetch (might fail due to CORS)
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e3) {
            throw new Error("Connection Failed: All proxies down and direct fetch blocked by CORS. Try disabling 'Use Proxy Server' in Settings.");
        }
        
    } else {
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error(`Keepa API Error: HTTP ${res.status}`);
            const json = await res.json();
            return parseKeepaJson(json, true);
        } catch(e) {
            throw new Error(`Failed to fetch from Keepa: ${e.message}`);
        }
    }
}

function parseKeepaJson(json, isID) {
    console.log('parseKeepaJson called with:', json);
    if(json.error) throw new Error(json.error.message);
    let product;
    if(!json.products || !json.products.length) {
        console.error('Keepa returned no products. Full response:', json);
        throw new Error("Product Not Found - Keepa returned no products for this ID");
    }
    product = json.products[0];
    
    return parseProduct(product);
}

function parseProduct(p) {
    const s = p.stats.current;
    const avg = p.stats.avg90 || [];
    const toPrice = (v) => (v && v > 0) ? v / 100 : 0;
    const toVal = (v) => (v == -1 || v == null) ? 0 : v;
    
    // Check for restriction flag
    const isRestricted = p.hazMat === 1 || 
                       (p.title && /international edition|instructor|review copy|not for resale|teacher edition/i.test(p.title));
    
    return {
        title: p.title || "Unknown",
        asin: p.asin,
        isbn: p.eanList?.[0] || '',
        rank: toVal(s[3]),
        avgRank: toVal(avg[3]),
        drops30: p.stats.salesRankDrops30 || 0,
        drops90: p.stats.salesRankDrops90 || 0,
        drops180: p.stats.salesRankDrops180 || 0,
        drops360: p.stats.salesRankDrops360 || 0,
        newPrice: toPrice(s[1]),
        usedPrice: toPrice(s[2]),
        fbaPrice: toPrice(s[10]),
        amzPrice: toPrice(s[0]),
        buyBoxPrice: toPrice(s[18]),
        avgNew: toPrice(avg[1]),
        avgUsed: toPrice(avg[2]),
        avgBb: toPrice(avg[18]),
        weight: p.packageWeight ? p.packageWeight / 100 : 1,
        fbaCount: toVal(s[16]) || 0,
        totalOffers: toVal(s[11]) || 0,
        category: p.categoryTree?.[0]?.name || 'Unknown',
        reviewCount: p.reviewCount || 0,
        rating: p.rating || 0,
        restricted: isRestricted
    };
}

/* ================= CATEGORY ICON HELPER ================= */
function getCategoryIcon(category) {
    const cat = (category || '').toLowerCase();
    
    if(cat.includes('book')) return 'üìö';
    if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) return 'üíø';
    if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray') || cat.includes('movie')) return 'üé¨';
    if(cat.includes('video game') || cat.includes('game')) return 'üéÆ';
    if(cat.includes('toy')) return 'üß∏';
    if(cat.includes('electronic')) return 'üì±';
    if(cat.includes('home') || cat.includes('kitchen')) return 'üè†';
    if(cat.includes('sport')) return '‚öΩ';
    if(cat.includes('clothing') || cat.includes('apparel')) return 'üëï';
    if(cat.includes('health') || cat.includes('beauty')) return 'üíä';
    
    return 'üì¶'; // Default for unknown categories
}

/* ================= CATEGORY-AWARE RANK THRESHOLDS ================= */
function getRankThresholds(category) {
    const cat = (category || '').toLowerCase();
    
    // Each category has different rank scales
    if(cat.includes('book')) {
        return { good: 500000, decent: 2000000, poor: 5000000 };
    } else if(cat.includes('music') || cat.includes('cd') || cat.includes('vinyl')) {
        return { good: 200000, decent: 800000, poor: 2000000 };
    } else if(cat.includes('video') || cat.includes('dvd') || cat.includes('blu-ray')) {
        return { good: 300000, decent: 1200000, poor: 3000000 };
    } else if(cat.includes('video game')) {
        return { good: 100000, decent: 500000, poor: 1500000 };
    } else if(cat.includes('toy')) {
        return { good: 300000, decent: 1500000, poor: 4000000 };
    } else {
        // Default for unknown categories
        return { good: 500000, decent: 2000000, poor: 5000000 };
    }
}

/* ================= CATEGORY-AWARE FEE CALCULATION ================= */
function calculateFees(price, weight, category) {
    const closingFee = 1.80;
    let referralFee = 0;
    let fulfillmentFee = 0;
    
    // Determine category type
    const cat = (category || '').toLowerCase();
    const isBooks = cat.includes('book');
    const isMedia = cat.includes('music') || cat.includes('video') || cat.includes('dvd') || cat.includes('cd') || cat.includes('vinyl') || cat.includes('blu-ray');
    const isGames = cat.includes('game') || cat.includes('toy');
    
    // REFERRAL FEES (Amazon's cut)
    if(isBooks) {
        referralFee = price * 0.15; // 15% for books
    } else if(isMedia) {
        referralFee = price * 0.15; // 15% for media
    } else if(isGames) {
        referralFee = price * 0.15; // 15% for toys & games
    } else {
        referralFee = price * 0.15; // Default 15%
    }
    
    // FULFILLMENT FEES (FBA shipping/handling)
    if(isBooks) {
        // Books: weight-based
        if(weight <= 0.5) fulfillmentFee = 3.07;
        else if(weight <= 1) fulfillmentFee = 3.37;
        else if(weight <= 2) fulfillmentFee = 4.16;
        else if(weight <= 3) fulfillmentFee = 5.32;
        else fulfillmentFee = 5.32 + ((weight - 3) * 0.38);
    } else if(isMedia) {
        // Media: standard + weight
        if(weight <= 0.5) fulfillmentFee = 2.92;
        else if(weight <= 1) fulfillmentFee = 3.16;
        else if(weight <= 2) fulfillmentFee = 3.74;
        else fulfillmentFee = 3.74 + ((weight - 2) * 0.38);
    } else {
        // Other: standard small/large item
        if(weight <= 1) fulfillmentFee = 3.22;
        else if(weight <= 2) fulfillmentFee = 4.40;
        else fulfillmentFee = 4.40 + ((weight - 2) * 0.38);
    }
    
    return closingFee + referralFee + fulfillmentFee;
}

/* ================= ANALYSIS (UPGRADED TO BUY/CONSIDER/REJECT) ================= */
function analyze(data) {
    let market = 0;
    const newBuyBox = data.buyBoxPrice || data.amzPrice || data.newPrice || 999999;
    
    // --- BUY BOX AWARE MARKET PRICE SELECTION ---
    let primaryPrice = data.avgBb || data.buyBoxPrice || 0; // Start with the most reliable historical/current BB
    
    if(CONFIG.condition === 'NEW') {
        // For NEW: Stick closely to current or average new/BB price
        primaryPrice = data.buyBoxPrice || data.newPrice || data.avgNew || 0;
    } else {
        // For USED: Use FBA or Used price, incorporating average BB.
        // Use average BB if it's substantial, otherwise fall back to FBA/used.
        
        // If BB is suppressed (primaryPrice=0), use FBA price or lowest used price + floor.
        if (primaryPrice < data.fbaPrice) primaryPrice = data.fbaPrice; 
        if (primaryPrice < data.usedPrice + 4.00) primaryPrice = data.usedPrice + 4.00;
    }
    
    // Set market price, ensuring it meets a $10 minimum before considering profit floor
    market = Math.max(10.00, primaryPrice); 
    
    // Ceiling Check (used price shouldn't beat new)
    if(CONFIG.condition === 'USED' && market > newBuyBox) market = newBuyBox * 0.95;
    
    market = Math.max(0, market); // Prevent negative market price

    // CATEGORY-AWARE FEE CALCULATION
    const fees = calculateFees(market, data.weight, data.category);
    const profit = market - fees - CONFIG.buyCost;
    
    let verdict = 'CONSIDER';
    let score = 50;
    let isGem = false;
    
    // Get category-specific rank thresholds
    const thresholds = getRankThresholds(data.category);
    
    const isSleeper = (data.drops30 === 0 && market > 35);
    const isFbaVoid = (data.totalOffers === 0 && data.avgRank < thresholds.decent && profit > 10);
    const isDip = (data.usedPrice > 0 && data.avgUsed > 0 && data.usedPrice < (data.avgUsed * 0.4) && profit > 5);
    const isTextbook = (data.newPrice > 80 && data.usedPrice < 20 && data.category && data.category.toLowerCase().includes('book'));
    const isRare = (data.avgRank !== -1 && data.avgRank < thresholds.poor && data.totalOffers < 3 && market > 20);
    const isSprinter = (data.drops30 > 3 && data.drops30 > (data.drops90/3 * 1.5)); 
    const isPhantom = (data.totalOffers > 50 && market > 15);
    const isFbaPrem = (data.fbaPrice > 0 && data.usedPrice > 0 && data.fbaPrice > (data.usedPrice * 1.4) && Math.abs(data.fbaPrice - data.buyBoxPrice) < 2); 

    const allTags = [];

    if(isSleeper) { allTags.push({text: "üíé Patience for Big Payout", type: "gem"}); }
    if(isFbaVoid) { allTags.push({text: "üíé Zero FBA Offers", type: "gem"}); }
    if(isDip)     { allTags.push({text: "üíé Buy The Dip", type: "gem"}); }
    if(isTextbook){ allTags.push({text: "üíé Sell Cheaper Used Textbook", type: "gem"}); }
    if(isRare)    { allTags.push({text: "üíé Low Comp Rewards", type: "gem"}); }
    if(isSprinter){ allTags.push({text: "üíé Picking Up Pace", type: "gem"}); }
    if(isPhantom) { allTags.push({text: "üíé Crowded But Fine", type: "gem"}); }
    if(isFbaPrem) { allTags.push({text: "üíé FBA Premium", type: "gem"}); }

    // CRITICAL: Profit floor check ALWAYS comes first - no exceptions!
    if(profit < CONFIG.profitFloor) {
        verdict = 'REJECT';
        score = Math.round(Math.max(0, 40 - (CONFIG.profitFloor - profit)));
        isGem = false; // Cannot be a gem with low profit
    } else if(isSleeper || isFbaVoid || isDip || isTextbook || isRare || isSprinter || isPhantom || isFbaPrem) {
        // Calculate what the score would be WITHOUT gem bonus
        let baseScore = 50;
        if (data.drops30 > 0) {
            baseScore = 80 + Math.min(19, data.drops30);
        } else if (data.drops180 > 0 && market > 20) {
            baseScore = 55;
        } else if (data.drops180 > 0) {
            baseScore = 30;
        } else {
            baseScore = 20;
        }
        
        // Only show gem diamond if base score >= 75
        if (baseScore >= 75) {
            isGem = true;
            verdict = 'BUY';
            score = baseScore; 
        } else {
            // Has gem signal but weak underlying metrics - no diamond
            isGem = false;
            verdict = (baseScore >= 50) ? 'CONSIDER' : 'REJECT';
            score = baseScore;
        }
    } else if (data.drops30 > 0) {
        verdict = 'BUY';
        score = 80 + Math.min(19, data.drops30);
    } else {
        // RESURRECTION LOGIC - No 30d sales but has 180d history
        if(data.drops180 > 0) {
            allTags.push({text: "Has 180d Sales", type: "good"}); 
            
            // Score based on PROFIT, not just price
            // Good profit (>$8) OR decent price (>$15) = CONSIDER
            if(profit >= 8 || market >= 15) {
                score = 55;
                allTags.push({text: "Recent Lull", type: "warn"});
            } else {
                score = 30;
                allTags.push({text: "Slow & Cheap", type: "bad"});
            }
            verdict = (score >= 50) ? 'CONSIDER' : 'REJECT';
        } else {
            verdict = 'REJECT';
            score = 20; 
        }
    }
    
    // --- BB AWARE TAGS ---
    const isBBVolatile = (data.avgBb > 0) && (Math.abs(data.buyBoxPrice - data.avgBb) > 1);
    
    if (data.buyBoxPrice === 0) {
        allTags.push({text: "BB Suppressed/Unavailable", type: "bad"});
    } else if (isBBVolatile && data.buyBoxPrice < data.avgBb) {
        allTags.push({text: "BB Dip Detected - Price is low", type: "warn"});
    } else if (data.buyBoxPrice > 0 && data.buyBoxPrice === data.amzPrice) {
        allTags.push({text: "BB Held by Amazon", type: "bad"});
    }


    if(data.drops30 > 5) allTags.push({text: "Good Velocity", type: "good"});
    if(data.avgRank !== -1 && data.avgRank < 500000) allTags.push({text: "Solid Rank", type: "good"});
    if(data.avgRank > 2000000) allTags.push({text: "High Rank", type: "bad"});

    if(profit >= CONFIG.profitFloor && !isGem) allTags.push({text: "Profitable", type: "good"});
    
    if(profit < 0) allTags.push({text: "Negative Profit", type: "bad"});
    else if(profit < CONFIG.profitFloor) allTags.push({text: "Thin Margins", type: "warn"});
    
    if(data.drops30 === 0 && !isSleeper && data.drops180 === 0) allTags.push({text: "0 Sales (180d)", type: "bad"});
    if(market < 10) allTags.push({text: "Low Value Item", type: "warn"});
    
    const posTags = allTags.filter(t => t.type === 'good' || t.type === 'gem');
    const negTags = allTags.filter(t => t.type === 'bad' || t.type === 'warn');
    
    if(posTags.length === 0) posTags.push({text: "None", type: "warn"});
    if(negTags.length === 0) negTags.push({text: "None", type: "good"});

    return { verdict, profit, score: Math.round(score), market, posTags, negTags, isGem };
}

/* ================= RENDER (SAFE MODE) ================= */
function render(res, data) {
    // FAIL-SAFE HELPER
    const setText = (id, val) => {
        const el = document.getElementById(id);
        if(el) el.innerText = val;
    };

    const card = document.getElementById('resultCard');
    const banner = document.getElementById('banner');
    const decisionEl = document.getElementById('decision');
    
    // Update banner and verdict
    banner.className = `banner ${res.isGem ? 'gem' : res.verdict.toLowerCase()}`;
    setText('confidence', res.score);
    setText('decision', res.verdict);
    if(decisionEl) {
        decisionEl.className = `decision-label ${res.verdict.toLowerCase()}`;
    }
    
    // Show/hide gem icon
    document.getElementById('gemIcon').classList.toggle('visible', res.isGem);
    
    // Show/hide Keepa restricted badge
    const restrictedBadge = document.getElementById('keepaRestricted');
    if(restrictedBadge) {
        restrictedBadge.classList.toggle('hidden', !data.restricted);
    }
    
    // Update score ring
    const offset = 283 - (283 * res.score / 100);
    const ring = document.getElementById('scoreRing');
    if(ring) {
        ring.style.strokeDashoffset = offset;
        if(res.isGem) ring.style.color = 'var(--diamond)';
        else if(res.verdict === 'BUY') ring.style.color = 'var(--green)';
        else if(res.verdict === 'CONSIDER') ring.style.color = 'var(--yellow)';
        else ring.style.color = 'var(--red)';
    }

    // Update book title
    setText('itemTitle', data.title);
    
    // Update category badge
    const categoryBadge = document.getElementById('categoryBadge');
    if(categoryBadge) {
        const cat = data.category || 'Unknown';
        const icon = getCategoryIcon(cat);
        categoryBadge.textContent = `${icon} ${cat}`;
    }
    
    // Update visual meter pricing (NO + SIGNS!)
    const maxPrice = Math.max(res.market, 100);
    const pricePercent = Math.min(100, (res.market / maxPrice) * 100);
    const profitPercent = Math.min(100, Math.max(0, (res.profit / (res.market || 1)) * 100));

    setText('recommendedPrice', '$' + res.market.toFixed(2));
    const priceFill = document.getElementById('priceFill');
    if(priceFill) priceFill.style.width = pricePercent + '%';

    const profitValue = document.getElementById('profitValue');
    if(profitValue) {
        profitValue.textContent = '$' + res.profit.toFixed(2);
        profitValue.style.color = res.profit >= 0 ? 'var(--green)' : 'var(--red)';
    }
    const profitFill = document.getElementById('profitFill');
    if(profitFill) profitFill.style.width = profitPercent + '%';

    // Update slider displays
    updateSliderDisplays();

    // --- Price Details Panel Update ---
    const isUsedCondition = CONFIG.condition === 'USED';
    const bbPrice = data.buyBoxPrice;
    let bbOwner = "NONE";
    let bbColorClass = "none";
    
    if (data.amzPrice > 0 && data.amzPrice === bbPrice) {
        bbOwner = "AMZ";
        bbColorClass = "amz";
    } else if (bbPrice > 0) {
        // Find the current winner based on proximity to FBA price
        if (data.fbaPrice > 0 && Math.abs(data.fbaPrice - bbPrice) < 0.05) {
             bbOwner = "FBA";
             bbColorClass = "fba";
        } else {
            bbOwner = "FBM";
            bbColorClass = "fbm";
        }
    }

    const bbWinnerValEl = document.getElementById('bbWinnerVal');
    const bbPriceValEl = document.getElementById('bbPriceVal');
    const bbCondEl = document.getElementById('bbCond');
    const bbStatusEl = document.getElementById('bbStatusText');
    
    if (bbCondEl) bbCondEl.innerText = isUsedCondition ? 'USED' : 'NEW';
    
    if (bbPriceValEl) {
      bbPriceValEl.innerText = bbPrice > 0 ? `$${bbPrice.toFixed(2)}` : 'Suppressed';
      bbPriceValEl.className = 'price-metric-value ' + bbColorClass;
    }
    
    if (bbWinnerValEl) {
        bbWinnerValEl.innerText = bbOwner;
        bbWinnerValEl.className = 'price-metric-value ' + bbColorClass;
    }

    // 2. Populate BB Summary Box
    if (bbPrice > 0) {
        bbStatusEl.innerHTML = `
            The Buy Box is currently held by <span class="price-metric-value ${bbColorClass}" style="font-weight:800;">${bbOwner}</span> at 
            <span style="font-weight:800; color:var(--text);">$${bbPrice.toFixed(2)} (${isUsedCondition ? 'Used' : 'New'})</span>. 
            <br>Your recommendation of <span style="font-weight:800; color:var(--blue);">$${res.market.toFixed(2)}</span> 
            is based on the average profitable price range.
        `;
    } else {
        bbStatusEl.innerHTML = `<span style="color:var(--red); font-weight:800;">Buy Box is suppressed or unavailable.</span> Pricing is based on historical averages and lowest active FBA/Used offers.`;
    }
    
    // --- End Price Details Panel Update ---


    // Build "Why This Score?" reasoning section
    const reasoningContent = document.getElementById('reasoningContent');
    if(reasoningContent) {
        const signals = [];
        
        // Signal descriptions mapping
        const getSignalInfo = (tagText, isPositive) => {
            const tag = tagText.toLowerCase();
            
            // Positive signals
            if(tag.includes('velocity')) return {
                icon: 'üöÄ',
                desc: `${data.drops30} sales in 30 days shows strong demand. Items moving this fast typically sell within weeks.`
            };
            if(tag.includes('patience for big payout')) return {
                icon: 'üíé',
                desc: `No recent sales but worth $${res.market.toFixed(2)}. Patient sellers can capitalize when demand returns.`
            };
            if(tag.includes('zero fba')) return {
                icon: 'üíé',
                desc: `No FBA competition despite ${data.avgRank < 1000000 ? 'good' : 'decent'} rank. You could dominate Buy Box.`
            };
            if(tag.includes('buy the dip')) return {
                icon: 'üíé',
                desc: `Current price ($${data.usedPrice.toFixed(2)}) is ${Math.round((1 - data.usedPrice/data.avgUsed) * 100)}% below 90-day average. Undervalued opportunity.`
            };
            if(tag.includes('sell cheaper used textbook')) return {
                icon: 'üíé',
                desc: `Expensive new ($${data.newPrice.toFixed(2)}) vs cheap used ($${data.usedPrice.toFixed(2)}). Classic textbook arbitrage play.`
            };
            if(tag.includes('low comp')) return {
                icon: 'üíé',
                desc: `Only ${data.totalOffers} total sellers with decent rank. Less competition = easier sales.`
            };
            if(tag.includes('picking up pace')) return {
                icon: 'üíé',
                desc: `Recent velocity accelerating. ${data.drops30} sales in 30d vs ${Math.round(data.drops90/3)} expected shows momentum.`
            };
            if(tag.includes('crowded but fine')) return {
                icon: 'üíé',
                desc: `${data.totalOffers} sellers seems high, but worth $${res.market.toFixed(2)} with profit above floor. Volume market.`
            };
            if(tag.includes('fba premium')) return {
                icon: 'üíé',
                desc: `FBA price ($${data.fbaPrice.toFixed(2)}) is ${Math.round((data.fbaPrice/data.usedPrice - 1) * 100)}% above MF. Prime customers pay more.`
            };
            if(tag.includes('solid rank')) return {
                icon: 'üìä',
                desc: `Avg rank ${data.avgRank < 100000 ? 'under 100k' : 'under 500k'} indicates consistent demand in this category.`
            };
            if(tag.includes('180d sales')) return {
                icon: 'üìÖ',
                desc: `${data.drops180} sales over 180 days. Slower mover but still active. Expect 2-6 month sell-through.`
            };
            if(tag.includes('recent lull')) return {
                icon: '‚ö†Ô∏è',
                desc: `Historical sales (${data.drops180} in 180d) but none recently. Market cooling or seasonal dip.`
            };
            if(tag.includes('profitable')) return {
                icon: 'üí∞',
                desc: `Net profit of $${res.profit.toFixed(2)} after fees ($${(res.market * 0.15 + (data.weight > 1 ? 5.30 : 4.30)).toFixed(2)}) and your cost ($${CONFIG.buyCost.toFixed(2)}).`
            };
            
            // Negative signals
            if(tag.includes('negative profit')) return {
                icon: '‚ùå',
                desc: `You'd lose $${Math.abs(res.profit).toFixed(2)} per unit after Amazon fees and your cost. Not viable.`
            };
            if(tag.includes('thin margins')) return {
                icon: '‚ö†Ô∏è',
                desc: `Profit ($${res.profit.toFixed(2)}) below your floor ($${CONFIG.profitFloor.toFixed(2)}). Risk not worth reward.`
            };
            if(tag.includes('0 sales')) return {
                icon: 'üìâ',
                desc: `Zero sales in 180 days. Dead inventory risk is very high. Could sit for months or years.`
            };
            if(tag.includes('high rank')) return {
                icon: 'üìà',
                desc: `Rank over 2M indicates very slow sales. Expect 6+ months to sell, or it may never sell.`
            };
            if(tag.includes('low value')) return {
                icon: 'üíµ',
                desc: `Selling for under $10 means tiny profits after fees. Not worth storage space or shipping hassle.`
            };
            if(tag.includes('slow & cheap')) return {
                icon: '‚ö†Ô∏è',
                desc: `Under $20 AND slow sales (180d only). Low profit potential with high risk of long storage.`
            };
            if(tag.includes('bb suppressed')) return {
                icon: 'üõë',
                desc: `The Buy Box is suppressed. Listing price is critical. Use the Recommended Price, which accounts for past BB averages.`
            };
            if(tag.includes('bb held by amazon')) return {
                icon: 'üëë',
                desc: `Amazon currently holds the Buy Box. They often price match the lowest FBA price, limiting your short-term profit unless they run out of stock.`
            };
            
            // Default
            return {
                icon: isPositive ? '‚ú®' : '‚ö†Ô∏è',
                desc: ''
            };
        };
        
        // Map positive tags
        res.posTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, true);
            signals.push({
                icon: info.icon,
                title: tag.text.replace('üíé ', ''),
                text: info.desc,
                type: 'positive'
            });
        });
        
        // Map negative tags
        res.negTags.forEach(tag => {
            if(tag.text === 'None') return;
            
            const info = getSignalInfo(tag.text, false);
            signals.push({
                icon: info.icon,
                title: tag.text,
                text: info.desc,
                type: 'negative'
            });
        });
        
        // Render signals
        if(signals.length === 0) {
            reasoningContent.innerHTML = '<div style="text-align: center; color: var(--muted); font-size: 11px; padding: 8px;">No specific signals</div>';
        } else {
            reasoningContent.innerHTML = signals.map(sig => `
                <div class="signal-item">
                    <span class="signal-icon">${sig.icon}</span>
                    <div class="signal-text">
                        <strong>${sig.title}</strong>
                        ${sig.text ? `<p>${sig.text}</p>` : ''}
                    </div>
                </div>
            `).join('');
        }
    }
    
    card.classList.remove('hidden');
    
}

function togglePriceDetails() {
    const body = document.getElementById('priceDetailsBody');
    const chevron = document.getElementById('priceDetailsChevron');
    
    if (body.classList.contains('active')) {
        body.classList.remove('active');
        chevron.classList.replace('fa-chevron-up', 'fa-chevron-down');
    } else {
        body.classList.add('active');
        chevron.classList.replace('fa-chevron-down', 'fa-chevron-up');
    }
}


function updateSliderDisplays() {
    const cost = parseFloat(document.getElementById('sliderCost').value);
    const floor = parseFloat(document.getElementById('sliderFloor').value);
    
    const costValueEl = document.getElementById('costValue');
    const floorValueEl = document.getElementById('floorValue');
    
    if(costValueEl) costValueEl.textContent = '$' + cost.toFixed(2);
    if(floorValueEl) floorValueEl.textContent = '$' + floor.toFixed(2);
}

function renderTags(id, tags) {
    const el = document.getElementById(id);
    if(!el) return;
    el.innerHTML = '';
    tags.forEach(t => {
        el.innerHTML += `<span class="tag ${t.type}">${t.text}</span>`;
    });
}

function toggleKeepa() {
  const container = document.getElementById('keepaGraphContainer');
  const btn = document.getElementById('linkKeepa');
  if(container.classList.contains('hidden')) {
    if(lastData && lastData.asin) {
      container.innerHTML = `
        <img src="https://graph.keepa.com/pricehistory.png?asin=${lastData.asin}&domain=1&t=${Date.now()}&width=400" alt="Keepa Graph" />
      `;
      container.classList.remove('hidden');
      btn.innerText = "Close Graph ‚úñ";
    }
  } else {
    container.classList.add('hidden');
    btn.innerText = "View Graph üìâ";
  }
}

function openAmazonOffers() {
    if(lastData && lastData.asin) {
        window.open(`https://www.amazon.com/gp/offer-listing/${lastData.asin}/`, '_blank');
    } else {
        alert("No ASIN available to open offers.");
    }
}


/* ================= CAMERA (ROBUST) ================= */
let html5QrCode;
let scanMode = 'barcode'; // 'barcode' or 'isbn'
let ocrInterval = null;

function openCamera() {
    startCamera();
}

function switchScanMode(mode) {
    scanMode = mode;
    
    // Update button states
    document.getElementById('mode-barcode').classList.toggle('active', mode === 'barcode');
    document.getElementById('mode-isbn').classList.toggle('active', mode === 'isbn');
    
    // Update frame visibility
    document.getElementById('scan-frame-barcode').classList.toggle('hidden', mode === 'isbn');
    document.getElementById('scan-frame-isbn').classList.toggle('hidden', mode === 'barcode');
    
    // Restart camera with new mode
    if(html5QrCode) {
        stopCamera();
        setTimeout(() => startCamera(), 500);
    }
}

function updateCameraStatus(state, text) {
    const status = document.getElementById('camera-status');
    if(!status) return;
    
    status.className = 'camera-status ' + state;
    status.textContent = text;
}

function startCamera() {
    const overlay = document.getElementById('camera-overlay');
    overlay.classList.remove('hidden');
    
    if(scanMode === 'barcode') {
        startBarcodeScanner();
    } else {
        startISBNScanner();
    }
}

function startBarcodeScanner() {
    updateCameraStatus('', 'Ready to scan barcode...');
    
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" }, 
        { fps: 10, qrbox: { width: 250, height: 150 } },
        (decodedText) => {
            // Success!
            updateCameraStatus('success', '‚úì Barcode Detected!');
            
            if(navigator.vibrate) navigator.vibrate(200);
            
            setTimeout(() => {
                stopCamera();
                document.getElementById('scanInput').value = decodedText;
                addToQueue(decodedText);
            }, 500);
        },
        (errorMessage) => {
            // Scanning...
            if(!errorMessage.includes('No MultiFormat Readers')) {
                updateCameraStatus('detecting', 'üîç Scanning...');
            }
        }
    ).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startISBNScanner() {
    updateCameraStatus('', 'Position ISBN in frame...');
    
    // Start video stream
    html5QrCode = new Html5Qrcode("reader");
    html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: { width: 280, height: 80 } },
        () => {}, // Not using barcode callback
        () => {}  // Not using error callback
    ).then(() => {
        // Start OCR processing
        startOCRProcessing();
    }).catch(err => {
        updateCameraStatus('error', '‚ùå Camera Error');
        setTimeout(() => {
            alert("Camera Error: " + err);
            stopCamera();
        }, 1000);
    });
}

function startOCRProcessing() {
    let isProcessing = false;
    let attemptCount = 0;
    
    // Update status with helpful instruction
    updateCameraStatus('detecting', 'üìñ HOLD STEADY - Reading ISBN...');
    
    ocrInterval = setInterval(async () => {
        if(isProcessing) return;
        
        isProcessing = true;
        attemptCount++;
        
        // Show progress
        updateCameraStatus('detecting', `üìñ HOLD STEADY - Attempt ${attemptCount}...`);
        
        try {
            // Capture frame from video
            const video = document.querySelector('#reader video');
            if(!video) {
                isProcessing = false;
                return;
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw video frame
            ctx.drawImage(video, 0, 0);
            
            // FIX #1: IMAGE PREPROCESSING for better OCR
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert to grayscale and increase contrast
            for(let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                // Increase contrast: make darks darker, lights lighter
                const contrast = avg < 128 ? avg * 0.7 : avg * 1.3;
                data[i] = data[i + 1] = data[i + 2] = Math.min(255, Math.max(0, contrast));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Run OCR on preprocessed frame
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                logger: () => {}, // Suppress logs
                tessedit_char_whitelist: '0123456789X' // Only numbers and X for ISBN
            });
            
            // Extract ISBN from text
            const isbn = extractISBN(text);
            
            if(isbn) {
                // Success!
                updateCameraStatus('success', '‚úì ISBN Detected!');
                
                if(navigator.vibrate) navigator.vibrate(200);
                
                clearInterval(ocrInterval);
                
                setTimeout(() => {
                    stopCamera();
                    document.getElementById('scanInput').value = isbn;
                    addToQueue(isbn);
                }, 500);
            } else {
                isProcessing = false;
            }
            
        } catch(err) {
            console.error('OCR error:', err);
            isProcessing = false;
        }
    }, 1000); // FIX #1: Check every 1 second (was 2 seconds)
}

function extractISBN(text) {
    // Remove all spaces and hyphens
    const cleaned = text.replace(/[\s\-]/g, '');
    
    // Look for ISBN-13 (starts with 978 or 979)
    const isbn13Match = cleaned.match(/97[89]\d{10}/);
    if(isbn13Match) return isbn13Match[0];
    
    // Look for ISBN-10 (10 digits or 9 digits + X)
    const isbn10Match = cleaned.match(/\d{9}[0-9X]/i);
    if(isbn10Match) return isbn10Match[0];
    
    return null;
}

function stopCamera() {
    document.getElementById('camera-overlay').classList.add('hidden');
    
    if(ocrInterval) {
        clearInterval(ocrInterval);
        ocrInterval = null;
    }
    
    if(html5QrCode) {
        html5QrCode.stop().then(() => html5QrCode.clear()).catch(() => {});
    }
}

/* ================= GEMINI (AUTO-LOAD FOR CONSIDER) ================= */
async function loadGeminiOpinion() {
    if(!lastData || !currentScan) return;
    if(!CONFIG.geminiKey) return; // Skip if no API key
    
    const geminiOpinion = document.getElementById('geminiOpinion');
    if(!geminiOpinion) return;
    
    const result = analyze(lastData);
    const baseScore = result.score;
    
    // Show loading state
    geminiOpinion.className = 'gemini-opinion loading';
    geminiOpinion.innerHTML = `
        <div class="gemini-header">
            <div class="gemini-title">
                <span>ü§ñ</span>
                <span>GEMINI SECOND OPINION</span>
            </div>
        </div>
        <div style="text-align:center; padding:30px; color:var(--muted);">
            <i class="fas fa-circle-notch fa-spin" style="font-size:24px; margin-bottom:10px;"></i>
            <div>Analyzing item...</div>
        </div>
    `;
    geminiOpinion.classList.remove('hidden');
    
    // Build prompt for Gemini
    const itemType = lastData.category || 'item';
    const prompt = `Analyze this ${itemType} for Amazon FBA resale:
Title: ${lastData.title}
Category: ${lastData.category || 'Unknown'}
Your Score: ${baseScore} (CONSIDER)
Profit: $${result.profit.toFixed(2)}
Sales (30d): ${lastData.drops30}
Sales (180d): ${lastData.drops180}
Competition: ${lastData.totalOffers} total offers

Based on this data, do you recommend UPGRADE to BUY or DOWNGRADE to REJECT?
What score (0-100) would you assign?
Explain in 2-3 sentences.

Respond EXACTLY in this format:
VERDICT: [BUY or REJECT]
SCORE: [0-100]
REASONING: [Your explanation]`;

    const model = 'gemini-2.0-flash-exp';
    const cleanKey = CONFIG.geminiKey.trim();

    try {
        let url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${cleanKey}`;
        
        if(CONFIG.useProxy) {
            url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });
        
        const json = await response.json();
        
        if(json.error) throw new Error(json.error.message);

        if(json.candidates && json.candidates[0] && json.candidates[0].content) {
            const text = json.candidates[0].content.parts[0].text;
            
            // Parse response
            const verdictMatch = text.match(/VERDICT:\s*(BUY|REJECT)/i);
            const scoreMatch = text.match(/SCORE:\s*(\d+)/);
            const reasoningMatch = text.match(/REASONING:\s*(.+)/s);

            const geminiVerdict = verdictMatch ? verdictMatch[1].toUpperCase() : null;
            const geminiScore = scoreMatch ? parseInt(scoreMatch[1]) : null;
            const geminiReasoning = reasoningMatch ? reasoningMatch[1].trim() : text;

            if (!geminiVerdict || !geminiScore) {
                throw new Error('Could not parse Gemini response');
            }

            // Save to current scan history
            if(currentScan) {
                currentScan.geminiVerdict = geminiVerdict;
                currentScan.geminiScore = geminiScore;
                
                // Update in scanHistory (first item)
                if(scanHistory[0]) {
                    scanHistory[0].geminiVerdict = geminiVerdict;
                    scanHistory[0].geminiScore = geminiScore;
                    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
                }
            }

            // Determine if upgrade or downgrade
            const isUpgrade = geminiVerdict === 'BUY';
            const opinionClass = isUpgrade ? 'upgrade' : 'downgrade';

            // Build the UI
            geminiOpinion.className = 'gemini-opinion ' + opinionClass;
            geminiOpinion.innerHTML = `
                <div class="gemini-header">
                    <div class="gemini-title ${opinionClass}">
                        <span>ü§ñ</span>
                        <span>GEMINI SECOND OPINION</span>
                    </div>
                    <div class="collapse-icon" onclick="toggleGeminiCollapse()">‚àí</div>
                </div>

                <div class="gemini-content" id="geminiContent">
                    <div class="score-comparison">
                        <div class="score-box">
                            <div class="score-box-label">Your Score</div>
                            <div class="score-box-value amber">${baseScore}</div>
                        </div>

                        <div class="score-arrow ${isUpgrade ? 'up' : 'down'}">‚Üí</div>

                        <div class="score-box">
                            <div class="score-box-label">Gemini Score</div>
                            <div class="score-box-value ${isUpgrade ? 'green' : 'red'}">${geminiScore}</div>
                        </div>
                    </div>

                    <div class="gemini-verdict ${opinionClass}">
                        ${isUpgrade ? '‚úì UPGRADE ‚Üí BUY' : '‚úó DOWNGRADE ‚Üí REJECT'}
                    </div>

                    <div class="gemini-text">${geminiReasoning}</div>
                </div>
            `;

            geminiOpinion.classList.remove('hidden');
        }
    } catch(e) { 
        console.error('Gemini error:', e);
        // Show error state but don't interrupt user
        geminiOpinion.innerHTML = `
            <div class="gemini-header">
                <div class="gemini-title">
                    <span>ü§ñ</span>
                    <span>GEMINI UNAVAILABLE</span>
                </div>
            </div>
            <div style="text-align:center; padding:20px; color:var(--muted); font-size:12px;">
                ${e.message.includes('API') ? 'Check your API key in Settings' : 'Connection error'}
            </div>
        `;
    }
}

function toggleGeminiCollapse() {
    const content = document.getElementById('geminiContent');
    const icon = document.querySelector('.collapse-icon');
    if(content && icon) {
        content.classList.toggle('hidden');
        icon.textContent = content.classList.contains('hidden') ? '+' : '‚àí';
    }
}

/* ================= SETTINGS ================= */
function showSettings() {
    document.getElementById('settingsPage').classList.remove('hidden');
    document.getElementById('keepaKey').value = CONFIG.keepaKey;
    document.getElementById('geminiKey').value = CONFIG.geminiKey;
    document.getElementById('defCost').value = CONFIG.buyCost;
    document.getElementById('defFloor').value = CONFIG.profitFloor;
}

function closeSettings() {
    document.getElementById('settingsPage').classList.add('hidden');
}

function saveSettings() {
    CONFIG.keepaKey = document.getElementById('keepaKey').value.trim();
    CONFIG.geminiKey = document.getElementById('geminiKey').value.trim();
    CONFIG.buyCost = parseFloat(document.getElementById('defCost').value);
    CONFIG.profitFloor = parseFloat(document.getElementById('defFloor').value);
    CONFIG.useProxy = document.getElementById('toggleProxy').classList.contains('active');
    CONFIG.fastScan = document.getElementById('toggleFastScan').classList.contains('active');
    
    localStorage.setItem('keepaKey', CONFIG.keepaKey);
    localStorage.setItem('geminiKey', CONFIG.geminiKey);
    localStorage.setItem('buyCost', CONFIG.buyCost);
    localStorage.setItem('profitFloor', CONFIG.profitFloor);
    localStorage.setItem('useProxy', CONFIG.useProxy);
    localStorage.setItem('fastScan', CONFIG.fastScan);
    
    updateTokenUI();
    updateConditionUI();
    closeSettings();
}

/* ================= HISTORY MANAGEMENT (VIEW & DELETE) ================= */

let focusedDeleteTimestamp = null;

function toggleDeleteConfirmation(timestamp) {
    const wrapper = document.querySelector(`.history-item-wrapper[data-timestamp="${timestamp}"]`);
    const overlay = wrapper ? wrapper.querySelector('.delete-confirm-overlay') : null;
    
    // If we click the same item again (to cancel), or cancel
    if(focusedDeleteTimestamp === timestamp) {
        if(overlay) overlay.classList.remove('active');
        focusedDeleteTimestamp = null;
        return;
    }
    
    // First, close any currently open confirmation
    if (focusedDeleteTimestamp) {
        toggleDeleteConfirmation(focusedDeleteTimestamp);
    }
    
    // Then, open the new confirmation
    if (overlay) {
        overlay.classList.add('active');
        focusedDeleteTimestamp = timestamp;
    }
}

function deleteScan(timestamp) {
    // We already have a confirmation built into the UI, so we only need the filter/re-render logic
    
    const initialLength = scanHistory.length;
    
    scanHistory = scanHistory.filter(item => item.timestamp !== timestamp);
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    if (scanHistory.length < initialLength) {
        // Successful deletion
        if (navigator.vibrate) navigator.vibrate(50);
        focusedDeleteTimestamp = null;
        showHistory(); // Re-render the history page
    } else {
        alert("Error deleting item.");
    }
}


function showHistory() {
    const page = document.getElementById('historyPage');
    const list = document.getElementById('historyList');
    
    if(!list) return;
    
    focusedDeleteTimestamp = null; // Reset focus when opening history
    
    // Render all history items
    if(scanHistory.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--muted);">No scan history</div>';
    } else {
        list.innerHTML = scanHistory.map(item => {
            let color = 'var(--red)';
            if(item.verdict === 'BUY') color = 'var(--green)';
            if(item.verdict === 'CONSIDER') color = 'var(--yellow)';
            
            // Decision badge
            let decisionBadge = '';
            if(item.decision === 'BOUGHT') {
                decisionBadge = `<span style="background:rgba(16,185,129,0.2); color:var(--green); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úì BOUGHT</span>`;
            } else if(item.decision === 'PASSED') {
                decisionBadge = `<span style="background:rgba(239,68,68,0.2); color:var(--red); padding:2px 8px; border-radius:99px; font-size:10px; font-weight:700;">‚úó PASSED</span>`;
            }
            
            // The new history item structure with click handler
            return `
                <div class="history-item-wrapper" data-timestamp="${item.timestamp}">
                    <div class="history-item-content" onclick="toggleDeleteConfirmation(${item.timestamp})">
                        <div style="display:flex; justify-content:space-between; align-items:center; font-weight:700;">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="color:${color}">${item.verdict}</span>
                                ${decisionBadge}
                            </div>
                            <span style="color:${item.profit >= 0 ? 'var(--green)' : 'var(--red)'}">$${item.profit.toFixed(2)}</span>
                        </div>
                        <div style="font-size:12px; color:var(--muted); margin-top:4px;">${item.title.substring(0,60)}...</div>
                    </div>
                    
                    <div class="delete-confirm-overlay">
                        <div class="delete-message">Delete this scan?</div>
                        <div class="confirm-buttons">
                            <button class="btn-delete-confirm cancel" onclick="toggleDeleteConfirmation(${item.timestamp}); event.stopPropagation();">Cancel</button>
                            <button class="btn-delete-confirm delete" onclick="deleteScan(${item.timestamp}); event.stopPropagation();">DELETE</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    page.classList.remove('hidden');
}

function closeHistory() {
    document.getElementById('historyPage').classList.add('hidden');
}

function addToHistory(res, data) {
    const item = { 
        verdict: res.verdict, 
        profit: res.profit, 
        score: res.score,
        market: res.market, // Add market price for CSV export
        title: data.title,
        asin: data.asin,
        isbn: data.isbn || '', // Add ISBN for CSV export
        category: data.category || 'Unknown',
        geminiVerdict: null, // Will be filled when Gemini responds
        geminiScore: null,
        decision: null, // 'BOUGHT', 'PASSED', or null
        timestamp: Date.now()
    };
    
    scanHistory.unshift(item);
    
    // Keep only last 100 scans
    if(scanHistory.length > 100) {
        scanHistory = scanHistory.slice(0, 100);
    }
    
    // Save to localStorage
    localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    
    // Set as current scan for decision tracking
    currentScan = item;
}

/* ================= DECISION TRACKING ================= */
function recordDecision(decision) {
    if(!currentScan) {
        alert('No active scan to record decision for');
        return;
    }
    
    // Update current scan
    currentScan.decision = decision;
    
    // Update in scanHistory (it's the first item)
    if(scanHistory[0]) {
        scanHistory[0].decision = decision;
        localStorage.setItem('scanHistory', JSON.stringify(scanHistory));
    }
    
    // Visual feedback
    const buttons = document.querySelectorAll('.decision-btn');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.closest('.decision-btn').classList.add('selected');
    
    const note = document.getElementById('decisionNote');
    if(note) {
        const emoji = decision === 'BOUGHT' ? '‚úì' : '‚úó';
        const action = decision === 'BOUGHT' ? 'BUYING' : 'PASSING ON';
        note.textContent = `${emoji} Decision saved: ${action} this item`;
        note.className = 'decision-note success';
    }
    
    // Vibrate if available
    if(navigator.vibrate) navigator.vibrate(100);
}

/* ================= CSV EXPORT (UPDATED) ================= */
function exportCSV() {
    // Export ALL history items
    const exportable = scanHistory; 
    
    if(exportable.length === 0) {
        alert('No scans in history to export!');
        return;
    }
    
    // Calculate stats
    const exportableLength = exportable.length;
    const totalProfit = exportable.reduce((sum, item) => sum + item.profit, 0);
    
    // Build CSV matching scout_scans_template.csv format
    // Format: TITLE,SCAN DATE,RATING,ISBN,ASIN,RECOMMENDED PRICE
    const headers = ['TITLE', 'SCAN DATE', 'RATING', 'ISBN', 'ASIN', 'RECOMMENDED PRICE'];
    const rows = exportable.map(item => {
        // Format date as MM/DD/YYYY
        const date = item.timestamp ? new Date(item.timestamp).toLocaleDateString('en-US') : '';
        
        // Title - escape quotes
        const title = (item.title || '').replace(/"/g, '""');
        
        // RATING = score (0-100)
        const rating = item.score || 0;
        
        // ISBN - extract from stored data
        const isbn = item.isbn || '';
        
        // ASIN
        const asin = item.asin || '';
        
        // RECOMMENDED PRICE - market price without $ or formatting
        const price = item.market ? item.market.toFixed(2) : '0.00';
        
        // Ensure values are wrapped in quotes if they contain commas or quotes
        const safeTitle = `"${title}"`;
        const safeIsbn = `"${isbn}"`;
        const safeAsin = `"${asin}"`;

        return [safeTitle, date, rating, safeIsbn, safeAsin, price].join(',');
    });
    
    const csv = [headers.join(','), ...rows].join('\n');
    
    // Download file
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scout-export-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    // Show success toast with decision stats
    const toast = document.getElementById('exportToast');
    if(toast) {
        toast.innerHTML = `üìä ${exportableLength} Items Exported ‚Ä¢ $${totalProfit.toFixed(2)} total profit`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), 4000);
    }
}

/* ================= TOGGLE CONDITION FIX ================= */
function setCondition(c) {
    // 1. Update State
    CONFIG.condition = c;
    
    // 2. Update UI (Force Toggle)
    const btnUsed = document.getElementById('btnCondUsed');
    const btnNew = document.getElementById('btnCondNew');
    
    if(btnUsed && btnNew) {
        if(c === 'USED') {
            btnUsed.classList.add('active');
            btnNew.classList.remove('active');
        } else {
            btnUsed.classList.remove('active');
            btnNew.classList.add('active');
        }
    }
    
    // 3. Re-run Analysis if we have data
    if(lastData) {
        const result = analyze(lastData);
        render(result, lastData);
    }
}

/* ================= TOGGLE PRICE ADJUSTER ================= */
function togglePriceAdjuster() {
    const adjuster = document.getElementById('priceAdjuster');
    const icon = document.getElementById('adjusterIcon');
    
    if(adjuster.classList.contains('collapsed')) {
        adjuster.classList.remove('collapsed');
        icon.innerText = '‚ñº';
    } else {
        adjuster.classList.add('collapsed');
        icon.innerText = '‚ñ∂';
    }
}

function togglePriceDetails() {
    const body = document.getElementById('priceDetailsBody');
    const chevron = document.getElementById('priceDetailsChevron');
    
    if (body.classList.contains('active')) {
        body.classList.remove('active');
        chevron.classList.replace('fa-chevron-up', 'fa-chevron-down');
    } else {
        body.classList.add('active');
        chevron.classList.replace('fa-chevron-down', 'fa-chevron-up');
    }
}
</script>

<script>
// SPLASH SCREEN - Must be at end of body to ensure DOM exists
(function() {
    const splash = document.getElementById('splash-screen');
    if(!splash) return;
    
    // Hide splash after 1.5 seconds
    setTimeout(() => {
        splash.classList.add('splash-hidden');
    }, 1500);
    
    // Emergency failsafe - force hide after 3 seconds
    setTimeout(() => {
        if(!splash.classList.contains('splash-hidden')) {
            splash.style.display = 'none';
        }
    }, 3000);
})();
</script>

</body>
</html>