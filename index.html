<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ScoutPro AI v3.0</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

<style>
:root {
  --bg: #0a0e1a;
  --panel: #141b2d;
  --card: #1a2332;
  --border: rgba(255,255,255,.08);
  --text: #ffffff;
  --muted: #8b92ab;
  --green: #10b981;
  --yellow: #fbbf24;
  --red: #ef4444;
  --blue: #3b82f6;
}

* { 
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app { 
  max-width: 480px;
  margin: 0 auto;
  min-height: 100vh;
  padding-bottom: 140px;
}

/* Header */
header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--bg);
  padding: 12px;
  border-bottom: 1px solid var(--border);
}

.brand {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.brand-title {
  font-size: 18px;
  font-weight: 800;
  letter-spacing: -0.02em;
}

.brand-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 999px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--blue);
  font-weight: 600;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: var(--blue);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.input-row {
  display: grid;
  grid-template-columns: 1fr auto auto;
  gap: 8px;
  width: 100%;
}

input[type="text"] {
  min-width: 0;
  padding: 14px 16px;
  border-radius: 12px;
  background: var(--panel);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 15px;
  outline: none;
  transition: border-color 0.2s;
}

input[type="text"]:focus {
  border-color: var(--blue);
}

input[type="text"]::placeholder {
  color: var(--muted);
}

button {
  padding: 14px 20px;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: transform 0.1s, opacity 0.2s;
}

button:active {
  transform: scale(0.98);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Status Bar */
.status-bar {
  padding: 10px 16px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 12px;
  color: var(--muted);
  background: var(--panel);
  margin: 12px 12px 0;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  pointer-events: none; /* FIX: don't block taps */
}

.status-label {
  color: var(--blue);
}

/* Duplicate Warning */
#dupeWarning {
  padding: 10px 16px;
  margin: 12px;
  background: rgba(251, 191, 36, 0.1);
  border: 1px solid var(--yellow);
  border-radius: 8px;
  color: var(--yellow);
  font-size: 13px;
  display: none;
}

/* Processing State */
.processing {
  margin: 12px;
  padding: 24px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  text-align: center;
  display: none;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto 16px;
  border: 3px solid var(--border);
  border-top-color: var(--blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.processing-text {
  font-size: 14px;
  color: var(--muted);
}

/* Cards */
.card {
  margin: 12px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  overflow: hidden;
}

/* Decision Banner */
.banner {
  padding: 24px 20px;
  text-align: center;
  position: relative;
}

.banner.buy { 
  background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), transparent);
  border-bottom: 2px solid rgba(16, 185, 129, 0.3);
}

.banner.pass { 
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), transparent);
  border-bottom: 2px solid rgba(239, 68, 68, 0.3);
}

.banner.gem {
  background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(16, 185, 129, 0.1));
  border-bottom: 2px solid rgba(251, 191, 36, 0.5);
  box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
}

.gem-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
  border-radius: 999px;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: #000;
  margin-bottom: 8px;
  box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  animation: gem-pulse 2s ease-in-out infinite;
}

.gem-sparkle {
  font-size: 14px;
  animation: sparkle 1.5s ease-in-out infinite;
}

@keyframes gem-pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  }
  50% { 
    transform: scale(1.05);
    box-shadow: 0 6px 20px rgba(251, 191, 36, 0.6);
  }
}

@keyframes sparkle {
  0%, 100% { 
    opacity: 1;
    transform: rotate(0deg);
  }
  50% { 
    opacity: 0.7;
    transform: rotate(180deg);
  }
}

.gem-reasons {
  margin-top: 12px;
  padding: 12px;
  background: rgba(251, 191, 36, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(251, 191, 36, 0.3);
  font-size: 12px;
  color: var(--text);
  text-align: left;
}

.gem-reasons strong {
  color: #fbbf24;
  display: block;
  margin-bottom: 6px;
  font-size: 13px;
}

.decision {
  font-size: 32px;
  font-weight: 800;
  letter-spacing: -0.02em;
  margin-bottom: 8px;
}

.reason {
  font-size: 14px;
  color: var(--muted);
  margin-bottom: 20px;
}

.stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 16px;
}

.stat {
  text-align: center;
}

.stat-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--muted);
  margin-bottom: 4px;
}

.stat-value {
  font-size: 18px;
  font-weight: 700;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
}

.stat-value.negative {
  color: var(--red);
}

.explanation {
  font-size: 13px;
  line-height: 1.6;
  color: var(--muted);
}

/* Sections */
.section {
  padding: 20px;
  border-top: 1px solid var(--border);
}

.section-title {
  font-size: 13px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--muted);
  margin-bottom: 16px;
}

/* Sliders */
.slider-group {
  margin-bottom: 16px;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
}

.slider-value {
  font-weight: 700;
  color: var(--blue);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--card);
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--blue);
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--blue);
  cursor: pointer;
  border: none;
}

/* Buttons */
.btn-toggle {
  width: 100%;
  background: var(--card);
  color: var(--text);
  border: 1px solid var(--border);
  margin-top: 12px;
}

.btn-toggle:hover {
  border-color: var(--blue);
}

/* Settings */
.settings-group {
  margin-bottom: 20px;
}

.settings-label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text);
}

.settings-input {
  width: 100%;
  padding: 12px 14px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 13px;
}

.settings-input:focus {
  outline: none;
  border-color: var(--blue);
}

.settings-hint {
  font-size: 11px;
  color: var(--muted);
  margin-top: 6px;
}

/* History */
.history-item {
  padding: 16px;
  background: var(--card);
  border-radius: 12px;
  margin-bottom: 12px;
  border: 1px solid var(--border);
}

.history-decision {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 8px;
}

.history-decision.ACCEPT {
  background: rgba(16, 185, 129, 0.2);
  color: var(--green);
}

.history-decision.REJECT {
  background: rgba(239, 68, 68, 0.2);
  color: var(--red);
}

.history-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text);
}

.history-meta {
  font-size: 12px;
  color: var(--muted);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  line-height: 1.5;
}

/* Action Buttons */
.actions {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--bg);
  border-top: 1px solid var(--border);
  padding: 16px;
  display: flex;
  gap: 12px;
  max-width: 480px;
  margin: 0 auto;
}

.btn-settings {
  background: var(--card);
  color: var(--text);
  border: 1px solid var(--border);
  flex-shrink: 0;
  width: 50px;
}

.btn-download {
  flex: 1;
  background: var(--green);
  color: var(--bg);
}

.btn-clear {
  background: var(--red);
  color: white;
}

.btn-history {
  background: var(--blue);
  color: white;
}

/* Utility */
.hidden {
  display: none !important;
}

@keyframes flash {
  0% { opacity: 0; transform: scale(0.95); }
  100% { opacity: 1; transform: scale(1); }
}

.flash {
  animation: flash 0.3s ease-out;
}
</style>
</head>
<body>

<div class="app">

<!-- Header -->
<header>
  <div class="brand">
    <div class="brand-title">ScoutPro AI</div>
    <div style="display:flex;gap:6px;align-items:center;">
      <div class="brand-badge" id="keepaBadge" style="display:none;">
        <div class="status-dot" style="background:var(--green);"></div>
        <span>KEEPA</span>
      </div>
      <div class="brand-badge" id="engineBadge">
        <div class="status-dot"></div>
        <span id="engineName">Local Engine</span>
      </div>
    </div>
  </div>
  <div class="input-row">
    <input id="scanInput" type="text" placeholder="ISBN, UPC, ASIN, or Title..." autocomplete="off" />
    <button id="historyBtn" class="btn-history">History</button>
  </div>
</header>

<div class="status-bar">
  <span id="statusText">Ready to scan</span>
  <span id="itemCount"><span class="status-label">Queue:</span> 0</span>
</div>

<div id="dupeWarning">‚ö†Ô∏è Already scanned ‚Äî ignored</div>

<!-- Processing State -->
<div class="processing" id="processing">
  <div class="spinner"></div>
  <div class="processing-text">Analyzing with AI...</div>
</div>

<!-- MAIN PAGE -->
<div id="mainPage">
  <div class="card hidden" id="resultCard">
    <div id="banner" class="banner buy">
      <div id="gemBadge" class="gem-badge" style="display:none;">
        <span class="gem-sparkle">‚ú®</span>
        <span>HIDDEN GEM</span>
        <span class="gem-sparkle">‚ú®</span>
      </div>
      <div class="decision" id="decision">ACCEPT</div>
      <div class="reason" id="reason"></div>
      
      <div class="stats">
        <div class="stat">
          <div class="stat-label">Target Price</div>
          <div class="stat-value" id="targetPrice">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">Profit</div>
          <div class="stat-value" id="profit">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">ROI</div>
          <div class="stat-value" id="roi">‚Äî</div>
        </div>
        <div class="stat">
          <div class="stat-label">Buy Box</div>
          <div class="stat-value" id="bb">‚Äî</div>
        </div>
      </div>
      
      <div class="explanation" id="explanation"></div>
    </div>

    <!-- Controls -->
    <div class="section">
      <div class="section-title">Scanner Controls</div>
      
      <div class="slider-group">
        <div class="slider-label">
          <span>Buy Cost</span>
          <span class="slider-value">$<span id="buyCostVal">1.00</span></span>
        </div>
        <input type="range" min="0.10" max="10" step="0.10" id="buyCostSlider" value="1.00" />
      </div>

      <div class="slider-group">
        <div class="slider-label">
          <span>Profit Floor</span>
          <span class="slider-value">$<span id="profitFloorVal">5.00</span></span>
        </div>
        <input type="range" min="1" max="20" step="1" id="profitFloorSlider" value="5" />
      </div>
      
      <button id="doubleCheckGeminiBtn" class="btn-toggle" style="background:linear-gradient(135deg,#8b5cf6,#6366f1);display:none;">
        ü§ñ Double Check with Gemini
      </button>
    </div>
  </div>
</div>

<!-- SETTINGS PAGE -->
<div id="settingsPage" class="card">
  <div class="section">
    <div class="section-title">API Configuration</div>
    
    <div class="settings-group">
      <label class="settings-label">Keepa API Key</label>
      <input type="text" id="keepaKey" class="settings-input" placeholder="Enter your Keepa API key" />
      <div class="settings-hint">Get your key at <a href="https://keepa.com/#!api" target="_blank" style="color:var(--blue)">keepa.com/#!api</a></div>
    </div>
    
    <div class="settings-group">
      <label class="settings-label">Gemini API Key</label>
      <input type="text" id="geminiKey" class="settings-input" placeholder="Enter your Gemini API key" />
      <div class="settings-hint">Get your key at <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color:var(--blue)">aistudio.google.com</a></div>
    </div>
    
    <div class="settings-group">
      <label class="settings-label">Decision Engine</label>
      <select id="useGemini" style="width:100%; padding:10px 12px; background:var(--card); border:1px solid var(--border); border-radius:8px; color:var(--text); font-size:13px;">
        <option value="false">Local Engine (Fast, Free)</option>
        <option value="true">Gemini AI (Smarter, $0.0001/scan)</option>
      </select>
      <div class="settings-hint">Local engine works offline and is faster. Gemini provides more nuanced analysis.</div>
    </div>
    
    <button id="saveSettings" style="width:100%; background:var(--green); color:var(--bg); margin-top:16px;">
      Save Settings
    </button>
    
    <button id="backFromSettings" style="width:100%; background:var(--panel); color:var(--text); margin-top:8px; border:1px solid var(--border);">
      Back
    </button>
  </div>
</div>

<!-- HISTORY PAGE -->
<div id="historyPage" class="card">
  <div class="section">
    <div class="section-title">Scan History</div>
    <div id="historyList"></div>
    <button id="backBtn" style="margin-top:16px; background:var(--blue); color:white; width:100%;">Back</button>
  </div>
</div>

<!-- Action Buttons -->
<div class="actions">
  <button id="settingsBtn" class="btn-settings">‚öôÔ∏è</button>
  <button id="downloadBtn" class="btn-download">Download</button>
  <button id="clearBtn" class="btn-clear">Clear</button>
</div>

</div>

<script>
/* ==================== CONFIG ==================== */
let BUY_COST = 1.00;
let PROFIT_FLOOR = 5.00;

const CONFIG = {
  keepaKey: localStorage.getItem('keepaKey') || '',
  geminiKey: localStorage.getItem('geminiKey') || '',
  useGemini: localStorage.getItem('useGemini') === 'true'
};

const seenIdentifiers = new Set();
let scanHistory = [];
let buyList = [];
let lastScanData = null;

const scanInput = document.getElementById("scanInput");

/* ==================== BLUETOOTH SCANNER HANDLER ==================== */
/* ‚úÖ Scanner fix (stable):
   - Uses scanInput.value (what the scanner actually types)
   - Processes after short inactivity OR Enter
   - Clears the field after processing so scans don't concatenate
   - Uses .oninput/.onkeydown (overwrites any other handlers -> avoids multi-listener fights)
*/
let __scan_timer = null;

function __scan_clean(v){
  return String(v || "").replace(/[^0-9xXbB]/g,"").trim();
}

// Override-aware finalize: if the app defines finalizeScan(), we'll call it with a value.
// If finalizeScan takes no args, we'll temporarily set scanInput.value then call it.
function __scan_callFinalize(cleanVal){
  if (!cleanVal) return;

  try { if (navigator.vibrate) navigator.vibrate(40); } catch(e) {}

  // Most robust: if app exposes finalizeScanWithValue
  if (typeof window.finalizeScanWithValue === "function") {
    window.finalizeScanWithValue(cleanVal);
    return;
  }

  // If app has finalizeScan(), make it see this value
  if (typeof window.finalizeScan === "function") {
    const prev = scanInput.value;
    scanInput.value = cleanVal;
    try { window.finalizeScan(); }
    finally { /* finalizeScan usually clears it; if not, restore to empty */ }
    return;
  }

  // Fallback
  console.warn("No finalizeScan() found; scanned:", cleanVal);
}

function __scan_processNow(){
  if (__scan_timer) { clearTimeout(__scan_timer); __scan_timer = null; }
  const raw = scanInput.value;
  const cleaned = __scan_clean(raw);

  // Many scanners type 12-14 digits (UPC/EAN) or 10/13 (ISBN)
  if (cleaned.length >= 10) {
    // Clear immediately so next scan doesn't append
    scanInput.value = "";
    __scan_callFinalize(cleaned);
  }
}

scanInput.oninput = () => {
  if (__scan_timer) clearTimeout(__scan_timer);
  // short inactivity window; scanners type in ~50ms bursts
  __scan_timer = setTimeout(__scan_processNow, 80);
};

scanInput.onkeydown = (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    __scan_processNow();
  }
};

// Keep focus for scanner
setTimeout(()=>{ try{ scanInput.focus(); }catch(e){} }, 50);
scanInput.focus();

/* ==================== UPDATE ENGINE BADGE ==================== */
function updateEngineBadge() {
  const badge = document.getElementById("engineName");
  badge.textContent = CONFIG.useGemini ? "Gemini AI" : "Local Engine";
}

function updateKeepaIndicator() {
  const keepaBadge = document.getElementById("keepaBadge");
  if (CONFIG.keepaKey) {
    keepaBadge.style.display = "flex";
  } else {
    keepaBadge.style.display = "none";
  }
}

// Update on load
updateEngineBadge();
updateKeepaIndicator();

/* ==================== HELPER: Switch to Local Engine ==================== */
window.useLocalEngine = function() {
  CONFIG.useGemini = false;
  localStorage.setItem('useGemini', 'false');
  updateEngineBadge();
  console.log('‚úÖ Switched to Local Engine. Refresh not needed.');
};

/* ==================== DOUBLE CHECK WITH GEMINI ==================== */
document.getElementById("doubleCheckGeminiBtn").onclick = async () => {
  if (!lastScanData) return;
  if (!CONFIG.geminiKey) {
    alert('‚ö†Ô∏è Please add your Gemini API key in Settings first');
    return;
  }
  
  const btn = document.getElementById("doubleCheckGeminiBtn");
  
  // Show loading state
  btn.disabled = true;
  btn.textContent = "ü§ñ Analyzing...";
  
  try {
    const { keepaData } = lastScanData;
    
    // Re-analyze with Gemini
    const geminiDecision = await analyzeWithGemini(keepaData);
    
    // Update display with Gemini's decision
    displayResult(geminiDecision, keepaData);
    
    document.getElementById("statusText").textContent = `GEMINI: ${geminiDecision.verdict}: ${keepaData.title}`;
    
    // Update the button text to show it was Gemini's analysis
    btn.textContent = "‚úÖ Gemini Analysis Complete";
    setTimeout(() => {
      btn.textContent = "ü§ñ Double Check with Gemini";
      btn.disabled = false;
    }, 2000);
    
  } catch (error) {
    console.error('Gemini double-check error:', error);
    alert(`‚ùå Gemini Error: ${error.message}\n\nCheck your API key in Settings.`);
    btn.disabled = false;
    btn.textContent = "ü§ñ Double Check with Gemini";
  }
};

/* ==================== SLIDERS ==================== */
const bcSlider = document.getElementById("buyCostSlider");
const pfSlider = document.getElementById("profitFloorSlider");

let sliderTimeout = null;

bcSlider.oninput = () => {
  BUY_COST = parseFloat(bcSlider.value);
  document.getElementById("buyCostVal").textContent = BUY_COST.toFixed(2);
  
  // Debounce reanalysis
  clearTimeout(sliderTimeout);
  sliderTimeout = setTimeout(() => {
    if (lastScanData) reanalyzeWithNewThresholds();
  }, 300);
};

pfSlider.oninput = () => {
  PROFIT_FLOOR = parseFloat(pfSlider.value);
  document.getElementById("profitFloorVal").textContent = PROFIT_FLOOR.toFixed(2);
  
  // Debounce reanalysis
  clearTimeout(sliderTimeout);
  sliderTimeout = setTimeout(() => {
    if (lastScanData) reanalyzeWithNewThresholds();
  }, 300);
};

/* ==================== SETTINGS ==================== */
document.getElementById("settingsBtn").onclick = () => {
  document.getElementById("mainPage").style.display = "none";
  document.getElementById("settingsPage").style.display = "block";
  document.getElementById("keepaKey").value = CONFIG.keepaKey;
  document.getElementById("geminiKey").value = CONFIG.geminiKey;
  document.getElementById("useGemini").value = CONFIG.useGemini ? "true" : "false";
};

document.getElementById("saveSettings").onclick = () => {
  CONFIG.keepaKey = document.getElementById("keepaKey").value.trim();
  CONFIG.geminiKey = document.getElementById("geminiKey").value.trim();
  CONFIG.useGemini = document.getElementById("useGemini").value === "true";
  
  localStorage.setItem('keepaKey', CONFIG.keepaKey);
  localStorage.setItem('geminiKey', CONFIG.geminiKey);
  localStorage.setItem('useGemini', CONFIG.useGemini);
  
  updateEngineBadge();
  updateKeepaIndicator();
  
  alert('‚úÖ Settings saved!');
  document.getElementById("settingsPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

document.getElementById("backFromSettings").onclick = () => {
  document.getElementById("settingsPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

/* ==================== FINALIZE SCAN ==================== */
async function finalizeScan() {
  const input = scanInput.value.trim();
  scanInput.value = "";
  scanInput.focus();

  if (!input) return;
  
  // Vibrate feedback
  if (navigator.vibrate) navigator.vibrate(40);
  
  // Check API keys
  if (!CONFIG.keepaKey) {
    console.warn('No Keepa key - using mock data');
  }
  
  if (CONFIG.useGemini && !CONFIG.geminiKey) {
    alert('‚ö†Ô∏è Gemini is enabled but no API key provided. Falling back to local engine.');
    CONFIG.useGemini = false;
  }
  
  // Detect input type
  const identifier = detectInputType(input);
  
  if (checkDuplicate(identifier)) return;
  
  document.getElementById("statusText").textContent = `Processing: ${identifier}`;
  
  // Show processing state
  document.getElementById("processing").style.display = "block";
  document.getElementById("resultCard").classList.add("hidden");
  
  try {
    // Step 1: Query Keepa
    const keepaData = await queryKeepa(identifier, input);
    
    if (!keepaData) {
      throw new Error("Item not found in Keepa database");
    }
    
    // Step 2: Analyze with local engine (not Gemini - that's only for double-checking)
    const decision = localDecisionEngine(keepaData);
    
    // Step 3: Display result
    displayResult(decision, keepaData);
    
    // Step 4: Add to history
    addToHistory(decision, keepaData);
    
    document.getElementById("statusText").textContent = `${decision.verdict}: ${keepaData.title}`;
    document.getElementById("processing").style.display = "none";
    
  } catch (error) {
    console.error('Scan error:', error);
    
    // More specific error messages
    let errorMsg = error.message;
    if (errorMsg.includes('Failed to fetch')) {
      errorMsg = 'Network error. Check your internet connection.';
    } else if (errorMsg.includes('API key')) {
      errorMsg = 'Invalid API key. Check Settings.';
    } else if (errorMsg.includes('not found')) {
      errorMsg = 'Product not found in database.';
    }
    
    document.getElementById("statusText").textContent = "Error ‚Äî try again";
    document.getElementById("processing").style.display = "none";
    
    // Show error in result card
    document.getElementById("resultCard").classList.remove("hidden");
    document.getElementById("banner").className = "banner pass";
    document.getElementById("decision").textContent = "ERROR";
    document.getElementById("reason").textContent = errorMsg;
    document.getElementById("explanation").innerHTML = `‚ö†Ô∏è ${error.message}`;
  }
}

/* ==================== INPUT DETECTION ==================== */
function detectInputType(input) {
  const cleaned = input.replace(/[^0-9X]/gi, '');
  
  // ISBN-10 or ISBN-13
  if (cleaned.length === 10 || cleaned.length === 13) {
    return cleaned;
  }
  
  // UPC/EAN (12-14 digits)
  if (cleaned.length >= 12 && cleaned.length <= 14) {
    return cleaned;
  }
  
  // ASIN (B + 9 alphanumeric)
  if (/^B[0-9A-Z]{9}$/i.test(input)) {
    return input.toUpperCase();
  }
  
  // Otherwise treat as title search
  return input;
}

/* ==================== DUPLICATE CHECK ==================== */
function checkDuplicate(identifier) {
  if (seenIdentifiers.has(identifier)) {
    document.getElementById("dupeWarning").style.display = "block";
    setTimeout(() => document.getElementById("dupeWarning").style.display = "none", 2000);
    return true;
  }
  seenIdentifiers.add(identifier);
  return false;
}

/* ==================== KEEPA API ==================== */
async function queryKeepa(identifier, rawInput) {
  // Check if we have a Keepa key
  if (!CONFIG.keepaKey) {
    console.warn('No Keepa key - using mock data');
    return getMockKeepaData(identifier, rawInput);
  }
  
  try {
    // Keepa Product API endpoint
    const domain = 1; // 1 = US Amazon (.com)
    
    // Build query based on identifier type
    let queryParam = '';
    const isNumeric = /^[0-9X]+$/i.test(identifier);
    
    if (isNumeric) {
      // ISBN/UPC/EAN
      queryParam = `code=${encodeURIComponent(identifier)}`;
    } else if (/^B[0-9A-Z]{9}$/i.test(identifier)) {
      // ASIN
      queryParam = `asin=${encodeURIComponent(identifier)}`;
    } else {
      // Title search - need to get ASIN first
      // For now, throw error - title search is complex
      throw new Error('Title search not yet implemented. Please scan ISBN/UPC or enter ASIN.');
    }
    
    // Stats parameter: 0 = current prices, 1 = sales rank history
    // We want current prices (Amazon, New, Used, etc.) and basic stats
    const stats = 0; // Current prices only
    const history = 0; // No historical data (saves tokens)
    
    const url = `https://api.keepa.com/product?key=${CONFIG.keepaKey}&domain=${domain}&${queryParam}&stats=${stats}&history=${history}`;
    
    console.log('Keepa API call:', url.replace(CONFIG.keepaKey, 'HIDDEN'));
    
    const response = await fetch(url);
    
    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit reached. Please wait a moment.');
      }
      throw new Error(`Keepa API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Check if product found
    if (!data.products || data.products.length === 0) {
      throw new Error('Product not found in Keepa database');
    }
    
    const product = data.products[0];
    
    // Parse Keepa data
    return parseKeepaProduct(product);
    
  } catch (error) {
    console.error('Keepa query error:', error);
    throw error;
  }
}

/* ==================== PARSE KEEPA PRODUCT ==================== */
function parseKeepaProduct(product) {
  console.log('Raw Keepa product data:', product);
  
  // Keepa uses -1 to indicate no data
  const getPrice = (val) => (val === -1 || val === null || val === undefined) ? 0 : val / 100;
  const getCount = (val) => (val === -1 || val === null || val === undefined) ? 0 : val;
  
  // Current prices from csv array (Keepa stores in cents, -1 = no data)
  // According to Keepa API docs:
  // csv[0] = Amazon price
  // csv[1] = Marketplace New
  // csv[2] = Marketplace Used  
  // csv[18] = Buy Box (what we want for current competitive price)
  const currentPriceAmazon = getPrice(product.csv?.[0]?.[product.csv[0]?.length - 1]); // Last Amazon price
  const currentPriceNew = getPrice(product.csv?.[1]?.[product.csv[1]?.length - 1]); // Last New price
  const currentPriceBuyBox = getPrice(product.csv?.[18]?.[product.csv[18]?.length - 1]); // Last Buy Box price
  
  // Use Buy Box price as our competitive price, fall back to New price
  const currentPriceFBA = currentPriceBuyBox > 0 ? currentPriceBuyBox : currentPriceNew;
  const currentPriceFBM = currentPriceNew; // Simplified - treating marketplace new as FBM
  
  // Offer counts from stats
  const offerCountFBA = getCount(product.offersSuccessful); // Total FBA offers
  const offerCountFBM = getCount(product.offers ? product.offers.length : 0); // FBM offers
  
  // Sales rank from csv[3]
  const salesRankArray = product.csv?.[3];
  const salesRank = salesRankArray && salesRankArray.length > 0 
    ? getCount(salesRankArray[salesRankArray.length - 1]) 
    : 999999;
  
  // Sales rank drops from stats
  const salesRankDrops30 = getCount(product.stats?.salesRankDrops30) || 0;
  const salesRankDrops90 = getCount(product.stats?.salesRankDrops90) || 0;
  
  console.log('Parsed prices:', {
    amazon: currentPriceAmazon,
    fba: currentPriceFBA,
    fbm: currentPriceFBM,
    salesRank: salesRank
  });
  
  // Determine Buy Box winner
  let buyBoxWinner = "NONE";
  if (currentPriceAmazon > 0 && (currentPriceAmazon <= currentPriceFBA || currentPriceFBA === 0) && (currentPriceAmazon <= currentPriceFBM || currentPriceFBM === 0)) {
    buyBoxWinner = "AMAZON";
  } else if (currentPriceFBA > 0 && (currentPriceFBA < currentPriceFBM || currentPriceFBM === 0)) {
    buyBoxWinner = "FBA";
  } else if (currentPriceFBM > 0) {
    buyBoxWinner = "FBM";
  }
  
  // Price volatility (simplified - would need historical data for accurate calc)
  const priceVolatility = "STABLE"; // Placeholder
  
  const parsedData = {
    asin: product.asin,
    title: product.title || 'Unknown Title',
    salesRank: salesRank,
    salesRankDrops30: salesRankDrops30,
    salesRankDrops90: salesRankDrops90,
    currentPriceAmazon: currentPriceAmazon,
    currentPriceFBA: currentPriceFBA,
    currentPriceFBM: currentPriceFBM,
    buyBoxWinner: buyBoxWinner,
    offerCountFBA: offerCountFBA,
    offerCountFBM: offerCountFBM,
    priceVolatility: priceVolatility,
    weight: product.packageWeight ? product.packageWeight / 100 : 1.0, // Keepa stores in 0.01 lb units
    publicationDate: product.releaseDate ? new Date(product.releaseDate * 60000) : null // Keepa time is in minutes since epoch
  };
  
  console.log('Final parsed data:', parsedData);
  return parsedData;
}


/* ==================== MOCK KEEPA DATA (for testing) ==================== */
function getMockKeepaData(identifier, rawInput) {
  console.log('Using mock data for:', identifier);
  
  // Generate semi-random but consistent data based on identifier
  const hash = identifier.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  
  return {
    asin: `B${identifier.slice(0, 9).padEnd(9, '0')}`,
    title: `Mock Book: ${rawInput}`,
    salesRank: 50000 + (hash % 200000),
    salesRankDrops30: Math.floor(hash % 50),
    salesRankDrops90: Math.floor(hash % 150),
    currentPriceAmazon: hash % 3 === 0 ? 15 + (hash % 20) : 0,
    currentPriceFBA: 12 + (hash % 15),
    currentPriceFBM: 10 + (hash % 18),
    buyBoxWinner: hash % 3 === 0 ? "AMAZON" : (hash % 2 === 0 ? "FBA" : "FBM"),
    offerCountFBA: Math.floor(hash % 15) + 1,
    offerCountFBM: Math.floor(hash % 10),
    priceVolatility: "STABLE",
    weight: 0.5 + (hash % 20) / 10,
    publicationDate: new Date(2020 + (hash % 5), hash % 12, 1)
  };
}

/* ==================== GEMINI ANALYSIS ENGINE ==================== */
async function analyzeWithGemini(keepaData) {
  if (!CONFIG.geminiKey) {
    throw new Error('Gemini API key not configured');
  }
  
  try {
    const prompt = `You are an expert Amazon FBA book reseller. Analyze this product and make a BUY/PASS decision.

PRODUCT DATA:
- Title: ${keepaData.title}
- ASIN: ${keepaData.asin}
- Sales Rank: ${keepaData.salesRank.toLocaleString()}
- Rank Drops (30d): ${keepaData.salesRankDrops30}
- Rank Drops (90d): ${keepaData.salesRankDrops90}
- Current FBA Price: $${keepaData.currentPriceFBA}
- Current FBM Price: $${keepaData.currentPriceFBM}
- Amazon Price: ${keepaData.currentPriceAmazon > 0 ? '$' + keepaData.currentPriceAmazon : 'Not selling'}
- Buy Box Winner: ${keepaData.buyBoxWinner}
- FBA Sellers: ${keepaData.offerCountFBA}
- FBM Sellers: ${keepaData.offerCountFBM}
- Weight: ${keepaData.weight}lb

MY CONSTRAINTS:
- Buy Cost: $${BUY_COST}
- Minimum Profit Target: $${PROFIT_FLOOR}
- FBA Fees: ~15% of selling price + $5 fixed
- Shipping to Amazon: $0.75

DECISION RULES:
1. If Amazon controls Buy Box: Can only compete if we can undercut Amazon by 5% AND still hit profit target
2. If FBA seller has Buy Box: We can undercut by 3%
3. If FBM seller has Buy Box: We can undercut by 2%
4. Sales Rank < 100k = EXCELLENT, 100k-300k = GOOD, 300k-500k = OK, >500k = RISKY
5. More rank drops = more sales velocity = better
6. Must account for weight (heavier = higher FBA fees)

OUTPUT FORMAT (JSON only, no markdown):
{
  "verdict": "ACCEPT" or "REJECT",
  "targetPrice": <number>,
  "profit": <number>,
  "roi": <number>,
  "reasoning": "<2-3 sentence explanation with ‚úì or ‚úó bullets>"
}`;

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${CONFIG.geminiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
          temperature: 0.3,
          maxOutputTokens: 300
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const resultText = data.candidates[0].content.parts[0].text;
    
    // Parse JSON from response (handle markdown code blocks)
    const jsonMatch = resultText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Invalid Gemini response format');
    }
    
    const result = JSON.parse(jsonMatch[0]);
    
    // Validate and sanitize
    return {
      verdict: result.verdict === "ACCEPT" ? "ACCEPT" : "REJECT",
      targetPrice: Math.round(parseFloat(result.targetPrice) * 100) / 100,
      profit: Math.round(parseFloat(result.profit) * 100) / 100,
      roi: parseInt(result.roi),
      reasoning: result.reasoning
    };
    
  } catch (error) {
    console.error('Gemini analysis error:', error);
    throw error;
  }
}

/* ==================== HIDDEN GEMS DETECTION ==================== */
function detectHiddenGems(keepaData, decision) {
  const gems = [];
  const title = keepaData.title.toLowerCase();
  
  // CRITICAL: Only detect gems for ACCEPT decisions with positive profit
  if (decision.verdict !== "ACCEPT" || decision.profit < PROFIT_FLOOR) {
    return gems; // No gems for rejects or unprofitable items
  }
  
  // GEM 1: High ROI despite borderline profit
  if (decision.roi >= 200 && decision.profit >= PROFIT_FLOOR * 0.8) {
    gems.push({
      type: 'high-roi',
      icon: 'üöÄ',
      label: 'Exceptional ROI',
      details: `${decision.roi}% return on investment`
    });
  }
  
  // GEM 2: Low competition FBA
  if (keepaData.offerCountFBA <= 3 && keepaData.salesRank < 200000) {
    gems.push({
      type: 'low-competition',
      icon: 'üíé',
      label: 'Low FBA competition',
      details: `Only ${keepaData.offerCountFBA} FBA sellers on good rank`
    });
  }
  
  // GEM 3: Amazon controls BB but we can still profit
  if (keepaData.buyBoxWinner === "AMAZON" && decision.verdict === "ACCEPT") {
    gems.push({
      type: 'amazon-gap',
      icon: 'üéØ',
      label: 'Amazon gap opportunity',
      details: 'Can undercut Amazon profitably'
    });
  }
  
  // GEM 4: High velocity (lots of sales)
  if (keepaData.salesRankDrops30 >= 30) {
    gems.push({
      type: 'high-velocity',
      icon: '‚ö°',
      label: 'Fast seller',
      details: `${keepaData.salesRankDrops30} rank drops in 30 days`
    });
  }
  
  // GEM 5: Price protection (high margin despite fees)
  if (decision.profit >= PROFIT_FLOOR * 1.5) {
    gems.push({
      type: 'price-cushion',
      icon: 'üõ°Ô∏è',
      label: 'Price cushion',
      details: `$${decision.profit.toFixed(2)} profit gives pricing flexibility`
    });
  }
  
  // GEM 6: Top 50k sales rank
  if (keepaData.salesRank < 50000) {
    gems.push({
      type: 'top-rank',
      icon: 'üëë',
      label: 'Top 50k rank',
      details: 'Excellent sales velocity'
    });
  }
  
  // GEM 7: Lightweight (lower fees)
  if (keepaData.weight < 1.0 && decision.profit > PROFIT_FLOOR) {
    gems.push({
      type: 'lightweight',
      icon: 'ü™∂',
      label: 'Lightweight advantage',
      details: 'Lower FBA fees boost margins'
    });
  }
  
  // GEM 8: Steady seller (90-day consistency)
  if (keepaData.salesRankDrops90 >= 60 && keepaData.salesRankDrops30 >= 15) {
    gems.push({
      type: 'steady-seller',
      icon: 'üìà',
      label: 'Consistent sales',
      details: 'Strong 90-day track record'
    });
  }
  
  // GEM 9: FBM dominant but FBA opportunity
  if (keepaData.buyBoxWinner === "FBM" && keepaData.offerCountFBA <= 2 && decision.verdict === "ACCEPT") {
    gems.push({
      type: 'fba-upgrade',
      icon: 'üì¶',
      label: 'FBA upgrade play',
      details: 'Win Buy Box with Prime shipping'
    });
  }
  
  // GEM 10: Monopoly opportunity
  if (keepaData.offerCountFBA === 0 && keepaData.salesRank < 300000) {
    gems.push({
      type: 'monopoly',
      icon: 'üèÜ',
      label: 'FBA monopoly',
      details: 'Be the only FBA seller'
    });
  }
  
  // GEM 11: Rising rank (improving sales)
  const rankImprovement = keepaData.salesRankDrops30 / Math.max(1, keepaData.salesRankDrops90 / 3);
  if (rankImprovement >= 1.5) {
    gems.push({
      type: 'rising-trend',
      icon: 'üìä',
      label: 'Sales trending up',
      details: 'Recent velocity increasing'
    });
  }
  
  // GEM 12: High profit absolute
  if (decision.profit >= 15) {
    gems.push({
      type: 'high-profit',
      icon: 'üí∞',
      label: 'High profit margin',
      details: `$${decision.profit.toFixed(2)} profit per unit`
    });
  }
  
  // GEM 13: Sweet spot rank (100k-200k)
  if (keepaData.salesRank >= 100000 && keepaData.salesRank <= 200000 && decision.profit >= PROFIT_FLOOR) {
    gems.push({
      type: 'sweet-spot',
      icon: 'üé™',
      label: 'Sweet spot rank',
      details: 'Good velocity without high competition'
    });
  }
  
  // GEM 14: No Amazon competition
  if (keepaData.currentPriceAmazon === 0 && keepaData.salesRank < 200000) {
    gems.push({
      type: 'no-amazon',
      icon: 'üö´',
      label: 'Amazon not competing',
      details: 'Third-party sellers only'
    });
  }
  
  // GEM 15: Double ROI minimum
  if (decision.roi >= 100 && decision.profit >= PROFIT_FLOOR) {
    gems.push({
      type: 'double-roi',
      icon: 'üé∞',
      label: 'Double your money',
      details: `${decision.roi}% ROI`
    });
  }
  
  // GEM 16: Underpriced market
  if (keepaData.currentPriceFBA > 0 && decision.targetPrice >= keepaData.currentPriceFBA * 1.1) {
    gems.push({
      type: 'underpriced',
      icon: 'üí∏',
      label: 'Underpriced market',
      details: 'Current pricing leaves room'
    });
  }
  
  // GEM 17: Niche dominance (few sellers, good rank)
  if ((keepaData.offerCountFBA + keepaData.offerCountFBM) <= 5 && keepaData.salesRank < 150000) {
    gems.push({
      type: 'niche',
      icon: 'üéØ',
      label: 'Niche opportunity',
      details: 'Low competition in active market'
    });
  }
  
  // GEM 18: Buy Box ready (can win immediately)
  if (keepaData.buyBoxWinner === "FBA" && decision.targetPrice < keepaData.currentPriceFBA) {
    gems.push({
      type: 'bb-ready',
      icon: 'üéÅ',
      label: 'Buy Box ready',
      details: 'Will win Buy Box immediately'
    });
  }
  
  // GEM 19: Seasonal timing (basic detection)
  const month = new Date().getMonth();
  const seasonal = (month >= 10 || month <= 1) && (title.includes('christmas') || title.includes('holiday') || title.includes('winter'));
  if (seasonal) {
    gems.push({
      type: 'seasonal',
      icon: 'üéØ',
      label: 'Seasonal timing',
      details: 'Peak demand window for this topic'
    });
  }
  
  // GEM 20: New release momentum
  if (keepaData.publicationDate) {
    const pubDate = new Date(keepaData.publicationDate);
    const monthsOld = (Date.now() - pubDate.getTime()) / (1000 * 60 * 60 * 24 * 30);
    if (monthsOld < 6 && keepaData.salesRank < 100000) {
      gems.push({
        type: 'new-release',
        icon: 'üÜï',
        label: 'New release momentum',
        details: `Published ${Math.round(monthsOld)} months ago with strong rank`
      });
    }
  }
  
  // GEM 21: Textbook potential
  if (decision.targetPrice > 30 && (title.includes('edition') || title.includes('textbook'))) {
    gems.push({
      type: 'textbook',
      icon: 'üéì',
      label: 'Textbook potential',
      details: 'High-value educational book'
    });
  }
  
  // GEM 22: Collectible premium
  if (keepaData.condition && keepaData.condition.includes('Collectible') && decision.profit > 8) {
    gems.push({
      type: 'collectible',
      icon: 'üè∫',
      label: 'Collectible premium',
      details: 'Collectible condition commands higher prices'
    });
  }
  
  // GEM 23: First edition
  if (title.includes('first edition') || title.includes('1st edition')) {
    gems.push({
      type: 'first-edition',
      icon: 'üìñ',
      label: 'First edition',
      details: 'First editions have collector value'
    });
  }
  
  // GEM 24: Out of print
  if (keepaData.outOfPrint) {
    gems.push({
      type: 'out-of-print',
      icon: 'üîí',
      label: 'Out of print',
      details: 'Limited supply increases value'
    });
  }
  
  // GEM 25: Floor protection working
  if (decision.targetPrice === 8.00 && decision.profit >= 5) {
    gems.push({
      type: 'floor-protection',
      icon: 'üõ°Ô∏è',
      label: 'Floor protection active',
      details: 'Raised to $8 floor but still profitable'
    });
  }
  
  return gems;
}

/* ==================== LOCAL FALLBACK DECISION ENGINE ==================== */
function localDecisionEngine(keepaData) {
  // Determine target price based on Buy Box
  let targetPrice = keepaData.currentPriceFBA;
  
  if (keepaData.buyBoxWinner === "AMAZON") {
    targetPrice = keepaData.currentPriceAmazon * 0.95;
  } else if (keepaData.buyBoxWinner === "FBM") {
    targetPrice = keepaData.currentPriceFBM * 0.98;
  } else if (keepaData.buyBoxWinner === "FBA") {
    targetPrice = keepaData.currentPriceFBA * 0.97;
  }
  
  // CRITICAL: Apply $8 minimum floor price for FBA
  // FBA fees make anything below $8 unprofitable
  const MINIMUM_PRICE = 8.00;
  if (targetPrice < MINIMUM_PRICE) {
    targetPrice = MINIMUM_PRICE;
  }
  
  // Calculate profit (FBA model: buy cost + $0.75 shipping to Amazon + FBA fees)
  const shippingToAmazon = 0.75;
  const totalCOGS = BUY_COST + shippingToAmazon;
  const fees = targetPrice * 0.15 + 5;
  const profit = targetPrice - totalCOGS - fees;
  const roi = Math.round((profit / totalCOGS) * 100);
  
  // Make decision
  let verdict = "REJECT";
  let reasoning = "";
  
  if (keepaData.buyBoxWinner === "AMAZON" && keepaData.currentPriceAmazon > 0) {
    if (profit >= PROFIT_FLOOR) {
      verdict = "ACCEPT";
      reasoning = `‚úì Can undercut Amazon profitably<br>‚úì Profit: $${profit.toFixed(2)} (${roi}% ROI)<br>‚úì Target: $${targetPrice.toFixed(2)}`;
    } else {
      reasoning = `‚úó Amazon controls Buy Box<br>‚úó Cannot compete profitably<br>‚úó Profit would be: $${profit.toFixed(2)}`;
    }
  } else if (profit < 0) {
    reasoning = `‚úó Not profitable<br>‚úó Loss: $${Math.abs(profit).toFixed(2)}<br>‚úó Fees too high relative to price`;
  } else if (profit < PROFIT_FLOOR) {
    reasoning = `‚úó Profit $${profit.toFixed(2)} below $${PROFIT_FLOOR.toFixed(2)} floor<br>‚úó ROI: ${roi}%<br>‚úó Not worth the capital`;
  } else if (keepaData.salesRank > 500000) {
    reasoning = `‚ö† High sales rank (${keepaData.salesRank.toLocaleString()})<br>‚ö† Profitable but slow mover<br>‚ö† Consider passing unless high ROI`;
  } else {
    verdict = "ACCEPT";
    reasoning = `‚úì Profit: $${profit.toFixed(2)} (${roi}% ROI)<br>‚úì ${keepaData.buyBoxWinner} controls Buy Box<br>‚úì Good sales rank: ${keepaData.salesRank.toLocaleString()}`;
  }
  
  return {
    verdict,
    targetPrice: Math.round(targetPrice * 100) / 100,
    profit: Math.round(profit * 100) / 100,
    roi,
    reasoning
  };
}

/* ==================== DISPLAY RESULT ==================== */
function displayResult(decision, keepaData) {
  lastScanData = { decision, keepaData };
  
  const banner = document.getElementById("banner");
  const cls = decision.verdict === "ACCEPT" ? "buy" : "pass";
  
  // Detect hidden gems
  const gems = detectHiddenGems(keepaData, decision);
  const isGem = gems.length > 0;
  
  banner.className = `banner ${cls}${isGem ? ' gem' : ''}`;
  
  // Show/hide gem badge
  const gemBadge = document.getElementById("gemBadge");
  if (isGem) {
    gemBadge.style.display = "inline-flex";
  } else {
    gemBadge.style.display = "none";
  }
  
  document.getElementById("decision").textContent = decision.verdict;
  document.getElementById("reason").textContent = keepaData.title;
  
  document.getElementById("targetPrice").textContent = `$${decision.targetPrice.toFixed(2)}`;
  document.getElementById("profit").textContent = `$${decision.profit.toFixed(2)}`;
  document.getElementById("roi").textContent = `${decision.roi}%`;
  document.getElementById("bb").textContent = keepaData.buyBoxWinner;
  
  const profitEl = document.getElementById("profit");
  profitEl.className = "stat-value" + (decision.profit < 0 ? " negative" : "");
  
  // Build explanation with gem reasons
  let explanationHTML = decision.reasoning;
  
  if (isGem) {
    explanationHTML += '<div class="gem-reasons"><strong>Why This is a Hidden Gem:</strong>';
    gems.forEach(gem => {
      explanationHTML += `<div style="margin:6px 0;">${gem.icon} <strong>${gem.label}:</strong> ${gem.details}</div>`;
    });
    explanationHTML += '</div>';
  }
  
  document.getElementById("explanation").innerHTML = explanationHTML;
  
  // Show Double Check with Gemini button (if Gemini key configured)
  const doubleCheckBtn = document.getElementById("doubleCheckGeminiBtn");
  if (CONFIG.geminiKey) {
    doubleCheckBtn.style.display = "block";
  } else {
    doubleCheckBtn.style.display = "none";
  }
  
  document.getElementById("resultCard").classList.remove("hidden");
  document.getElementById("resultCard").classList.add("flash");
  setTimeout(() => document.getElementById("resultCard").classList.remove("flash"), 300);
}

/* ==================== REANALYZE ==================== */
async function reanalyzeWithNewThresholds() {
  if (!lastScanData) return;
  
  // Don't show spinner for reanalysis - update in place
  // Always use local engine for reanalysis (not Gemini)
  try {
    const decision = localDecisionEngine(lastScanData.keepaData);
    displayResult(decision, lastScanData.keepaData);
    document.getElementById("statusText").textContent = `${decision.verdict}: ${lastScanData.keepaData.title}`;
  } catch (error) {
    console.error('Reanalysis error:', error);
    // Silently fail - keep showing old data
  }
}

/* ==================== HISTORY ==================== */
function addToHistory(decision, keepaData) {
  const gems = detectHiddenGems(keepaData, decision);
  
  const record = {
    verdict: decision.verdict,
    title: keepaData.title,
    asin: keepaData.asin,
    price: decision.targetPrice.toFixed(2),
    profit: decision.profit.toFixed(2),
    roi: decision.roi,
    time: new Date().toLocaleTimeString(),
    isGem: gems.length > 0,
    gemTypes: gems.map(g => g.label).join(', ')
  };
  
  scanHistory.push(record);
  if (decision.verdict === "ACCEPT") {
    buyList.push(record);
  }
  
  updateHistoryUI();
  document.getElementById("itemCount").innerHTML = `<span class="status-label">Queue:</span> ${buyList.length}`;
}

function updateHistoryUI() {
  const list = document.getElementById("historyList");
  list.innerHTML = '';
  
  scanHistory.slice().reverse().forEach(rec => {
    const div = document.createElement("div");
    div.className = "history-item";
    
    const gemBadge = rec.isGem ? `<span style="color:#fbbf24;font-size:14px;margin-right:4px;">‚ú®</span>` : '';
    
    div.innerHTML = `
      <div class="history-decision ${rec.verdict}">${gemBadge}${rec.verdict}</div>
      <div class="history-title">${rec.title}</div>
      <div class="history-meta">
        ASIN: ${rec.asin}<br>
        Price: $${rec.price} ‚Ä¢ Profit: $${rec.profit} ‚Ä¢ ROI: ${rec.roi}%<br>
        ${rec.isGem ? `<span style="color:#fbbf24;">üíé ${rec.gemTypes}</span><br>` : ''}
        ${rec.time}
      </div>
    `;
    list.appendChild(div);
  });
}

/* ==================== NAVIGATION ==================== */
document.getElementById("historyBtn").onclick = () => {
  document.getElementById("mainPage").style.display = "none";
  document.getElementById("historyPage").style.display = "block";
};

document.getElementById("backBtn").onclick = () => {
  document.getElementById("historyPage").style.display = "none";
  document.getElementById("mainPage").style.display = "block";
};

/* ==================== CSV DOWNLOAD ==================== */
document.getElementById("downloadBtn").onclick = () => {
  if (buyList.length === 0) return alert("No items in buy queue.");

  let csv = "Title,ASIN,TargetPrice,Profit,ROI,HiddenGem,GemReasons\n";
  buyList.forEach(r => {
    const gemFlag = r.isGem ? 'YES' : 'NO';
    const gemReasons = r.isGem ? `"${r.gemTypes}"` : '';
    csv += `"${r.title}",${r.asin},${r.price},${r.profit},${r.roi}%,${gemFlag},${gemReasons}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `scoutpro_buylist_${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
};

/* ==================== CLEAR DATA ==================== */
document.getElementById("clearBtn").onclick = () => {
  if (!confirm("Clear all scan data and buy queue?")) return;

  scanHistory.length = 0;
  buyList.length = 0;
  lastScanData = null;
  seenIdentifiers.clear();

  document.getElementById("historyList").innerHTML = "";
  document.getElementById("itemCount").innerHTML = `<span class="status-label">Queue:</span> 0`;
  document.getElementById("statusText").textContent = "Ready to scan";
  document.getElementById("resultCard").classList.add("hidden");
};
</script>

</body>
</html>
